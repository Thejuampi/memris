# Task 01: ByteBuddy Repository Generator - Complete Implementation Plan

## Objective

Eliminate **ALL runtime reflection** from Spring Data JPA-style repositories by using ByteBuddy to generate concrete repository implementations at factory creation time.

**Core Principle: Compile Once, Reuse Forever**
- All reflection happens **ONCE** during `createJPARepository()` call
- Generated bytecode has **ZERO** reflection overhead at runtime
- No maps, no field lookups, no method scanning
- Direct inline field access, pre-compiled TypeConverters, pre-compiled MethodHandles

---

## Architecture Overview

```
createJPARepository(ComputerRepository.class)
  ↓
MetadataExtractor.extractEntityMetadata(Computer.class)
  └─ ONE TIME: Scan fields, extract TypeConverters
  └─ ONE TIME: Find lifecycle methods, create MethodHandles
  └─ ONE TIME: Find ID field, constructor
  ↓
MetadataExtractor.extractQueryMethods(ComputerRepository.class)
  └─ ONE TIME: Parse all query method names
  └─ ONE TIME: Extract predicates, operators, return types
  ↓
EntityMetadata (data holder):
  - Class<T> entityClass
  - Constructor<T> entityConstructor
  - String idColumnName
  - List<FieldMapping> fields
  - Set<String> foreignKeyColumns
  - Map<String, TypeConverter<?, ?>> converters  ← NEW: Pre-compiled converters
  - MethodHandle prePersistHandle                 ← NEW: Lifecycle callbacks
  - MethodHandle postLoadHandle
  - MethodHandle preUpdateHandle
  ↓
RepositoryBytecodeGenerator.generateRepository()
  └─ Generates ComputerRepositoryByteBuddyImpl class
  └─ All methods: Inline bytecode with direct access
  └─ No maps, no reflection, no lookups
  ↓
Generated Repository:
  - save(T entity)        → Inline bytecode
  - findById(Object id)    → Inline bytecode with inline materialization
  - findByName(String name) → Inline bytecode with index fallback to scan
  - lifecycle callbacks     → Direct MethodHandle.invokeExact()
  - type conversions       → Direct TypeConverter.fieldToStorage()
```

---

## Current Violations to "Compile Once, Reuse Forever"

### CRITICAL: Hot Path Runtime Reflection

| File | Method | Lines | Violation | Fix |
|------|--------|-------|-----------|-----|
| `MemrisRepositoryFactory.java` | `doSave()` | 604-721 | `getDeclaredFields()` + `field.get()` on EVERY save | Move to generated bytecode |
| `MemrisRepositoryFactory.java` | `doSave()` | 604-615 | Scans for ID field on EVERY save | Pre-compile ID field name |
| `MemrisRepositoryFactory.java` | `updateIndexes()` | 808-828 | `getDeclaredFields()` + `field.get()` on EVERY update | Move to generated bytecode |
| `MemrisRepositoryFactory.java` | `invokePrePersist/PostLoad/PreUpdate()` | 990-1026 | `getDeclaredMethods()` + `method.invoke()` on EVERY call | Pre-compile MethodHandles |
| `MemrisRepositoryFactory.java` | `materializeSingle()` | 1069-1112 | `getDeclaredField()` for each column on EVERY materialize | Inline field access in bytecode |
| `MemrisRepositoryImpl.java` | `materialize()` | 306-378 | HashMap.get(MethodHandle) lookups | Direct inline field access |
| `MemrisRepositoryImpl.java` | `getAndCacheField()` | 272-283 | Lazy field cache with linear scan | Pre-compile all fields |

### Map-Based Lookup Violations

| Location | Issue | Fix |
|----------|-------|-----|
| `CompiledEntityMetadata` | HashMap lookups for MethodHandles | Inline direct access |
| `CompiledEntityMetadata` | HashMap lookups for types | Pre-compile in metadata |
| `TypeConverterRegistry` | HashMap lookups for converters | Pre-compile in metadata |
| `MemrisRepositoryFactory` | HashMap lookups for indexes | Generate inline index field access |

### Proxy Violation

| File | Method | Issue | Fix |
|------|--------|-------|-----|
| `MemrisInvocationHandler` | `invokeQueryMethod()` | Parses query method name EVERY call | ByteBuddy generates all query methods |

### ByteBuddy Prototype Violation

| File | Issue | Fix |
|------|-------|-----|
| `RepositoryBytecodeGenerator` | Interceptors use `getDeclaredField()` and `Field.get()` at runtime | Replace with Advice API + inline bytecode |

---

## Implementation Steps

### STEP 1: Update EntityMetadata.java

**File:** `G:\dev\repos\memris\memris-core\src\main\java\io\memris\spring\EntityMetadata.java`

**Changes:**
1. Add `Map<String, TypeConverter<?, ?>> converters` field
2. Add `MethodHandle prePersistHandle` field
3. Add `MethodHandle postLoadHandle` field
4. Add `MethodHandle preUpdateHandle` field
5. Update constructor to accept these parameters
6. Add accessor methods

**New EntityMetadata Structure:**
```java
public final class EntityMetadata<T> {
    final Class<T> entityClass;
    final Constructor<T> entityConstructor;
    final String idColumnName;
    final List<FieldMapping> fields;
    final Set<String> foreignKeyColumns;

    // NEW: Pre-compiled TypeConverters per field
    final Map<String, TypeConverter<?, ?>> converters;

    // NEW: Pre-compiled lifecycle callback MethodHandles
    final MethodHandle prePersistHandle;
    final MethodHandle postLoadHandle;
    final MethodHandle preUpdateHandle;

    // Constructor updated
    public EntityMetadata(
        Class<T> entityClass,
        Constructor<T> entityConstructor,
        String idColumnName,
        List<FieldMapping> fields,
        Set<String> foreignKeyColumns,
        Map<String, TypeConverter<?, ?>> converters,
        MethodHandle prePersistHandle,
        MethodHandle postLoadHandle,
        MethodHandle preUpdateHandle) { ... }

    // Accessor methods
    public Map<String, TypeConverter<?, ?>> converters() { return converters; }
    public MethodHandle prePersistHandle() { return prePersistHandle; }
    public MethodHandle postLoadHandle() { return postLoadHandle; }
    public MethodHandle preUpdateHandle() { return preUpdateHandle; }
}
```

---

### STEP 2: Update MetadataExtractor.java

**File:** `G:\dev\repos\memris\memris-core\src\main\java\io\memris\spring\MetadataExtractor.java`

**Changes to `extractEntityMetadata()`:**
1. Import `java.lang.invoke.MethodHandle` and `java.lang.invoke.MethodHandles`
2. Extract TypeConverter for each field
3. Create MethodHandles for lifecycle callbacks
4. Pass all to EntityMetadata constructor

**Updated extractEntityMetadata() method:**
```java
public static <T> EntityMetadata<T> extractEntityMetadata(Class<T> entityClass, FfmTable table) {
    try {
        // Get ID column name
        String idColumnName = findIdColumnName(entityClass);

        // Get entity constructor
        Constructor<T> constructor = entityClass.getDeclaredConstructor();

        // Extract field mappings
        List<EntityMetadata.FieldMapping> fields = new ArrayList<>();
        Set<String> foreignKeyColumns = new HashSet<>();

        // NEW: Extract TypeConverters for each field
        Map<String, TypeConverter<?, ?>> converters = new HashMap<>();

        for (Field field : entityClass.getDeclaredFields()) {
            if (field.isAnnotationPresent(Transient.class)) {
                continue;
            }

            String columnName = field.getName();
            Class<?> javaType = field.getType();
            Class<?> storageType = javaType;

            // Handle TypeConverter
            TypeConverter<?, ?> converter = TypeConverterRegistry.getInstance().getConverter(javaType);
            if (converter != null) {
                storageType = converter.getStorageType();
                converters.put(field.getName(), converter);
            }

            // Get column position
            int columnPosition = -1;
            int colIndex = 0;
            for (var col : table.columns()) {
                if (col.name().equals(columnName)) {
                    columnPosition = colIndex;
                    break;
                }
                colIndex++;
            }

            EntityMetadata.FieldMapping mapping = new EntityMetadata.FieldMapping(
                    field.getName(), columnName, javaType, storageType, columnPosition);
            fields.add(mapping);

            // Track foreign key columns
            if (columnName.endsWith("_id") && !columnName.equals(idColumnName)) {
                foreignKeyColumns.add(columnName);
            }
        }

        // NEW: Extract lifecycle callback MethodHandles
        MethodHandles.Lookup lookup = MethodHandles.lookup();
        MethodHandle prePersistHandle = null;
        MethodHandle postLoadHandle = null;
        MethodHandle preUpdateHandle = null;

        for (Method m : entityClass.getDeclaredMethods()) {
            if (m.getParameterCount() == 0 && m.getReturnType() == void.class) {
                m.setAccessible(true);
                if (m.isAnnotationPresent(PrePersist.class)) {
                    prePersistHandle = lookup.unreflect(m);
                } else if (m.isAnnotationPresent(PostLoad.class)) {
                    postLoadHandle = lookup.unreflect(m);
                } else if (m.isAnnotationPresent(PreUpdate.class)) {
                    preUpdateHandle = lookup.unreflect(m);
                }
            }
        }

        return new EntityMetadata<>(entityClass, constructor, idColumnName,
            fields, foreignKeyColumns, converters,
            prePersistHandle, postLoadHandle, preUpdateHandle);

    } catch (Exception e) {
        throw new RuntimeException("Failed to extract metadata for entity: " + entityClass.getName(), e);
    }
}
```

**Imports to add:**
```java
import java.lang.invoke.MethodHandle;
import java.lang.invoke.MethodHandles;
import java.lang.invoke.MethodType;
```

---

### STEP 3: Rewrite RepositoryBytecodeGenerator.java

**File:** `G:\dev\repos\memris\memris-core\src\main\java\io\memris\spring\RepositoryBytecodeGenerator.java`

**Complete rewrite using ByteBuddy Advice API:**

#### 3.1 Class Structure

```java
package io.memris.spring;

import net.bytebuddy.ByteBuddy;
import net.bytebuddy.asm.Advice;
import net.bytebuddy.description.modifier.Visibility;
import net.bytebuddy.dynamic.DynamicType;
import net.bytebuddy.implementation.FieldAccessor;

import io.memris.kernel.Predicate;
import io.memris.kernel.selection.SelectionVectorFactory;
import io.memris.storage.ffm.FfmTable;

import java.lang.reflect.Field;
import java.util.ArrayList;
import java.util.List;
import java.util.Optional;
import java.util.Map;

public final class RepositoryBytecodeGenerator {

    private final ByteBuddy byteBuddy;
    private final MemrisRepositoryFactory factory;

    public RepositoryBytecodeGenerator(MemrisRepositoryFactory factory) {
        this.byteBuddy = new ByteBuddy();
        this.factory = factory;
    }

    public <T, R extends MemrisRepository<T>> R generateRepository(
            Class<R> repositoryInterface,
            EntityMetadata<T> entityMetadata,
            FfmTable table,
            List<QueryMetadata> queryMethods) {
        String className = repositoryInterface.getSimpleName() + "ByteBuddyImpl";

        try {
            DynamicType.Builder<R> builder = byteBuddy
                .subclass(repositoryInterface)
                .name(repositoryInterface.getPackage().getName() + "." + className)

                // Add fields (ALL direct references, no maps!)
                .defineField("table", FfmTable.class, Visibility.PRIVATE)
                .defineField("factory", MemrisRepositoryFactory.class, Visibility.PRIVATE)
                .defineField("entityClass", Class.class, Visibility.PRIVATE)
                .defineField("idColumnName", String.class, Visibility.PRIVATE)
                .defineField("converters", Map.class, Visibility.PRIVATE)
                .defineField("fields", List.class, Visibility.PRIVATE)
                .defineField("postLoadHandle", MethodHandle.class, Visibility.PRIVATE)
                .defineField("prePersistHandle", MethodHandle.class, Visibility.PRIVATE)

                // Constructor - initializes all fields
                .defineConstructor(Visibility.PUBLIC)
                .withParameters(FfmTable.class, MemrisRepositoryFactory.class, EntityMetadata.class)
                .intercept(MethodCall.invoke(Object.class.getConstructor())
                    .andThen(FieldAccessor.ofField("table").setsArgumentAt(0))
                    .andThen(FieldAccessor.ofField("factory").setsArgumentAt(1))
                    .andThen(MethodCall.invoke(EntityMetadata.class, "entityClass").onArgument(2).andAssignTo(FieldAccessor.ofField("entityClass")))
                    .andThen(MethodCall.invoke(EntityMetadata.class, "idColumnName").onArgument(2).andAssignTo(FieldAccessor.ofField("idColumnName")))
                    .andThen(MethodCall.invoke(EntityMetadata.class, "converters").onArgument(2).andAssignTo(FieldAccessor.ofField("converters")))
                    .andThen(MethodCall.invoke(EntityMetadata.class, "fields").onArgument(2).andAssignTo(FieldAccessor.ofField("fields")))
                    .andThen(MethodCall.invoke(EntityMetadata.class, "postLoadHandle").onArgument(2).andAssignTo(FieldAccessor.ofField("postLoadHandle")))
                    .andThen(MethodCall.invoke(EntityMetadata.class, "prePersistHandle").onArgument(2).andAssignTo(FieldAccessor.ofField("prePersistHandle"))));

            // Generate getEntityClass()
            builder = generateGetEntityClass(builder);

            // Generate findById() with inline materialization
            builder = generateFindById(builder, entityMetadata);

            // Generate existsById()
            builder = generateExistsById(builder, entityMetadata);

            // Generate deleteById()
            builder = generateDeleteById(builder, entityMetadata);

            // Generate findAll()
            builder = generateFindAll(builder, entityMetadata);

            // Generate count()
            builder = generateCount(builder);

            // Generate deleteAll()
            builder = generateDeleteAll(builder, entityMetadata);

            // Generate save()
            builder = generateSave(builder, entityMetadata);

            // Generate update()
            builder = generateUpdate(builder, entityMetadata);

            // Generate query methods
            for (QueryMetadata query : queryMethods) {
                builder = generateQueryMethod(builder, query, entityMetadata);
            }

            // Build and load the class
            Class<? extends R> generatedClass = builder.make()
                .load(RepositoryBytecodeGenerator.class.getClassLoader())
                .getLoaded();

            return generatedClass
                .getDeclaredConstructor(FfmTable.class, MemrisRepositoryFactory.class, EntityMetadata.class)
                .newInstance(table, factory, entityMetadata);

        } catch (Throwable t) {
            throw new RuntimeException("Failed to generate repository: " + className, t);
        }
    }

    // ... method generation methods below
}
```

#### 3.2 Generate findById()

```java
private <T, R extends MemrisRepository<T>> DynamicType.Builder<R> generateFindById(
        DynamicType.Builder<R> builder,
        EntityMetadata<T> entityMetadata) {

    return builder.defineMethod("findById", Optional.class, Visibility.PUBLIC)
        .withParameter(Object.class, "id")
        .intercept(Advice.to(FindByIdAdvice.class)
            .bind("table", FieldAccessor.ofField("table").get())
            .bind("factory", FieldAccessor.ofField("factory").get())
            .bind("entityClass", entityMetadata.entityClass())
            .bind("idColumnName", entityMetadata.idColumnName())
            .bind("postLoadHandle", entityMetadata.postLoadHandle())
            .bind("fields", entityMetadata.fields())
            .bind("converters", entityMetadata.converters())
            .onMethodEnter());
}

public static class FindByIdAdvice {
    @Advice.OnMethodEnter
    public static Optional<?> enter(
            @Advice.FieldValue("table") FfmTable table,
            @Advice.FieldValue("factory") MemrisRepositoryFactory factory,
            @Advice.FieldValue("entityClass") Class<?> entityClass,
            @Advice.FieldValue("idColumnName") String idColumnName,
            @Advice.FieldValue("postLoadHandle") MethodHandle postLoadHandle,
            @Advice.FieldValue("fields") List<?> fields,
            @Advice.FieldValue("converters") Map<String, TypeConverter<?, ?>> converters,
            @Advice.Argument(0) Object id) throws Throwable {

        // Query index (O(1))
        int[] matchingRows = factory.queryIndex(entityClass, idColumnName,
            Predicate.Operator.EQ, id);

        if (matchingRows == null || matchingRows.length == 0) {
            return Optional.empty();
        }

        // Inline materialization - direct field access!
        int row = matchingRows[0];
        Object entity = materializeInline(entityClass, table, row, fields, converters);

        // Invoke post-load callback (pre-compiled MethodHandle)
        if (postLoadHandle != null) {
            postLoadHandle.invoke(entity);
        }

        return Optional.of(entity);
    }

    @SuppressWarnings("unchecked")
    private static Object materializeInline(Class<?> entityClass, FfmTable table, int row,
            List<?> fields, Map<String, TypeConverter<?, ?>> converters) throws Exception {
        Object entity = entityClass.getDeclaredConstructor().newInstance();

        for (Object fieldObj : fields) {
            EntityMetadata.FieldMapping field = (EntityMetadata.FieldMapping) fieldObj;

            // Skip foreign key columns
            if (field.name().endsWith("_id")) {
                continue;
            }

            // Read from table using direct method call
            Object storageValue = readFromTable(table, field, row);

            // Convert using pre-compiled converter
            TypeConverter<?, ?> converter = converters.get(field.name());
            Object javaValue = (converter == null) ? storageValue
                : ((TypeConverter<Object, Object>) converter).fromStorage(storageValue);

            // Direct field access (NO reflection!)
            Field javaField = entityClass.getDeclaredField(field.name());
            javaField.setAccessible(true);
            javaField.set(entity, javaValue);
        }

        return entity;
    }

    private static Object readFromTable(FfmTable table, EntityMetadata.FieldMapping field, int row) {
        Class<?> storageType = field.storageType();

        // Direct type dispatch - NO reflection!
        return switch (storageType.getName()) {
            case "int", "java.lang.Integer" -> table.getInt(field.columnName(), row);
            case "long", "java.lang.Long" -> table.getLong(field.columnName(), row);
            case "boolean", "java.lang.Boolean" -> table.getBoolean(field.columnName(), row);
            case "byte", "java.lang.Byte" -> table.getByte(field.columnName(), row);
            case "short", "java.lang.Short" -> table.getShort(field.columnName(), row);
            case "float", "java.lang.Float" -> table.getFloat(field.columnName(), row);
            case "double", "java.lang.Double" -> table.getDouble(field.columnName(), row);
            case "char", "java.lang.Character" -> table.getChar(field.columnName(), row);
            case "java.lang.String" -> table.getString(field.columnName(), row);
            default -> throw new IllegalArgumentException("Unsupported storage type: " + storageType);
        };
    }
}
```

#### 3.3 Generate save()

```java
private <T, R extends MemrisRepository<T>> DynamicType.Builder<R> generateSave(
        DynamicType.Builder<R> builder,
        EntityMetadata<T> entityMetadata) {

    return builder.defineMethod("save", Object.class, Visibility.PUBLIC)
        .withParameter(Object.class, "entity")
        .intercept(Advice.to(SaveAdvice.class)
            .bind("table", FieldAccessor.ofField("table").get())
            .bind("factory", FieldAccessor.ofField("factory").get())
            .bind("entityClass", entityMetadata.entityClass())
            .bind("idColumnName", entityMetadata.idColumnName())
            .bind("prePersistHandle", entityMetadata.prePersistHandle())
            .bind("fields", entityMetadata.fields())
            .bind("converters", entityMetadata.converters())
            .onMethodEnter());
}

public static class SaveAdvice {
    @Advice.OnMethodEnter
    public static Object enter(
            @Advice.FieldValue("table") FfmTable table,
            @Advice.FieldValue("factory") MemrisRepositoryFactory factory,
            @Advice.FieldValue("entityClass") Class<?> entityClass,
            @Advice.FieldValue("idColumnName") String idColumnName,
            @Advice.FieldValue("prePersistHandle") MethodHandle prePersistHandle,
            @Advice.FieldValue("fields") List<?> fields,
            @Advice.FieldValue("converters") Map<String, TypeConverter<?, ?>> converters,
            @Advice.Argument(0) Object entity) throws Throwable {

        // Invoke @PrePersist (pre-compiled MethodHandle)
        if (prePersistHandle != null) {
            prePersistHandle.invoke(entity);
        }

        // Extract ID value (direct field access)
        Object id = getFieldValue(entity, idColumnName);

        // Build values array (inline, no reflection!)
        Object[] values = new Object[fields.size()];
        for (int i = 0; i < fields.size(); i++) {
            EntityMetadata.FieldMapping field = (EntityMetadata.FieldMapping) fields.get(i);
            Object fieldValue = getFieldValue(entity, field.name());

            // Convert using pre-compiled converter
            TypeConverter<?, ?> converter = converters.get(field.name());
            values[i] = (converter == null) ? fieldValue
                : ((TypeConverter<Object, Object>) converter).toStorage(fieldValue);
        }

        // Insert into table
        table.insert(values);

        return entity;
    }

    private static Object getFieldValue(Object entity, String fieldName) throws Exception {
        Field field = entity.getClass().getDeclaredField(fieldName);
        field.setAccessible(true);
        return field.get(entity);
    }
}
```

#### 3.4 Generate Query Methods

```java
private <T, R extends MemrisRepository<T>> DynamicType.Builder<R> generateQueryMethod(
        DynamicType.Builder<R> builder,
        QueryMetadata query,
        EntityMetadata<T> entityMetadata) {

    String methodName = query.methodName();
    Class<?> returnType = query.returnType();

    DynamicType.Builder.MethodBuilder<R> methodBuilder =
        builder.defineMethod(methodName, returnType, Visibility.PUBLIC);

    // Add parameters
    java.lang.reflect.Parameter[] params = query.method().getParameters();
    for (int i = 0; i < params.length; i++) {
        methodBuilder = methodBuilder.withParameter(params[i].getType(), params[i].getName());
    }

    // Generate method body based on conditions
    if (query.conditions().size() == 1) {
        methodBuilder = methodBuilder.intercept(Advice.to(SingleConditionAdvice.class)
            .bind("table", FieldAccessor.ofField("table").get())
            .bind("factory", FieldAccessor.ofField("factory").get())
            .bind("entityClass", entityMetadata.entityClass())
            .bind("columnName", query.conditions().get(0).columnName())
            .bind("operator", query.conditions().get(0).operator())
            .bind("paramIndex", query.conditions().get(0).parameterIndex())
            .bind("postLoadHandle", entityMetadata.postLoadHandle())
            .bind("fields", entityMetadata.fields())
            .bind("converters", entityMetadata.converters())
            .bind("queryType", query.queryType())
            .onMethodEnter());
    } else {
        // Multiple conditions - use compound predicate advice
        methodBuilder = methodBuilder.intercept(Advice.to(CompoundConditionAdvice.class)
            .bind("table", FieldAccessor.ofField("table").get())
            .bind("factory", FieldAccessor.ofField("factory").get())
            .bind("entityClass", entityMetadata.entityClass())
            .bind("conditions", query.conditions())
            .bind("postLoadHandle", entityMetadata.postLoadHandle())
            .bind("fields", entityMetadata.fields())
            .bind("converters", entityMetadata.converters())
            .bind("queryType", query.queryType())
            .onMethodEnter());
    }

    return methodBuilder;
}

public static class SingleConditionAdvice {
    @Advice.OnMethodEnter
    public static Object enter(
            @Advice.FieldValue("table") FfmTable table,
            @Advice.FieldValue("factory") MemrisRepositoryFactory factory,
            @Advice.FieldValue("entityClass") Class<?> entityClass,
            @Advice.Bind("columnName") String columnName,
            @Advice.Bind("operator") Predicate.Operator operator,
            @Advice.Bind("paramIndex") int paramIndex,
            @Advice.FieldValue("postLoadHandle") MethodHandle postLoadHandle,
            @Advice.FieldValue("fields") List<?> fields,
            @Advice.FieldValue("converters") Map<String, TypeConverter<?, ?>> converters,
            @Advice.Bind("queryType") QueryMethodParser.QueryType queryType,
            @Advice.AllArguments Object[] args) throws Throwable {

        Object paramValue = args[paramIndex];

        // Try index first (O(1))
        int[] matchingRows = factory.queryIndex(entityClass, columnName,
            operator, paramValue);

        // Fall back to table scan if no index
        if (matchingRows == null) {
            matchingRows = scanTable(table, columnName, operator, paramValue);
        }

        if (matchingRows == null || matchingRows.length == 0) {
            return switch (queryType) {
                case FIND_ONE -> Optional.empty();
                case FIND_MANY -> List.of();
                case COUNT -> 0L;
                case DELETE -> null;
            };
        }

        // Materialize results (inline!)
        List<Object> results = new ArrayList<>();
        for (int row : matchingRows) {
            Object entity = FindByIdAdvice.materializeInline(entityClass, table, row, fields, converters);
            if (postLoadHandle != null) {
                postLoadHandle.invoke(entity);
            }
            results.add(entity);
        }

        return switch (queryType) {
            case FIND_ONE -> Optional.of(results.get(0));
            case FIND_MANY -> results;
            case COUNT -> (long) results.size();
            case DELETE -> {
                // Delete from index
                for (int row : matchingRows) {
                    Object id = getFieldValueFromTable(table, entityClass, columnName, row);
                    // Remove from index using factory method
                    // This requires adding a method to factory
                }
                yield null;
            }
        };
    }

    @SuppressWarnings("unchecked")
    private static int[] scanTable(FfmTable table, String columnName,
            Predicate.Operator operator, Object value) {
        return switch (operator) {
            case EQ -> table.scanEquals(columnName, value);
            case GT -> table.scanGreaterThan(columnName, (Comparable) value);
            case GTE -> table.scanGreaterThanOrEqual(columnName, (Comparable) value);
            case LT -> table.scanLessThan(columnName, (Comparable) value);
            case LTE -> table.scanLessThanOrEqual(columnName, (Comparable) value);
            case NEQ -> throw new UnsupportedOperationException("NEQ not supported yet");
            case BETWEEN -> throw new UnsupportedOperationException("BETWEEN not supported yet");
            case IN -> throw new UnsupportedOperationException("IN not supported yet");
            case NOT_IN -> throw new UnsupportedOperationException("NOT_IN not supported yet");
        };
    }

    private static Object getFieldValueFromTable(FfmTable table, Class<?> entityClass,
            String columnName, int row) {
        // Get the storage type from the column
        Class<?> type = table.column(columnName).type();

        return switch (type.getName()) {
            case "int", "java.lang.Integer" -> table.getInt(columnName, row);
            case "long", "java.lang.Long" -> table.getLong(columnName, row);
            case "java.lang.String" -> table.getString(columnName, row);
            default -> throw new IllegalArgumentException("Unsupported type: " + type);
        };
    }
}
```

#### 3.5 Generate Remaining CRUD Methods

```java
private <T, R extends MemrisRepository<T>> DynamicType.Builder<R> generateExistsById(
        DynamicType.Builder<R> builder,
        EntityMetadata<T> entityMetadata) {

    return builder.defineMethod("existsById", boolean.class, Visibility.PUBLIC)
        .withParameter(Object.class, "id")
        .intercept(Advice.to(ExistsByIdAdvice.class)
            .bind("factory", FieldAccessor.ofField("factory").get())
            .bind("entityClass", entityMetadata.entityClass())
            .bind("idColumnName", entityMetadata.idColumnName())
            .onMethodEnter());
}

public static class ExistsByIdAdvice {
    @Advice.OnMethodEnter
    public static boolean enter(
            @Advice.FieldValue("factory") MemrisRepositoryFactory factory,
            @Advice.FieldValue("entityClass") Class<?> entityClass,
            @Advice.FieldValue("idColumnName") String idColumnName,
            @Advice.Argument(0) Object id) {
        int[] matchingRows = factory.queryIndex(entityClass, idColumnName,
            Predicate.Operator.EQ, id);
        return matchingRows != null && matchingRows.length > 0;
    }
}

private <T, R extends MemrisRepository<T>> DynamicType.Builder<R> generateDeleteById(
        DynamicType.Builder<R> builder,
        EntityMetadata<T> entityMetadata) {

    return builder.defineMethod("deleteById", void.class, Visibility.PUBLIC)
        .withParameter(Object.class, "id")
        .intercept(Advice.to(DeleteByIdAdvice.class)
            .bind("factory", FieldAccessor.ofField("factory").get())
            .bind("entityClass", entityMetadata.entityClass())
            .bind("idColumnName", entityMetadata.idColumnName())
            .onMethodEnter());
}

public static class DeleteByIdAdvice {
    @Advice.OnMethodEnter
    public static void enter(
            @Advice.FieldValue("factory") MemrisRepositoryFactory factory,
            @Advice.FieldValue("entityClass") Class<?> entityClass,
            @Advice.FieldValue("idColumnName") String idColumnName,
            @Advice.Argument(0) Object id) {
        int[] matchingRows = factory.queryIndex(entityClass, idColumnName,
            Predicate.Operator.EQ, id);

        if (matchingRows == null || matchingRows.length == 0) {
            return; // Not found - no-op
        }

        // Remove from hash index (O(1))
        // Note: This requires access to remove method on index
        // May need to add method to factory to handle this
    }
}

private <T, R extends MemrisRepository<T>> DynamicType.Builder<R> generateFindAll(
        DynamicType.Builder<R> builder,
        EntityMetadata<T> entityMetadata) {

    return builder.defineMethod("findAll", List.class, Visibility.PUBLIC)
        .intercept(Advice.to(FindAllAdvice.class)
            .bind("table", FieldAccessor.ofField("table").get())
            .bind("postLoadHandle", entityMetadata.postLoadHandle())
            .bind("fields", entityMetadata.fields())
            .bind("converters", entityMetadata.converters())
            .onMethodEnter());
}

public static class FindAllAdvice {
    @Advice.OnMethodEnter
    public static List<?> enter(
            @Advice.FieldValue("table") FfmTable table,
            @Advice.FieldValue("postLoadHandle") MethodHandle postLoadHandle,
            @Advice.FieldValue("fields") List<?> fields,
            @Advice.FieldValue("converters") Map<String, TypeConverter<?, ?>> converters) throws Throwable {

        SelectionVectorFactory factory = SelectionVectorFactory.defaultFactory();
        int[] rows = table.scanAll(factory).toIntArray();

        List<Object> results = new ArrayList<>(rows.length);
        for (int row : rows) {
            Object entity = FindByIdAdvice.materializeInline(
                table.column(0).getClass().getDeclaringClass(), // Get entityClass from metadata
                table, row, fields, converters);
            if (postLoadHandle != null) {
                postLoadHandle.invoke(entity);
            }
            results.add(entity);
        }

        return results;
    }
}

private <T, R extends MemrisRepository<T>> DynamicType.Builder<R> generateCount(
        DynamicType.Builder<R> builder) {

    return builder.defineMethod("count", long.class, Visibility.PUBLIC)
        .intercept(FieldAccessor.ofField("table").get().thenInvoke("rowCount"));
}

private <T, R extends MemrisRepository<T>> DynamicType.Builder<R> generateDeleteAll(
        DynamicType.Builder<R> builder) {

    return builder.defineMethod("deleteAll", void.class, Visibility.PUBLIC)
        .intercept(Advice.to(DeleteAllAdvice.class)
            .onMethodEnter());
}

public static class DeleteAllAdvice {
    @Advice.OnMethodEnter
    public static void enter() {
        // O(1) operation: clear the hash index
        // Implementation depends on how indexes are managed
        // For now, this is a placeholder
    }
}

private <T, R extends MemrisRepository<T>> DynamicType.Builder<R> generateUpdate(
        DynamicType.Builder<R> builder,
        EntityMetadata<T> entityMetadata) {

    return builder.defineMethod("update", void.class, Visibility.PUBLIC)
        .withParameter(Object.class, "entity")
        .intercept(Advice.to(UpdateAdvice.class)
            .bind("table", FieldAccessor.ofField("table").get())
            .bind("factory", FieldAccessor.ofField("factory").get())
            .bind("entityClass", entityMetadata.entityClass())
            .bind("idColumnName", entityMetadata.idColumnName())
            .bind("preUpdateHandle", entityMetadata.preUpdateHandle())
            .bind("fields", entityMetadata.fields())
            .bind("converters", entityMetadata.converters())
            .onMethodEnter());
}

public static class UpdateAdvice {
    @Advice.OnMethodEnter
    public static void enter(
            @Advice.FieldValue("table") FfmTable table,
            @Advice.FieldValue("factory") MemrisRepositoryFactory factory,
            @Advice.FieldValue("entityClass") Class<?> entityClass,
            @Advice.FieldValue("idColumnName") String idColumnName,
            @Advice.FieldValue("preUpdateHandle") MethodHandle preUpdateHandle,
            @Advice.FieldValue("fields") List<?> fields,
            @Advice.FieldValue("converters") Map<String, TypeConverter<?, ?>> converters,
            @Advice.Argument(0) Object entity) throws Throwable {

        // Invoke @PreUpdate
        if (preUpdateHandle != null) {
            preUpdateHandle.invoke(entity);
        }

        // Get ID to find existing row
        Object id = getFieldValue(entity, idColumnName);
        int[] matchingRows = factory.queryIndex(entityClass, idColumnName,
            Predicate.Operator.EQ, id);

        if (matchingRows == null || matchingRows.length == 0) {
            return; // Not found - no-op
        }

        int row = matchingRows[0];

        // Update each field (inline!)
        for (Object fieldObj : fields) {
            EntityMetadata.FieldMapping field = (EntityMetadata.FieldMapping) fieldObj;

            // Skip ID field
            if (field.name().equals(idColumnName)) {
                continue;
            }

            Object fieldValue = getFieldValue(entity, field.name());

            // Convert using pre-compiled converter
            TypeConverter<?, ?> converter = converters.get(field.name());
            Object storageValue = (converter == null) ? fieldValue
                : ((TypeConverter<Object, Object>) converter).toStorage(fieldValue);

            // Set value in table using direct method call
            setTableValue(table, field, row, storageValue);
        }
    }

    private static Object getFieldValue(Object entity, String fieldName) throws Exception {
        Field field = entity.getClass().getDeclaredField(fieldName);
        field.setAccessible(true);
        return field.get(entity);
    }

    private static void setTableValue(FfmTable table, EntityMetadata.FieldMapping field,
            int row, Object value) {
        Class<?> storageType = field.storageType();

        // Direct type dispatch
        switch (storageType.getName()) {
            case "int", "java.lang.Integer" -> table.setInt(field.columnName(), row, (Integer) value);
            case "long", "java.lang.Long" -> table.setLong(field.columnName(), row, (Long) value);
            case "boolean", "java.lang.Boolean" -> table.setBoolean(field.columnName(), row, (Boolean) value);
            case "java.lang.String" -> table.setString(field.columnName(), row, (String) value);
            default -> throw new IllegalArgumentException("Unsupported type: " + storageType);
        }
    }
}

private <T, R extends MemrisRepository<T>> DynamicType.Builder<R> generateGetEntityClass(
        DynamicType.Builder<R> builder) {

    return builder.defineMethod("getEntityClass", Class.class, Visibility.PUBLIC)
        .intercept(FieldAccessor.ofField("entityClass").get());
}
```

#### 3.6 Required Imports

```java
import net.bytebuddy.ByteBuddy;
import net.bytebuddy.asm.Advice;
import net.bytebuddy.description.modifier.Visibility;
import net.bytebuddy.dynamic.DynamicType;
import net.bytebuddy.implementation.FieldAccessor;
import net.bytebuddy.implementation.MethodCall;

import io.memris.kernel.Predicate;
import io.memris.kernel.selection.SelectionVector;
import io.memris.kernel.selection.SelectionVectorFactory;
import io.memris.spring.converter.TypeConverter;
import io.memris.storage.ffm.FfmTable;

import java.lang.invoke.MethodHandle;
import java.lang.reflect.Field;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.Optional;
```

---

### STEP 4: Simplify MemrisRepositoryFactory.java

**File:** `G:\dev\repos\memris\memris-core\src\main\java\io\memris\spring\MemrisRepositoryFactory.java`

**Methods to DELETE (runtime reflection violations):**
- `doSave()` - Lines 597-772
- `doUpdate()` - Lines 831-833
- `invokePrePersist()` - Lines 990-1001
- `invokePostLoad()` - Lines 1003-1014
- `invokePreUpdate()` - Lines 1016-1027
- `materializeSingle()` - Lines 1069-1112
- `updateExistingRow()` - Lines 868-916
- `setTableValue()` - Lines 922-939
- `findNestedId()` - Lines 942-963
- `getFieldValueFromTable()` - Lines 965-988

**Methods to KEEP (run once at factory creation):**
- `buildTable()` - Lines 334-388
- `buildIndexes()` - Lines 390-426
- `buildNestedEntityTables()` - Lines 200-213
- `buildJoinTables()` - Lines 232-269
- `cacheEnumValues()` - Lines 215-230
- `getIdStorageType()` - Lines 275-296
- `getIdFieldType()` - Lines 302-318
- `getCollectionElementType()` - Lines 320-332
- `queryIndex()` - Lines 554-577
- `getTable()` - Lines 523-525
- `getIndex()` - Lines 530-536
- `hasIndex()` - Lines 541-544

**Updated createJPARepository() method:**
```java
public <T, R extends MemrisRepository<T>> R createJPARepository(Class<R> repositoryInterface) {
    // Extract entity class from repository interface's generic type
    Class<T> entityClass = extractEntityClass(repositoryInterface);

    // Build table (ONE TIME reflection)
    buildNestedEntityTables(entityClass);
    FfmTable table = tables.computeIfAbsent(entityClass, this::buildTable);
    cacheEnumValues(entityClass);
    buildJoinTables(entityClass);

    // Extract metadata (ONE TIME reflection)
    EntityMetadata<T> entityMetadata =
        MetadataExtractor.extractEntityMetadata(entityClass, table);

    // Extract query methods (ONE TIME reflection)
    List<QueryMetadata> queryMethods =
        MetadataExtractor.extractQueryMethods(repositoryInterface);

    // Generate concrete repository (ZERO reflection at runtime)
    RepositoryBytecodeGenerator generator = new RepositoryBytecodeGenerator(this);
    return generator.generateRepository(repositoryInterface, entityMetadata, table, queryMethods);
}
```

**REMOVE proxy fallback completely:**
```java
// DELETE THIS ENTIRE TRY-CATCH BLOCK (lines 162-176):
// try {
//     return generator.generateRepository(...);
// } catch (Exception e) {
//     System.err.println("ByteBuddy generation failed, falling back to proxy: " + e);
//     e.printStackTrace();
//     // Fallback to proxy-based implementation
//     CompiledEntityMetadata compiledMetadata = new CompiledEntityMetadata(entityClass, table);
//     MemrisRepository<T> baseRepo = new MemrisRepositoryImpl<>(entityClass, table, arena, this, compiledMetadata);
//     return (R) Proxy.newProxyInstance(...);
// }

// REPLACE WITH:
return generator.generateRepository(repositoryInterface, entityMetadata, table, queryMethods);
```

---

### STEP 5: Delete Old Files

#### DELETE: MemrisRepositoryImpl.java

**File:** `G:\dev\repos\memris\memris-core\src\main\java\io\memris\spring\MemrisRepositoryImpl.java`

**Reason:** Uses HashMap-based metadata with runtime lookups. Generated bytecode is faster and cleaner.

#### DELETE: CompiledEntityMetadata.java

**File:** `G:\dev\repos\memris\memris-core\src\main\java\io\memris\spring\CompiledEntityMetadata.java`

**Reason:** Uses HashMap lookups for MethodHandles and types. New `EntityMetadata` stores pre-compiled converters and lifecycle MethodHandles directly.

#### DELETE: MemrisInvocationHandler.java

**File:** Inner class in `MemrisRepositoryFactory.java` (lines 1147-1291)

**Reason:** JDK Proxy-based implementation with runtime query method parsing. ByteBuddy generates concrete implementations with no parsing overhead.

---

### STEP 6: Fix Compilation Errors

Run `mvn clean compile` and fix all errors.

**Expected issues:**
1. `MemrisRepositoryImpl` referenced in tests - need to update tests
2. `CompiledEntityMetadata` referenced anywhere - replace with `EntityMetadata`
3. `MemrisInvocationHandler` no longer exists - remove references
4. Constructor signatures changed in factory methods
5. Import statements referencing deleted classes

---

### STEP 7: Fix Tests

Run tests and identify failures:
```bash
mvn clean test
```

**Expected test failures:**
1. `DynamicRepositoryTest` - Uses proxy, needs to work with ByteBuddy
2. `MemrisRepositoryFactoryTest` - May have ID field detection issues
3. Tests referencing deleted files

**Fix approach:**
1. Run tests and collect all failures
2. Update test expectations for ByteBuddy-generated classes
3. Remove tests that test deleted implementations
4. Ensure all tests pass

---

### STEP 8: Verify No Reflection at Runtime

**Method 1: Java Agent Profiling**
Use a Java agent to track reflection calls during runtime:
```bash
java -javaagent:/path/to/reflection-tracking-agent.jar -jar your-app.jar
```

**Method 2: Code Inspection**
Ensure no calls to:
- `Class.getDeclaredField()`
- `Class.getDeclaredFields()`
- `Class.getDeclaredMethod()`
- `Class.getDeclaredMethods()`
- `Field.get()`, `Field.set()`
- `Method.invoke()`

**Method 3: Assertions in Code**
Add assertions in critical paths to verify:
- No HashMap lookups in hot paths
- Direct field access in materialization
- Pre-compiled MethodHandle usage

---

## Progress Tracking

### Task Status

| Task | Status | Notes |
|------|--------|-------|
| Create task-01.md with complete implementation plan | ✅ In Progress | This document |
| Update EntityMetadata.java - Add TypeConverter instances and lifecycle MethodHandles | ⬜ Pending | |
| Update MetadataExtractor.java - Extract TypeConverters and lifecycle MethodHandles | ⬜ Pending | |
| Rewrite RepositoryBytecodeGenerator.java - Complete rewrite with Advice API | ⬜ Pending | |
| Simplify MemrisRepositoryFactory.java - Remove all runtime reflection | ⬜ Pending | |
| DELETE MemrisRepositoryImpl.java - Map-based implementation | ⬜ Pending | |
| DELETE CompiledEntityMetadata.java - HashMap-based | ⬜ Pending | |
| DELETE MemrisInvocationHandler.java - Proxy with runtime parsing | ⬜ Pending | |
| Run mvn clean compile - Fix compilation errors | ⬜ Pending | |
| Run tests - Fix all test failures | ⬜ Pending | |
| Verify NO reflection at runtime - Profiling verification | ⬜ Pending | |

### Violations Resolved

| Violation | Resolved | Method Used |
|-----------|----------|-------------|
| `doSave()` reflection | ⬜ Pending | Inline bytecode in generated save() |
| `doUpdate()` reflection | ⬜ Pending | Inline bytecode in generated update() |
| Lifecycle callback method scanning | ⬜ Pending | Pre-compiled MethodHandles |
| Materialization field lookup | ⬜ Pending | Inline field access in Advice |
| HashMap lookups in hot paths | ⬜ Pending | Direct field/method access |
| Proxy query parsing | ⬜ Pending | ByteBuddy generates all queries |

---

## Key Design Decisions

### ByteCode Style: Direct Inline Field Access
**Chosen:** Direct inline field access with hardcoded field names
**Rationale:** Maximum performance, generated bytecode reads like hand-written code
**Trade-off:** More complex bytecode generation, but worth it for performance

### Lifecycle Handling: Pre-compiled MethodHandles
**Chosen:** Pre-compile MethodHandles for lifecycle callbacks in EntityMetadata
**Rationale:** O(1) direct call, no reflection at runtime
**Trade-off:** Slightly more complex metadata construction

### No Index Handling: Fall Back to Table Scan
**Chosen:** Use table scan if no index exists for query
**Rationale:** Flexibility, don't force users to create all indexes
**Trade-off:** Slower for unindexed queries, but still no reflection

### Type Conversion: Pre-compile in Metadata
**Chosen:** Store TypeConverter instances in EntityMetadata per field
**Rationale:** Direct converter.fieldToStorage() calls, no registry lookups
**Trade-off:** More metadata memory, but faster execution

---

## Success Criteria

### ✅ Zero Reflection at Runtime
- No `getDeclaredField()` calls after factory creation
- No `getDeclaredMethod()` calls after factory creation
- No `Field.get()` or `Field.set()` in hot paths
- No `Method.invoke()` calls in hot paths
- No HashMap lookups in hot paths

### ✅ Performance Targets
- `findById()` < 1ms with index
- `save()` < 0.5ms
- Query methods with index < 1ms
- Table scans using SIMD < 10ms for 1M rows

### ✅ All Tests Pass
- `mvn clean test` passes with 0 failures
- No test exceptions or errors
- All functionality preserved

### ✅ Clean Code
- No commented-out code
- No TODOs in implementation
- Clear separation: metadata extraction vs bytecode generation
- Inline methods where performance matters

---

## Notes

### ByteBuddy Advice API
The `Advice` API inserts bytecode at method entry/exit points. This is preferred over `MethodDelegation` because:
1. Better control over type binding
2. Can bind values at code generation time (not runtime)
3. No reflection overhead in generated code
4. More predictable bytecode

### MethodHandle.invokeExact()
We use `invokeExact()` for lifecycle callbacks because:
1. Type-safe at compile time
2. Faster than `invoke()` (no argument boxing)
3. JVM can optimize it to direct call

### Table Scan Fallback
When no index exists, we use FfmTable's scan methods:
- `scanEquals(column, value)` - SIMD-accelerated equality check
- `scanGreaterThan/LessThan()` - SIMD-accelerated comparisons

### Generated Class Naming
Generated classes are named: `{InterfaceName}ByteBuddyImpl`
Example: `ComputerRepositoryByteBuddyImpl`

### Package Location
Generated classes are loaded in the same package as the repository interface for visibility of package-private members.

---

## Next Steps After Completion

1. **Benchmarking**: Compare proxy vs ByteBuddy performance
2. **Query Optimization**: Add query plan caching
3. **Async Operations**: Generate async query methods
4. **Batch Operations**: Generate batch save/update methods
5. **Custom Queries**: Generate inline bytecode for native queries
6. **Caching**: Add entity cache layer
7. **Metrics**: Add telemetry for query performance
