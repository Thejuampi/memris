# Memris Architecture Diagrams

This directory contains PlantUML diagrams visualizing Memris's zero-reflection query architecture and component relationships.

## Architecture Overview

Memris uses a **zero-reflection runtime** with build-time planning:

- **Build-Time (once per entity type)**: QueryPlanner + QueryCompiler compile queries to `CompiledQuery[]`
- **Hot-Path (reuse forever)**: RepositoryRuntime with constant `queryId` dispatch
- **Zero Reflection**: No `Method` objects, no method-name parsing, no string map lookups at runtime

## Design Philosophy

### Zero Reflection Runtime
All reflection happens during **build-time** (repository creation). Runtime execution uses:
- **Constant queryId**: Embedded in generated bytecode (e.g., `rt.list1(0, arg)`)
- **Dense Arrays**: `String[] columnNames`, `byte[] typeCodes`, `MethodHandle[] setters` (no maps)
- **TypeCode Dispatch**: Switch on `byte typeCode` for zero-allocation type switching
- **Typed Entrypoints**: `list0/1/2()`, `optional1()`, `exists1()`, `count0/1/2()`
- **Direct Table Access**: FfmTable indexed API (`getInt(int columnId, int row)`)

### Query Planning (Build-Time)
- **QueryPlanner** parses Spring Data JPA method names into `LogicalQuery`
- **QueryCompiler** resolves property paths to column indices, produces `CompiledQuery`
- Plans stored in `CompiledQuery[]` array indexed by `queryId`
- No runtime parsing, no Method objects, no string comparisons

### RepositoryRuntime (Hot-Path Engine)
- Owns `FfmTable`, `MemrisRepositoryFactory`, `CompiledQuery[]`
- Dense arrays for materialization: `columnNames`, `typeCodes`, `converters`, `setters`
- Typed entrypoints for zero-reflection execution:
  ```java
  public List<T> list1(int queryId, Object arg0) {
      CompiledQuery cq = compiledQueries[queryId];  // O(1) array lookup
      int[] rows = executeQuery(cq, new Object[]{arg0});
      return materialize(rows);  // MethodHandle-based, no reflection
  }
  ```
- TypeCode dispatch for column access:
  ```java
  Object getTableValue(int columnIndex, int row) {
      return switch (typeCodes[columnIndex]) {
          case TYPE_INT -> table.getInt(columnIndex, row);
          case TYPE_STRING -> table.getString(columnIndex, row);
          // ... zero-allocation switch on byte
      };
  }
  ```

## Diagrams

### query-system.puml

**Purpose**: Visualizes the separation between build-time planning and hot-path runtime execution in Memris's zero-reflection query system.

**Key Concepts**:
- **Build-Time (Once)**: QueryPlanner + QueryCompiler create CompiledQuery[]
- **Hot-Path (Forever)**: RepositoryRuntime executes with constant queryId, typed entrypoints
- **Zero Reflection**: No Method objects, no string parsing, no map lookups at runtime

### architecture.puml

**Purpose**: Shows high-level component relationships across storage, query planning, runtime, and code generation layers.

**Key Components**:
- MemrisRepositoryFactory (orchestrator)
- QueryPlanner + QueryCompiler (build-time)
- RepositoryRuntime (hot-path engine)
- RepositoryScaffolder + RepositoryEmitter (code generation)
- FfmTable (column-indexed storage)
