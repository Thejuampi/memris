# Plan: Precompiled Query Executors in RepositoryRuntime

## Goal
- Replace the runtime opCode switch in `RepositoryRuntime` with per-query precompiled executors to reduce branching and arg-binding overhead.
- Keep API impact minimal and confine changes to runtime/repository planning layers.

## Approach
1. Add a tiny executor abstraction (e.g., `RepositoryMethodExecutor`) in `io.memris.runtime` that executes a repository method given the method args.
2. Precompute one executor per repository method at plan-build time and store in `RepositoryPlan`.
3. Use `RepositoryMethodBinding` to precompute an arg resolver (or augment it with a fast-path resolver) so each executor can bind args without re-checking nulls or opCodes.
4. Replace `RepositoryRuntime.executeCompiledQuery` branching with a direct executor lookup/dispatch.
5. Optionally simplify ByteBuddy interceptors to use the executor array directly (still minimal change, no behavioral shift).

## Implementation Steps
1. **Define executor interface**
   - Add `RepositoryMethodExecutor` (functional interface) under `io.memris.runtime`.
   - Optional: add an `ArgResolver` functional interface, or add a `resolveArgsFast` method to `RepositoryMethodBinding` with precomputed resolver logic.

2. **Extend RepositoryPlan**
   - Add `RepositoryMethodExecutor[] executors` field, constructor wiring, and getter.
   - Update builder to accept executors.

3. **Enhance RepositoryMethodBinding**
   - Add precomputed arg resolver variants:
     - no-slot: return `args` or empty array
     - bound-only: return bound values
     - mixed: allocate and fill using parameter indices and bound values
   - Keep behavior identical to current `resolveArgs`.

4. **Build executors in RepositoryEmitter**
   - After `bindings` creation, build an executors array aligned with query methods.
   - Executor mapping (per opCode):
     - direct: `saveOne/saveAll/findById/findAll/countAll/existsById/deleteOne/deleteAll/deleteById/deleteAllById`
     - binding + query: `find/countFast/existsFast/deleteQuery/updateQuery`
   - Store into `RepositoryPlan`.
   - Interceptors option (minimal change): keep existing interceptors but make them call the executor for their method index (or swap to a single generic interceptor using method index).

5. **Update RepositoryRuntime**
   - Replace `executeCompiledQuery` switch with `plan.executors()[methodIndex].execute(args)`.
   - Keep existing execution methods unchanged.

## Files to Modify
- `memris-core/src/main/java/io/memris/runtime/RepositoryPlan.java`
- `memris-core/src/main/java/io/memris/runtime/RepositoryMethodBinding.java`
- `memris-core/src/main/java/io/memris/runtime/RepositoryRuntime.java`
- `memris-core/src/main/java/io/memris/runtime/RepositoryMethodExecutor.java` (new)
- `memris-core/src/main/java/io/memris/repository/RepositoryEmitter.java`

## Verification
- Compile: `mvn.cmd -q -e compile`
- Targeted tests (if available): `mvn.cmd -q -e -pl memris-core test`

## Notes/Risks
- Ensure executors and arg resolvers do not share mutable arrays across calls (allocate per call or use safe caching).
- Keep behavior for bound values and parameter indices identical to current `RepositoryMethodBinding.resolveArgs`.
