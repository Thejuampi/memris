Phase 1 and Phase 2 complete. Scope and approach confirmed with user.

# Plan: Repository-level stress test (1M rows, concurrent ops)

## Goal
Add a JUnit stress test that inserts 1,000,000 TestEntity rows, concurrently updates and deletes a deterministic subset, then asserts final state after eventual consistency using a polling loop. Test should be tagged as stress and skipped in default runs.

## Constraints and conventions
- Tests are JUnit 5 + AssertJ and must use a single assertion per test.
- Use repository-level API (MemrisRepositoryFactory + MemrisArena + TestEntityRepository).
- Use existing test entity `io.memris.runtime.TestEntity` and repository `io.memris.runtime.TestEntityRepository`.
- Eventual consistency requires polling with timeout.
- Stress tests should be `@Tag("stress")`.

## Files to change
- Add: `memris-core/src/test/java/io/memris/runtime/RepositoryStressTest.java`

## Test design
1) **Setup repository**
   - Create `MemrisRepositoryFactory` and `MemrisArena` in `@BeforeEach` or inside test with try/finally.
   - Create `TestEntityRepository` from the arena.

2) **Deterministic workload**
   - Insert 1,000,000 entities with deterministic content by ID:
     - `name = "seed-" + id`
     - `age = (int) (id % 100)`
     - `department = "dept-" + (id % 10)`
   - Use explicit IDs to make expected-state rules deterministic:
     - `new TestEntity(id, name, age, department)`

3) **Concurrent operations**
   - Use `ExecutorService` with fixed thread pool (e.g., `Math.max(4, Runtime.getRuntime().availableProcessors())`).
   - Split work across workers with range-based slices to avoid shared coordination overhead.
   - Operations:
     - **Insert**: all IDs `1..1_000_000` (initial pass) in parallel.
     - **Update**: deterministic subset (e.g., even IDs) update `age = age + 1000`, `name = "updated-" + id`.
     - **Delete**: deterministic subset (e.g., IDs divisible by 10) delete by ID.
   - Run update/delete concurrently after inserts start; use `CountDownLatch` to synchronize start of all worker tasks.

4) **Expected state calculation**
   - Compute expected counts without storing all entities:
     - `totalInserted = 1_000_000`
     - `deletedCount = totalInserted / 10` (IDs divisible by 10)
     - `remainingCount = totalInserted - deletedCount`
     - `updatedCount = count(even IDs not deleted)`
   - For value verification, sample a deterministic small set (e.g., 1000 IDs evenly spaced) to validate:
     - Deleted IDs are absent.
     - Updated IDs show `name` and `age` updated.
     - Untouched IDs keep original values.

5) **Eventual consistency polling**
   - After workers complete, poll until:
     - `repo.count()` equals `remainingCount`.
     - Sample checks all pass.
   - Poll for up to 60s with 200ms interval (configurable constants in the test).
   - Capture the final snapshot (actual count, sample validation result, timeout flag).

6) **Single assertion**
   - Create a small record or static class (e.g., `StressSnapshot`) holding:
     - `actualCount`, `expectedCount`, `sampleOk`, `timedOut`.
   - Assert once with AssertJ:
     - `assertThat(actualSnapshot).usingRecursiveComparison().isEqualTo(expectedSnapshot)`.

## Implementation notes
- Avoid allocating 1M entity instances at once. Insert in chunks (e.g., 10k per task) within worker loops.
- Reuse simple string patterns to minimize heap overhead.
- Use `repo.deleteById(id)` for deletes to avoid loading entities.
- Sample validation should not scan the whole table; use `findById` for sample IDs.
- Ensure `ExecutorService` shutdown and factory close in finally blocks.
- Tag class and/or method with `@Tag("stress")`.

## Verification
- Run only the stress test explicitly:
  - `mvn.cmd -q -e -pl memris-core test -Dtest=RepositoryStressTest`
- Optional: run with tag selection (if configured):
  - `mvn.cmd -q -e -pl memris-core test -Dgroups=stress` (if Maven Surefire tag config exists; otherwise use the class filter above).

## Out of scope
- No changes to production code.
- No changes to benchmarks or existing concurrency tests.

---

# Addendum: JMH benchmark capacity failure

## Symptom
`ConcurrentReadWriteBenchmark` fails with `Table capacity exceeded: 1048576` once total inserts exceed the default capacity.

## Why this happens
- “Dynamic growth” is currently lazy page allocation up to `maxPages` (default 1024). It does **not** grow beyond `maxPages`.
- Capacity is capped at `pageSize * maxPages` (defaults: 1024 * 1024 = 1,048,576).
- Deletes add rowIds to a free-list and **can be reused**, but the benchmark’s writer keeps allocating new IDs, so it can still exceed capacity if net inserts outpace reuse.

## Decision
Use **Increase capacity** for the JMH benchmark. Configure `MemrisConfiguration` in benchmark setup to raise `defaultMaxPages` (and optionally lower `defaultInitialPages`) so the benchmark can exceed 1,048,576 rows without crashing.

## Files likely to change if we proceed
- `memris-core/src/jmh/java/io/memris/benchmarks/ConcurrentReadWriteBenchmark.java`
- (Optionally) `memris-core/src/jmh/java/io/memris/benchmarks/TestEntityRepositoryBenchmark.java`
- (Optionally) `memris-core/src/jmh/java/io/memris/benchmarks/MemrisBenchmarks.java`

## Implementation detail (recommended)
- In `ConcurrentReadWriteBenchmark.setup()`, build a `MemrisConfiguration` with higher capacity.
  - Example: `defaultPageSize=1024`, `defaultMaxPages=4096` (capacity 4,194,304), `defaultInitialPages=256` to reduce up-front allocation.
  - Pass config to `new MemrisRepositoryFactory(configuration)`.
- If desired, apply the same config to other JMH benchmarks using large row counts.

---

# Addendum: Error Prone warnings (main code only)

## Scope
- Fix warnings in `memris-core/src/main` only.
- Ignore Java Date warnings and generated `jmh_generated` sources.
- Suppress `StringSplitter` warnings where `String.split` is intentional.
- Prefer `instanceof` for equals checks.
- Remove unused members in main code.

## Files to change
- `memris-core/src/main/java/io/memris/repository/MemrisRepositoryFactory.java`
- `memris-core/src/main/java/io/memris/repository/RepositoryEmitter.java`
- `memris-core/src/main/java/io/memris/runtime/RepositoryRuntime.java`
- `memris-core/src/main/java/io/memris/query/LogicalQuery.java`
- `memris-core/src/main/java/io/memris/repository/RepositoryMethodIntrospector.java`
- `memris-core/src/main/java/io/memris/runtime/HeapRuntimeKernel.java`
- `memris-core/src/main/java/io/memris/runtime/RepositoryMethodBinding.java`
- `memris-core/src/main/java/io/memris/storage/SimpleTable.java`
- `memris-core/src/main/java/io/memris/storage/heap/LockFreeFreeList.java`
- `memris-core/src/main/java/io/memris/core/FloatEncoding.java`
- `memris-core/src/main/java/io/memris/core/JoinColumn.java`
- `memris-core/src/main/java/io/memris/core/ManyToOne.java`
- `memris-core/src/main/java/io/memris/query/QueryPlanner.java`
- `memris-core/src/main/java/io/memris/query/QueryMethodLexer.java`
- `memris-core/src/main/java/io/memris/query/JpqlQueryParser.java`
- `memris-core/src/main/java/io/memris/query/QueryCompiler.java`
- `memris-core/src/main/java/io/memris/storage/heap/PageColumnString.java`
- `memris-core/src/main/java/io/memris/runtime/handler/StringTypeHandler.java`

## Planned changes
- **MissingOverride**: add `@Override` to `MemrisRepositoryFactory.close()`.
- **StringCaseLocaleUsage**: use `Locale.ROOT` for `toLowerCase()` in join-column defaults and query parsing (RepositoryFactory/Emitter/Runtime, QueryPlanner, QueryMethodLexer, JpqlQueryParser, PageColumnString, StringTypeHandler).
- **EqualsGetClass**: switch to `instanceof` in `LogicalQuery.equals` and `RepositoryMethodIntrospector.MethodKey.equals`.
- **UnusedMethod/UnusedVariable (main code)**:
  - Keep members, add `@SuppressWarnings` on specific methods/fields as needed (per user preference).
- **IntLongMath**: ensure casts before shifts in `SimpleTable` row index math.
- **NonAtomicVolatileUpdate**: replace `LockFreeFreeList.size` with `AtomicInteger` and use `incrementAndGet/decrementAndGet`.
- **ThreadPriorityCheck**: suppress on `AbstractTable.backoff` if needed to keep behavior.
- **UnnecessaryParentheses**: simplify expressions in `FloatEncoding` to remove redundant parentheses.
- **InvalidBlockTag (Javadoc)**: escape annotation examples in `JoinColumn` and `ManyToOne` with `{@literal @}` (or wrap in `{@code ...}`) to satisfy doclint.
- **StringSplitter**: add `@SuppressWarnings("StringSplitter")` to methods using `String.split` (QueryPlanner.parseGroupingProperties, QueryMethodLexer.resolvePropertyPath, JpqlQueryParser.resolveProjectionField/resolvePath, QueryCompiler.compileJoinPath/compileProjectionPath).

## Verification
- Re-run Error Prone on main code (no tests):
  - `mvn -Pquality -pl memris-core test-compile`
