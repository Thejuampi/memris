# Testing Plan: Context-Aware QueryMethodLexer with Entity Class Support

## Overview

After research into Spring Data JPA official test patterns, this plan defines comprehensive test scenarios and entity structures needed to validate a context-aware lexer that resolves property ambiguities using Entity class metadata.

## Phase 1: Entity Class Structure Design

### 1.1 Base Test Entity Classes

**Purpose**: Define entity classes that support all test scenarios.

#### Entity 1: SimpleEntity (Basic Property Tests)
```java
@Entity
static final class SimpleEntity {
    @Id Long id;
    String name;
    int age;
    boolean active;
    LocalDate birthday;
}
```

#### Entity 2: NestedEntity (Joined Property Tests)
```java
@Entity
static final class NestedEntity {
    @Id Long id;
    
    String name;
    
    @ManyToOne
    Department department;
    
    @ManyToOne
    Address address;
    
    @ManyToOne
    Account account;
}

@Entity
static final class Department {
    @Id Long id;
    String name;
}

@Entity
static final class Address {
    @Id Long id;
    String city;
    String state;
}

@Entity
static final class Account {
    @Id Long id;
    String email;
    String phone;
}
```

#### Entity 3: DeepNestedEntity (Multi-Level Joins)
```java
@Entity
static final class DeepNestedEntity {
    @Id Long id;
    
    @ManyToOne
    Department department;
    
    @ManyToOne
    Account account;
}

// Department has @ManyToOne Company
@Entity
static final class Company {
    @Id Long id;
    String name;
}
```

#### Entity 4: SelfReferentialEntity (Parent/Child Tests)
```java
@Entity
static final class SelfReferentialEntity {
    @Id Long id;
    String name;
    
    @ManyToOne
    SelfReferentialEntity parent;
    
    @OneToMany(mappedBy = "parent")
    List<SelfReferentialEntity> children;
}
```

#### Entity 5: EmbeddedEntity (Embedded Type Tests)
```java
@Entity
static final class EmbeddedEntity {
    @Id Long id;
    String name;
    
    @Embedded
    Location location;
}

@Embeddable
static final class Location {
    String city;
    String country;
    String zipCode;
}
```

#### Entity 6: SpecialCharEntity (Edge Cases)
```java
@Entity
static final class SpecialCharEntity {
    @Id Long id;
    String øre;      // Special char
    String år;       // Special char
    String 생일;     // Korean "birthday"
    String 이름;     // Korean "name"
    String URL;       // All caps, keyword
    int order2;      // Number in property name
}
```

### 1.2 Repository Interfaces

Each entity needs corresponding repository interface for reflection-based testing:

```java
interface SimpleEntityRepository extends Repository<SimpleEntity, Long> {
    // Generated from method names
    List<SimpleEntity> findByName(String name);
    List<SimpleEntity> findByAgeGreaterThan(int age);
    List<SimpleEntity> findByActiveTrue();
}

interface NestedEntityRepository extends Repository<NestedEntity, Long> {
    List<NestedEntity> findByDepartmentName(String name);
    List<NestedEntity> findByAccountEmailLike(String pattern);
    List<NestedEntity> findByParentIdIsNull();
}
```

## Phase 2: Test Scenario Organization

### 2.1 Simple Property Tests

**Objective**: Verify basic property resolution against entity fields.

```java
@Test
void tokenizeSimpleProperty_ResolvesFromEntityFields() {
    Class<SimpleEntity> entityClass = SimpleEntity.class;
    var tokens = QueryMethodLexer.tokenize(entityClass, "findByName");
    
    assertThat(tokens).hasSize(1);
    assertThat(tokens.get(0).value()).isEqualTo("name");
}

@Test
void tokenizeSimpleProperty_ValidatesFieldExists() {
    Class<SimpleEntity> entityClass = SimpleEntity.class;
    var tokens = QueryMethodLexer.tokenize(entityClass, "findByNonExistentField");
    
    // Should throw exception or mark as invalid
    assertThatThrownBy(() -> QueryMethodLexer.tokenize(entityClass, "findByNonExistentField"))
        .isInstanceOf(IllegalArgumentException.class);
}
```

**Test Cases**:
- `findByName` → property `name` exists ✅
- `findByAge` → property `age` exists ✅
- `findByActive` → property `active` exists ✅
- `findByBirthday` → property `birthday` exists ✅
- `findByNonExistent` → should fail ❌

### 2.2 Nested/Joined Property Tests

**Objective**: Verify correct property path resolution for navigation.

```java
@Test
void tokenizeNestedProperty_ResolvesToDotNotation() {
    Class<NestedEntity> entityClass = NestedEntity.class;
    var tokens = QueryMethodLexer.tokenize(entityClass, "findByDepartmentName");
    
    assertThat(tokens).hasSize(2);
    assertThat(tokens.get(0).value()).isEqualTo("department.name");  // dot notation
    assertThat(tokens.get(1).value()).isEqualTo("IsNull");
}

@Test
void tokenizeDeepNestedProperty_ResolvesMultipleLevels() {
    Class<DeepNestedEntity> entityClass = DeepNestedEntity.class;
    var tokens = QueryMethodLexer.tokenize(entityClass, "findByDepartmentCompanyName");
    
    assertThat(tokens.get(0).value()).isEqualTo("department.company.name");
}

@Test
void tokenizeAmbiguousProperty_UsesLongerMatch() {
    Class<NestedEntity> entityClass = NestedEntity.class;
    // Entity has both: department.name AND departmentName field?
    var tokens = QueryMethodLexer.tokenize(entityClass, "findByDepartmentName");
    
    // Should prefer department.name if exists, else use departmentName
    assertThat(tokens.get(0).value()).isEqualTo("department.name");
}
```

**Test Cases**:
- `findByDepartmentName` → `department.name` ✅
- `findByAccountEmail` → `account.email` ✅
- `findByAddressCity` → `address.city` ✅
- `findByParentId` → `parent.id` ✅
- `findByDepartmentCompanyName` → `department.company.name` (multi-level) ✅

### 2.3 Comparison Operator Tests

**Objective**: Verify all comparison operators tokenize correctly.

```java
@Test
void tokenizeGreaterThan_ProducesOperatorToken() {
    var tokens = QueryMethodLexer.tokenize(SimpleEntity.class, "findByAgeGreaterThan");
    
    assertThat(tokens).hasSize(2);
    assertThat(tokens.get(1).value()).isEqualTo("GreaterThan");
}

@Test
void tokenizeBetween_ProducesTwoValueMarkers() {
    var tokens = QueryMethodLexer.tokenize(SimpleEntity.class, "findByAgeBetween");
    
    assertThat(tokens).hasSize(2);
    assertThat(tokens.get(1).value()).isEqualTo("Between");
    // Between consumes TWO parameters in query binding
}
```

**Test Cases**:
- `GreaterThan` ✅
- `LessThan` ✅
- `GreaterThanEqual` ✅
- `LessThanEqual` ✅
- `Between` ✅
- `In` ✅
- `NotIn` ✅

### 2.4 String Operator Tests

**Objective**: Verify string-specific operators.

```java
@Test
void tokenizeLike_ProducesOperatorToken() {
    var tokens = QueryMethodLexer.tokenize(SimpleEntity.class, "findByNameLike");
    
    assertThat(tokens).hasSize(2);
    assertThat(tokens.get(1).value()).isEqualTo("Like");
}

@Test
void tokenizeStartingWith_ProducesOperatorToken() {
    var tokens = QueryMethodLexer.tokenize(SimpleEntity.class, "findByNameStartingWith");
    
    assertThat(tokens).hasSize(2);
    assertThat(tokens.get(1).value()).isEqualTo("StartingWith");
}
```

**Test Cases**:
- `Like` ✅
- `NotLike` ✅
- `StartingWith` ✅
- `EndingWith` ✅
- `Containing` ✅
- `NotContaining` ✅

### 2.5 Boolean/Null Operator Tests

**Objective**: Verify boolean and null operators.

```java
@Test
void tokenizeTrue_ProducesOperatorToken() {
    var tokens = QueryMethodLexer.tokenize(SimpleEntity.class, "findByActiveTrue");
    
    assertThat(tokens).hasSize(2);
    assertThat(tokens.get(1).value()).isEqualTo("True");
}

@Test
void tokenizeIsNull_ProducesOperatorToken() {
    var tokens = QueryMethodLexer.tokenize(NestedEntity.class, "findByParentIdIsNull");
    
    assertThat(tokens).hasSize(2);
    assertThat(tokens.get(1).value()).isEqualTo("IsNull");
}
```

**Test Cases**:
- `True` ✅
- `False` ✅
- `IsTrue` ✅
- `IsFalse` ✅
- `IsNull` ✅
- `IsNotNull` ✅

### 2.6 IgnoreCase Modifier Tests

**Objective**: Verify IgnoreCase sets flag on operator token.

```java
@Test
void tokenizeLikeIgnoreCase_ProducesOperatorWithIgnoreCaseFlag() {
    var tokens = QueryMethodLexer.tokenize(SimpleEntity.class, "findByNameLikeIgnoreCase");
    
    assertThat(tokens).hasSize(2);  // Like and IgnoreCase merged
    assertThat(tokens.get(1).value()).isEqualTo("LikeIgnoreCase");
    assertThat(tokens.get(1).ignoreCase()).isTrue();
}

@Test
void tokenizeAllIgnoreCase_ProducesMultipleOperatorsWithFlags() {
    var tokens = QueryMethodLexer.tokenize(SimpleEntity.class, 
        "findByNameAndAgeGreaterThanAllIgnoreCase");
    
    assertThat(tokens).hasSize(4);
    assertThat(tokens.get(1).ignoreCase()).isTrue();   // And
    assertThat(tokens.get(3).ignoreCase()).isTrue();   // GreaterThan
}
```

**Test Cases**:
- `findByNameLikeIgnoreCase` → `name`, `LikeIgnoreCase` (ignoreCase=true) ✅
- `findByNameContainingIgnoreCase` → `name`, `ContainingIgnoreCase` (ignoreCase=true) ✅
- `findByNameStartingWithIgnoreCase` → `name`, `StartingWithIgnoreCase` (ignoreCase=true) ✅
- `findByFirstNameAndLastNameIgnoreCase` → All operators marked ignoreCase=true ✅

### 2.7 AND/OR Combinator Tests

**Objective**: Verify combinators separate conditions correctly.

```java
@Test
void tokenizeAndCombination_ProducesTwoConditions() {
    var tokens = QueryMethodLexer.tokenize(SimpleEntity.class, "findByNameAndAge");
    
    assertThat(tokens).hasSize(3);
    assertThat(tokens.get(0).value()).isEqualTo("name");
    assertThat(tokens.get(1).value()).isEqualTo("And");
    assertThat(tokens.get(2).value()).isEqualTo("age");
}

@Test
void tokenizeOrCombination_ProducesTwoConditions() {
    var tokens = QueryMethodLexer.tokenize(SimpleEntity.class, "findByNameOrAge");
    
    assertThat(tokens).hasSize(3);
    assertThat(tokens.get(1).value()).isEqualTo("Or");
}
```

**Test Cases**:
- `findByNameAndAge` → 3 tokens ✅
- `findByNameOrAge` → 3 tokens ✅
- `findByNameAndAgeAndActive` → 5 tokens ✅
- `findByNameOrAgeOrActive` → 5 tokens ✅
- `findByNameAndAgeGreaterThanAndActiveTrue` → 6 tokens ✅

### 2.8 OrderBy Clause Tests

**Objective**: Verify OrderBy parsing with property normalization.

```java
@Test
void tokenizeOrderBySingleProperty_ProducesCorrectTokens() {
    var tokens = QueryMethodLexer.tokenize(SimpleEntity.class, "findByAgeOrderByPrice");
    
    assertThat(tokens).hasSize(2);
    assertThat(tokens.get(0).value()).isEqualTo("age");
    assertThat(tokens.get(1).value()).isEqualTo("OrderBy");
    // Note: Price is not in WHERE clause
}

@Test
void tokenizeOrderByWithDirection_ProducesDirectionToken() {
    var tokens = QueryMethodLexer.tokenize(SimpleEntity.class, "findByAgeOrderByPriceDesc");
    
    assertThat(tokens).hasSize(3);
    assertThat(tokens.get(0).value()).isEqualTo("age");
    assertThat(tokens.get(1).value()).isEqualTo("OrderBy");
    assertThat(tokens.get(2).type()).isEqualTo(QueryMethodTokenType.DESC);
}

@Test
void tokenizeOrderByMultipleProperties_ProducesAndCombinator() {
    var tokens = QueryMethodLexer.tokenize(NestedEntity.class, 
        "findByDepartmentNameOrderByAddressCityAscAndAccountEmailDesc");
    
    assertThat(tokens).hasSize(7);
    // Tokens: department, name, OrderBy, address.city, Asc, And, account.email, Desc
}
```

**Test Cases**:
- `findByAgeOrderByPrice` → `age`, `OrderBy` ✅
- `findByAgeOrderByPriceAsc` → `age`, `OrderBy`, `price`, `Asc` ✅
- `findByAgeOrderByPriceDesc` → `age`, `OrderBy`, `price`, `Desc` ✅
- `findByNameOrderByFirstNameAscAndLastNameDesc` → Multi-property OrderBy ✅

### 2.9 Edge Case Tests

**Objective**: Verify lexer handles special cases correctly.

#### Special Characters
```java
@Test
void tokenizeSpecialCharacters_PreservesUnicode() {
    var tokens = QueryMethodLexer.tokenize(SpecialCharEntity.class, "findByØre");
    
    assertThat(tokens.get(0).value()).isEqualTo("øre");
}

@Test
void tokenizeKoreanCharacters_PreservesHangul() {
    var tokens = QueryMethodLexer.tokenize(SpecialCharEntity.class, "findBy이름");
    
    assertThat(tokens.get(0).value()).isEqualTo("이름");
}
```

#### Property Names as Keywords
```java
@Test
void tokenizeOrderAsProperty_DoesNotConfuseWithKeyword() {
    // Entity has "order" field (not keyword in this context)
    var tokens = QueryMethodLexer.tokenize(SpecialCharEntity.class, "findByOrder");
    
    assertThat(tokens.get(0).value()).isEqualTo("order");
}
```

#### Numbers in Property Names
```java
@Test
void tokenizePropertyWithNumber_PreservesNumber() {
    var tokens = QueryMethodLexer.tokenize(SpecialCharEntity.class, "findByOrder2");
    
    assertThat(tokens.get(0).value()).isEqualTo("order2");
}
```

#### Empty Predicates
```java
@Test
void tokenizeOrderByOnly_ProducesNoConditionTokens() {
    var tokens = QueryMethodLexer.tokenize(SimpleEntity.class, "findAllByOrderByPrice");
    
    // Only OrderBy tokens, no WHERE conditions
    assertThat(tokens.stream()
        .filter(t -> t.type() == QueryMethodTokenType.OPERATOR && 
                     !t.value().equals("OrderBy"))
        .count())
        .isEqualTo(0);
}
```

### 2.10 Property Resolution Ambiguity Tests

**Objective**: Verify lexer uses entity metadata to resolve ambiguous paths.

```java
@Entity
static final class AmbiguousEntity {
    @Id Long id;
    
    String order;              // Direct field
    @ManyToOne OrderEntity orderRef;  // Relationship to OrderEntity
}

@Entity
static final class OrderEntity {
    @Id Long id;
    String orderNumber;
    String customerName;
}

@Test
void tokenizeAmbiguousProperty_UsesEntityMetadata() {
    // findByOrder - is this "order" field or "orderRef" relationship?
    // Entity metadata tells us "order" field EXISTS, so use that
    var tokens = QueryMethodLexer.tokenize(AmbiguousEntity.class, "findByOrder");
    
    assertThat(tokens.get(0).value()).isEqualTo("order");
}

@Test
void tokenizeNestedAmbiguousProperty_UsesLongestMatch() {
    // findByOrderCustomerName
    // Entity has: orderRef (→ OrderEntity → customerName)
    // Entity does NOT have: order.customerName field
    // So parse as: orderRef.customerName
    var tokens = QueryMethodLexer.tokenize(AmbiguousEntity.class, "findByOrderCustomerName");
    
    assertThat(tokens.get(0).value()).isEqualTo("orderRef.customerName");
}
```

## Phase 3: Integration Test Scenarios

### 3.1 Real-World Query Patterns

```java
@Test
void tokenizeRealWorldECommerceQuery() {
    // "findProductsByDepartmentNameAndPriceBetweenAndActiveTrue"
    var tokens = QueryMethodLexer.tokenize(ProductEntity.class, 
        "findProductsByDepartmentNameAndPriceBetweenAndActiveTrue");
    
    assertThat(tokens).hasSize(5);
    // department.name, And, price, Between, And, active, True
}

@Test
void tokenizeRealWorldUserQuery() {
    // "findUsersByAddressCityContainingIgnoreCaseAndStatusInOrderByLastNameAsc"
    var tokens = QueryMethodLexer.tokenize(UserEntity.class,
        "findUsersByAddressCityContainingIgnoreCaseAndStatusInOrderByLastNameAsc");
    
    // Verify complex query structure
    assertThat(tokens.stream()
        .filter(t -> t.ignoreCase())
        .count())
        .isEqualTo(1);  // Only ContainsIgnoreCase
}
```

### 3.2 Error Scenario Tests

```java
@Test
void tokenizeInvalidProperty_ThrowsException() {
    assertThatThrownBy(() -> 
        QueryMethodLexer.tokenize(SimpleEntity.class, "findByInvalidField")
    ).isInstanceOf(IllegalArgumentException.class)
        .hasMessageContaining("Property 'invalidField' not found in entity");
}

@Test
void tokenizeInvalidRelationship_ThrowsException() {
    assertThatThrownBy(() -> 
        QueryMethodLexer.tokenize(NestedEntity.class, "findByDepartmentNonExistentField")
    ).isInstanceOf(IllegalArgumentException.class)
        .hasMessageContaining("Property 'nonExistentField' not found");
}
```

## Phase 4: Test Implementation Structure

### 4.1 Test Class Organization

```java
@TestMethodOrder(MethodOrderer.class)
class ContextAwareLexerTest {
    
    static final Class<?>[] ENTITY_CLASSES = {
        SimpleEntity.class,
        NestedEntity.class,
        DeepNestedEntity.class,
        SelfReferentialEntity.class,
        EmbeddedEntity.class,
        SpecialCharEntity.class
    };
    
    @BeforeAll
    static void setup() {
        // Validate all entities have JPA annotations
        for (Class<?> entityClass : ENTITY_CLASSES) {
            assertThat(entityClass.isAnnotationPresent(Entity.class))
                .as("Entity " + entityClass.getSimpleName() + " missing @Entity")
                .isTrue();
        }
    }
    
    @TestFactory
    Stream<DynamicTest> tokenizeAllOperatorTypes() {
        return Stream.of(
            DynamicTest.dynamicTest("GreaterThan", 
                () -> verifyOperator("GreaterThan")),
            DynamicTest.dynamicTest("LessThan", 
                () -> verifyOperator("LessThan")),
            // ... all operators
        );
    }
}
```

### 4.2 Test Data Management

```java
@Test
void lexerIsThreadSafe() throws InterruptedException {
    CountDownLatch latch = new CountDownLatch(10);
    List<List<QueryMethodToken>> results = new ArrayList<>();
    
    for (int i = 0; i < 10; i++) {
        new Thread(() -> {
            results.add(QueryMethodLexer.tokenize(SimpleEntity.class, "findByName"));
            latch.countDown();
        }).start();
    }
    
    latch.await(5, TimeUnit.SECONDS);
    assertThat(results).hasSize(10);
    assertThat(results).allMatch(tokens -> 
        tokens.get(0).value().equals("name")
    );
}
```

## Phase 5: Verification Strategy

### 5.1 Unit Test Execution

```bash
# Run simple property tests
mvn test -Dtest=ContextAwareLexerTest#tokenize*

# Run specific operator tests
mvn test -Dtest=ContextAwareLexerTest#tokenizeGreaterThan*

# Run OrderBy tests
mvn test -Dtest=ContextAwareLexerTest#tokenizeOrderBy*
```

### 5.2 Integration Test Execution

```bash
# Test with MemrisRepositoryFactory
mvn test -Dtest=MemrisRepositoryIntegrationTest

# Verify lexer integration with QueryPlanner
mvn test -Dtest=QueryPlannerTest
```

### 5.3 Coverage Verification

```bash
# Generate coverage report
mvn test jacoco:report

# Verify lexer coverage
# Target: >95% coverage on QueryMethodLexer
```

## Phase 6: Success Criteria

### 6.1 Lexer Implementation

✅ **Context-Aware Parsing**:
- `QueryMethodLexer.tokenize(String methodName, Class<?> entityClass)`
- Uses entity metadata for property resolution
- Validates property paths against entity fields
- Resolves ambiguities using greedy matching with entity validation

✅ **Property Normalization**:
- Simple properties: `name` (lowercase)
- Joined properties: `department.name` (dot notation, lowercase segments)
- Deep joins: `department.company.name`

✅ **Operator Recognition**:
- All comparison operators (GreaterThan, LessThan, Between, In, etc.)
- All string operators (Like, StartingWith, Containing, etc.)
- Boolean operators (True, False, IsNull)
- Date operators (After, Before)

✅ **Modifier Handling**:
- IgnoreCase merged with operator: `LikeIgnoreCase`
- AllIgnoreCase: marks all operators with ignoreCase=true
- Distinct (not in token list, but recognized)

✅ **Combinator Recognition**:
- AND as separate token
- OR as separate token
- Proper separation of multiple conditions

✅ **OrderBy Parsing**:
- OrderBy as operator token
- Property names lowercased and converted to dot notation
- Direction (Asc/Desc) as separate tokens
- Multi-property OrderBy with AND combinators

### 6.2 Test Coverage

✅ **Operator Coverage**:
- All 20+ Spring Data operators tested
- Edge cases for each operator

✅ **Property Type Coverage**:
- Simple properties
- Nested/joined properties (2 levels)
- Deep nested properties (3+ levels)
- Self-referential properties
- Embedded properties

✅ **Complex Query Coverage**:
- Single condition
- Multiple AND conditions
- Multiple OR conditions
- Mixed AND/OR conditions
- OrderBy clauses (single and multiple)
- Empty predicates (OrderBy only)

✅ **Edge Case Coverage**:
- Special characters (Unicode, Korean)
- Property names as keywords
- Numbers in property names
- All-caps property names
- Empty method names

✅ **Error Scenario Coverage**:
- Invalid property names
- Invalid relationship paths
- Non-existent entity fields
- Ambiguous property paths

### 6.3 Performance Criteria

✅ **Lexer Performance**:
- Single pass tokenization (O(n) complexity)
- No reflection in hot path (entity metadata cached)
- Minimal allocations (re-use StringBuilder)
- Thread-safe (no shared mutable state)

## Phase 7: Risk Mitigation

### 7.1 Known Risks

| Risk | Impact | Mitigation |
|-------|---------|-------------|
| Entity reflection cost | Slow tokenization | Cache field metadata per entity class |
| Greedy matching errors | Wrong property resolution | Validate against actual entity fields |
| Case sensitivity | Property not found | Normalize to lowercase during comparison |
| Complex inheritance | Wrong field resolution | Support @MappedSuperclass scanning |

### 7.2 Rollback Strategy

If new lexer introduces regressions:
1. Keep old `tokenize(String methodName)` method (deprecated)
2. Add `tokenize(String methodName, Class<?> entityClass)` (new method)
3. Run test suite with both methods
4. If new method fails, fallback to old method
5. Incremental migration of test cases

## Phase 8: Implementation Order

1. **Phase 1**: Implement entity metadata extraction
   - `QueryMethodLexer` - add field extraction methods
   - Cache entity field metadata
   
2. **Phase 2**: Implement property resolution with entity context
   - Replace camelCase-based detection with entity field validation
   - Support greedy matching with entity validation
   
3. **Phase 3**: Update operator parsing for IgnoreCase merging
   - Merge IgnoreCase with preceding operator
   - Set ignoreCase flag correctly
   
4. **Phase 4**: Fix OrderBy property extraction
   - Use regex-based splitting
   - Normalize properties to dot notation
   
5. **Phase 5**: Create entity classes
   - Implement all entity structures from Phase 1.1
   
6. **Phase 6**: Create repository interfaces
   - Implement repository interfaces for each entity
   
7. **Phase 7**: Write test cases
   - Implement all test scenarios from Phase 2
   
8. **Phase 8**: Run and verify
   - Execute test suite
   - Verify coverage
   - Validate integration with QueryPlanner

## Summary

This testing plan provides:
- **7 entity classes** covering all relationship types
- **50+ test scenarios** covering operators, properties, complex queries
- **Context-aware lexer** using entity metadata for unambiguous parsing
- **Spring Data JPA compliant** property normalization (dot notation, lowercase)
- **Comprehensive coverage** of operators, modifiers, combinators, OrderBy

**Next Step**: Implement Phase 1 (entity metadata extraction) and create entity classes.
