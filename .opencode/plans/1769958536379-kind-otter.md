# Plan: Fix All Code Quality Issues

## Overview
Fix all reported code quality issues including Modernizer violations and a critical seqlock bug causing test failures.

## Issue Summary

### 1. Modernizer Violations (3 issues)
**Status**: FAILED
**File**: `memris-core/src/test/java/io/memris/core/ECommerceRealWorldTest.java`

The Modernizer plugin reports 3 violations for using `Optional.get()` instead of the more idiomatic `Optional.orElseThrow()`:

| Line | Current Code | Issue |
|------|-------------|-------|
| 361 | `found.get().name` | Prefer `Optional.orElseThrow()` |
| 362 | `found.get().id` | Prefer `Optional.orElseThrow()` |
| 516 | `found.get().name` | Prefer `Optional.orElseThrow()` |

All instances are preceded by `assertThat(found).isPresent()`, so the `get()` is safe. However, `orElseThrow()` is more idiomatic and expresses intent better.

### 2. Test Failure - SeqLock Bug
**Status**: FAILED
**Test**: `io.memris.storage.heap.RowLevelConcurrencyTest.seqlockCoordination_shouldPreventTornReads`

**Error Message**:
```
Should have no torn reads, but found: name=writer-2-iter-1, value=3002
expected: <0> but was: <2>
```

**Root Cause Analysis**:
The test verifies that seqlock coordination prevents torn reads when multiple writers update the same entity. The failure shows a torn read:
- Name: `writer-2-iter-1` (writer 2's data)
- Value: `3002` (writer 3's data, should be in range [2000, 2100))

**The Bug**:
In both `MethodHandleImplementation.java:InsertInterceptor` and `BytecodeTableGenerator.java:InsertInterceptor`, the seqlock is released BEFORE publishing columns:

```java
// Current buggy code:
table.beginSeqLock(rowIndex);
try {
    // Write values to columns
    for (int i = 0; i < columnFields.size(); i++) {
        // ... write each column
    }
} finally {
    table.endSeqLock(rowIndex);  // ❌ Released too early!
}

// Publish row to make data visible to scans  // ❌ Not protected by seqlock!
VarHandle.storeStoreFence();
for (int i = 0; i < columnFields.size(); i++) {
    // ... publish each column
}
```

**Why This Causes Torn Reads**:
1. Thread A writes name="writer-2", calls `endSeqLock()`, seqlock becomes even
2. Thread B starts writing, writes value=3002, calls `endSeqLock()`, seqlock becomes even again
3. Reader reads name after Thread A's publish (seqlock even)
4. Reader reads value after Thread B's publish (seqlock even)
5. seqBefore == seqAfter for both reads → No retry
6. Result: Torn read with mismatched columns!

**The Fix**:
Move `endSeqLock()` AFTER all publishes to ensure atomic visibility of all columns:

```java
table.beginSeqLock(rowIndex);
try {
    // Write values to columns
    for (int i = 0; i < columnFields.size(); i++) {
        // ... write each column
    }

    // Publish row to make data visible to scans
    VarHandle.storeStoreFence();
    for (int i = 0; i < columnFields.size(); i++) {
        // ... publish each column
    }
} finally {
    table.endSeqLock(rowIndex);  // ✅ Released after publishes!
}
```

## Implementation Plan

### Phase 1: Fix Modernizer Violations

**File**: `memris-core/src/test/java/io/memris/core/ECommerceRealWorldTest.java`

**Change 1.1 (Line 361)**:
```java
// Before:
assertThat(found.get().name).isEqualTo("Second User");

// After:
assertThat(found.orElseThrow().name).isEqualTo("Second User");
```

**Change 1.2 (Line 362)**:
```java
// Before:
assertThat(found.get().id).isEqualTo(saved.id);

// After:
assertThat(found.orElseThrow().id).isEqualTo(saved.id);
```

**Change 1.3 (Line 516)**:
```java
// Before:
assertThat(found.get().name).isEqualTo("Second");

// After:
assertThat(found.orElseThrow().name).isEqualTo("Second");
```

### Phase 2: Fix SeqLock Bug in MethodHandleImplementation

**File**: `memris-core/src/main/java/io/memris/storage/heap/MethodHandleImplementation.java`

**Change 2.1 (Lines 804-906)**:
Move `endSeqLock(rowIndex)` call from line 905 (in finally block after writes) to after all publishes (after line 938).

**Current structure**:
```java
table.beginSeqLock(rowIndex);
try {
    // Write columns (lines 809-903)
} finally {
    table.endSeqLock(rowIndex);  // ❌ Line 905
}

// Publish columns (lines 909-938)  // ❌ Not protected!
```

**Fixed structure**:
```java
table.beginSeqLock(rowIndex);
try {
    // Write columns (lines 809-903)

    // Publish row to make data visible to scans
    VarHandle.storeStoreFence();
    for (int i = 0; i < columnFields.size(); i++) {
        // ... publish each column
    }
} finally {
    table.endSeqLock(rowIndex);  // ✅ Moved to after publishes
}
```

**Note**: Remove the `VarHandle.storeStoreFence()` line 909 since the finally block's `endSeqLock()` already provides memory ordering.

### Phase 3: Fix SeqLock Bug in BytecodeTableGenerator

**File**: `memris-core/src/main/java/io/memris/storage/heap/BytecodeTableGenerator.java`

**Change 3.1 (Lines 907-1054)**:
Apply the same fix as Phase 2 for the byte code generated insert operation.

Move `endSeqLock(rowIndex)` call from the finally block (currently around line 1054) to after all publishes (after line 1054).

**Current structure** (approximate):
```java
table.beginSeqLock(rowIndex);
try {
    // Write columns (lines 910-1048)
} finally {
    table.endSeqLock(rowIndex);  // ❌ Released too early
}

// Publish columns (lines 1056-...)  // ❌ Not protected
```

**Fixed structure**:
```java
table.beginSeqLock(rowIndex);
try {
    // Write columns (lines 910-1048)

    // Publish row to make data visible to scans
    // Publish all columns...
} finally {
    table.endSeqLock(rowIndex);  // ✅ Released after publishes
}
```

### Phase 4: Verification

**Step 4.1**: Run Modernizer check
```bash
mvn.cmd -q -e -pl memris-core modernizer:modernizer
```
Expected: No violations

**Step 4.2**: Run concurrency test repeatedly (10 times)
```bash
for i in {1..10}; do
  mvn.cmd -q -e -pl memris-core test -Dtest=RowLevelConcurrencyTest#seqlockCoordination_shouldPreventTornReads
done
```
Expected: All passes (no intermittent failures)

**Step 4.3**: Run full test suite
```bash
mvn.cmd -q -e -pl memris-core test
```
Expected: All 640 tests pass

**Step 4.4**: Run all code quality checks
```bash
mvn.cmd -q -e verify
```
Expected:
- ✅ Checkstyle: PASSED
- ✅ SpotBugs: PASSED
- ✅ PMD: PASSED
- ✅ Modernizer: PASSED
- ✅ Tests: PASSED

## Critical Files to Modify

1. `memris-core/src/test/java/io/memris/core/ECommerceRealWorldTest.java`
   - Lines 361, 362, 516

2. `memris-core/src/main/java/io/memris/storage/heap/MethodHandleImplementation.java`
   - InsertInterceptor class (lines 779-960)
   - Move `endSeqLock()` call

3. `memris-core/src/main/java/io/memris/storage/heap/BytecodeTableGenerator.java`
   - InsertInterceptor class (lines 889-1058)
   - Move `endSeqLock()` call

## Risk Assessment

### Modernizer Fixes
**Risk**: LOW
- Simple string replacements in test code
- No behavioral changes
- Code is already safe (preceded by isPresent() check)

### SeqLock Fixes
**Risk**: MEDIUM
- Critical concurrency fix
- May affect performance (seqlock held longer during publishes)
- Requires careful testing
- Both implementations must be fixed consistently

**Performance Impact Analysis**:
- Positive: Reduces torn reads, improves consistency
- Negative: Seqlock held slightly longer during publishes
- Trade-off: Worth it for correctness; publishes are fast memory operations

**Mitigation**:
- Fix both implementations identically
- Run concurrency test repeatedly to verify no regressions
- Consider adding stress test with higher thread counts

## Expected Result

After implementation:
1. ✅ Modernizer: No violations
2. ✅ Concurrency test: Passes consistently (no intermittent failures)
3. ✅ All tests: 640/640 passing
4. ✅ All quality checks: PASSED

The seqlock fix ensures atomic multi-column writes, preventing torn reads in concurrent update scenarios.
