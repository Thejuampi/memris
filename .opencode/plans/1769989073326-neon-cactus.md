# Concurrency Optimization Implementation Plan

## Executive Summary

This document details a comprehensive analysis of concurrency implementation in the Memris codebase, identifying critical bugs, performance bottlenecks, and optimization opportunities.

---

## Critical Issues Requiring Immediate Fixes

### Issue 1: RepositoryRuntime ID Counter Sharing (CRITICAL)

**File**: `memris-core/src/main/java/io/memris/runtime/RepositoryRuntime.java:46`

**Problem**: Static `ID_COUNTER` is shared across all tables instead of per-table counters.

**Impact**:
- Global ID allocation causing single contention point
- IDs allocated across different tables instead of per-table
- Potential for long overflow (2^63 IDs globally)

**Current Code**:
```java
// Line 46
private static final AtomicLong ID_COUNTER = new AtomicLong(1L);

// Lines 550-552
private Long generateNextId() {
    return ID_COUNTER.getAndIncrement();
}
```

**Fix**:
```java
// Change to instance field in RepositoryRuntime record
private final AtomicLong idCounter = new AtomicLong(1L);

private Long generateNextId() {
    return idCounter.getAndIncrement();
}
```

**Testing**:
- Verify IDs are unique per table
- Verify no ID overlap between different entity types

**Risk**: LOW - Simple change to instance field

---

### Issue 2: TypeHandlerRegistry Non-Thread-Safe (HIGH)

**File**: `memris-core/src/main/java/io/memris/runtime/TypeHandlerRegistry.java:45-46`

**Problem**: Uses regular `HashMap` instead of `ConcurrentHashMap`, but documentation suggests it's extensible at runtime.

**Impact**:
- Data corruption if handlers are registered concurrently
- Potential exceptions during concurrent access

**Current Code**:
```java
// Lines 45-46
private final Map<Byte, TypeHandler<?>> handlersByTypeCode = new HashMap<>();
private final Map<Class<?>, TypeHandler<?>> handlersByJavaType = new HashMap<>();
```

**Fix**:
```java
private final ConcurrentHashMap<Byte, TypeHandler<?>> handlersByTypeCode = new ConcurrentHashMap<>();
private final ConcurrentHashMap<Class<?>, TypeHandler<?>> handlersByJavaType = new ConcurrentHashMap<>();
```

**Testing**:
- Run concurrent handler registration tests
- Verify no data corruption under concurrent access

**Risk**: MEDIUM - HashMap to ConcurrentHashMap is safe, but need to verify all usage patterns

---

### Issue 3: LockFreeFreeList Node.next Not Volatile (MEDIUM)

**File**: `memris-core/src/main/java/io/memris/storage/heap/LockFreeFreeList.java:77`

**Problem**: `Node.next` field is not volatile, which can cause unsafe publication.

**Impact**:
- Published nodes may have stale `next` references
- ABA problem possible (though less likely due to single-writer pattern)

**Current Code**:
```java
// Line 77
private static final class Node {
    final int rowId;
    Node next;  // Should be volatile!
    
    Node(int rowId) {
        this.rowId = rowId;
    }
}
```

**Fix**:
```java
private static final class Node {
    final int rowId;
    volatile Node next;  // Add volatile for safe publication
    
    Node(int rowId) {
        this.rowId = rowId;
    }
}
```

**Testing**:
- Run existing `AbstractTableFreeListConcurrencyTest`
- Stress test with high contention

**Risk**: LOW - Adding volatile is always safe

---

### Issue 4: PageColumn publish() Non-Atomic (MEDIUM)

**Files**:
- `memris-core/src/main/java/io/memris/storage/heap/PageColumnInt.java:23, 41, 155-164`
- `memris-core/src/main/java/io/memris/storage/heap/PageColumnLong.java:23, 41, 155-164`
- `memris-core/src/main/java/io/memris/storage/heap/PageColumnString.java:23, 41, 156-165`

**Problem**: Non-atomic read-modify-write in `publish()` method can lose updates.

**Current Code**:
```java
// Lines 155-164
public void publish(int newPublished) {
    if (newPublished < 0 || newPublished > capacity) {
        throw new IndexOutOfBoundsException("newPublished out of range: " + newPublished);
    }
    // Monotonic publish - only increase
    int current = this.published;
    if (newPublished > current) {
        this.published = newPublished;  // RACE: Non-atomic update!
    }
}
```

**Fix**:
```java
// 1. Change field declaration (line 23)
private final AtomicInteger published;

// 2. Update constructor initialization (line 41)
this.published = new AtomicInteger(0);

// 3. Update publish() method
public void publish(int newPublished) {
    if (newPublished < 0 || newPublished > capacity) {
        throw new IndexOutOfBoundsException("newPublished out of range: " + newPublished);
    }
    // Monotonic publish - only increase (atomic with CAS)
    int current;
    do {
        current = published.get();
        if (newPublished <= current) {
            return; // No update needed
        }
    } while (!published.compareAndSet(current, newPublished));
}

// 4. Update all reads: replace `published` with `published.get()`
// Example: int count = Math.min(published.get(), limit);
```

**Testing**:
- Run `PageColumnConcurrencyTest`
- Verify monotonic property is preserved under concurrent publishing

**Risk**: MEDIUM - Changes internal field type but maintains semantics

---

### Issue 5: LockFreeFreeList Size Unnecessary Atomic (LOW)

**File**: `memris-core/src/main/java/io/memris/storage/heap/LockFreeFreeList.java:15`

**Problem**: Uses `AtomicInteger` for size which is documented as "approximate".

**Impact**:
- Unnecessary atomic operation overhead
- Size not required for correctness

**Current Code**:
```java
// Line 15
private final AtomicInteger size = new AtomicInteger(0);

// Lines 29, 50
size.incrementAndGet();
size.decrementAndGet();

// Line 72
return size.get();
```

**Fix**:
```java
// Change to volatile int
private volatile int size;

// In push() and pop(), replace with regular increment/decrement
size++;  // instead of size.incrementAndGet();
size--;  // instead of size.decrementAndGet();

// In size(), remove .get()
return size;  // instead of size.get()
```

**Testing**:
- Size is already documented as approximate, no specific tests needed
- Verify size tracking still works reasonably well

**Risk**: LOW - Performance-only optimization

---

## Performance Optimization Opportunities

### Opt 1: RowIdArraySet Performance (HIGH)

**File**: `memris-core/src/main/java/io/memris/kernel/RowIdArraySet.java`

**Problem**: O(n) array cloning on every mutation causes severe performance degradation.

**Current Implementation**:
```java
// Line 36
long[] nextValues = Arrays.copyOf(current.values, capacity);
```

**Solution**: Replace with ConcurrentHashMap-based implementation:
```java
public final class RowIdArraySetOptimized implements MutableRowIdSet {
    private final ConcurrentHashMap<Long, Boolean> valueSet = new ConcurrentHashMap<>();
    private final AtomicInteger size = new AtomicInteger(0);

    @Override
    public void add(RowId rowId) {
        if (rowId == null) return;
        valueSet.put(rowId.value(), Boolean.TRUE);
        size.incrementAndGet();
    }

    @Override
    public void remove(RowId rowId) {
        if (rowId == null) return;
        if (valueSet.remove(rowId.value()) != null) {
            size.decrementAndGet();
        }
    }

    @Override
    public boolean contains(RowId rowId) {
        return rowId != null && valueSet.containsKey(rowId.value());
    }

    @Override
    public int size() {
        return size.get();
    }

    @Override
    public LongEnumerator enumerator() {
        return new LongEnumerator() {
            private final Iterator<Long> it = valueSet.keySet().iterator();

            @Override
            public boolean hasNext() {
                return it.hasNext();
            }

            @Override
            public long nextLong() {
                return it.next();
            }
        };
    }
}
```

**Benefit**: O(1) operations instead of O(n), 10-100x faster for large sets

**Risk**: MEDIUM - New implementation requires thorough testing

---

### Opt 2: RowIdBitSet Chunk-Based COW (MEDIUM)

**File**: `memris-core/src/main/java/io/memris/kernel/RowIdBitSet.java`

**Problem**: Full word array clone on every add (O(m) where m = number of words).

**Current Implementation**:
```java
// Line 36
long[] nextWords = words.clone();
```

**Solution**: Use chunk-based copy-on-write:
```java
public final class RowIdBitSetChunked implements MutableRowIdSet {
    private static final int CHUNK_WORDS = 64; // 4096 bits per chunk
    private final AtomicReference<ChunkedState> state;

    private static final class ChunkedState {
        final AtomicReference<long[]>[] chunks;
        final int size;

        @SuppressWarnings("unchecked")
        ChunkedState(int numChunks) {
            this.chunks = new AtomicReference[numChunks];
            for (int i = 0; i < numChunks; i++) {
                chunks[i] = new AtomicReference<>(new long[CHUNK_WORDS]);
            }
            this.size = 0;
        }

        ChunkedState(ChunkedState other) {
            this.chunks = other.chunks.clone();
            this.size = other.size;
        }
    }

    @Override
    public void add(RowId rowId) {
        if (rowId == null) throw new IllegalArgumentException("rowId required");
        int index = toIndex(rowId);
        int wordIndex = index >>> 6;
        int chunkIndex = wordIndex / CHUNK_WORDS;

        while (true) {
            ChunkedState current = state.get();

            // Ensure chunks array is large enough
            if (chunkIndex >= current.chunks.length) {
                ChunkedState expanded = expandChunks(current, chunkIndex);
                if (state.compareAndSet(current, expanded)) {
                    current = expanded;
                } else {
                    continue;
                }
            }

            int wordInChunk = wordIndex % CHUNK_WORDS;
            long bitMask = 1L << (index & 63);

            AtomicReference<long[]> chunkRef = current.chunks[chunkIndex];
            long[] chunk = chunkRef.get();

            if ((chunk[wordInChunk] & bitMask) != 0L) {
                return; // Already present
            }

            // Clone only the affected chunk
            long[] newChunk = chunk.clone();
            newChunk[wordInChunk] = chunk[wordInChunk] | bitMask;

            if (chunkRef.compareAndSet(chunk, newChunk)) {
                state.updateAndGet(s -> new ChunkedState(s, s.size + 1));
                return;
            }
            // CAS failed, retry
        }
    }

    private ChunkedState expandChunks(ChunkedState current, int requiredChunk) {
        int newSize = Math.max(current.chunks.length * 2, requiredChunk + 1);
        ChunkedState expanded = new ChunkedState(newSize);
        System.arraycopy(current.chunks, 0, expanded.chunks, 0, current.chunks.length);
        for (int i = current.chunks.length; i < newSize; i++) {
            expanded.chunks[i] = new AtomicReference<>(new long[CHUNK_WORDS]);
        }
        expanded.size = current.size;
        return expanded;
    }
}
```

**Benefit**: 64x less memory churn, significantly faster under contention

**Risk**: MEDIUM - Complex implementation, requires thorough testing

---

### Opt 3: Thread-Local Sorting Buffers (LOW)

**File**: `memris-core/src/main/java/io/memris/runtime/RepositoryRuntime.java`

**Problem**: Frequent array allocation during sorting operations.

**Solution**: Use thread-local buffers for sorting:
```java
private static final ThreadLocal<int[]> sortBuffer =
    ThreadLocal.withInitial(() -> new int[MAX_SORT_SIZE]);

private int[] sortByIntColumn(int[] rows, int columnIndex, boolean ascending) {
    int[] result = rows.clone();
    int[] buffer = sortBuffer.get();
    if (buffer.length < result.length) {
        buffer = new int[result.length];
        sortBuffer.set(buffer);
    }
    // ... use buffer for sorting ...
    return result;
}
```

**Benefit**: Reduces GC pressure for frequently executed sorts

**Risk**: LOW - Simple optimization, well-tested pattern

---

## Files Summary

| File | Issue | Lines | Priority |
|------|-------|-------|----------|
| `RepositoryRuntime.java` | Static ID counter shared | 46, 550-552 | CRITICAL |
| `TypeHandlerRegistry.java` | HashMap not thread-safe | 45-46 | HIGH |
| `LockFreeFreeList.java` | Node.next not volatile | 77 | MEDIUM |
| `PageColumnInt.java` | Non-atomic publish() | 23, 41, 155-164 | MEDIUM |
| `PageColumnLong.java` | Non-atomic publish() | 23, 41, 155-164 | MEDIUM |
| `PageColumnString.java` | Non-atomic publish() | 23, 41, 156-165 | MEDIUM |
| `LockFreeFreeList.java` | Unnecessary AtomicInteger | 15, 29, 50, 72 | LOW |
| `RowIdArraySet.java` | O(n) copies | 36 | HIGH (opt) |
| `RowIdBitSet.java` | O(n) copies | 36 | MEDIUM (opt) |
| `RepositoryRuntime.java` | Array allocations in sort | Various | LOW (opt) |

---

## Implementation Order

### Phase 1: Critical Bug Fixes
1. **RepositoryRuntime ID counter** - Fix ID allocation
2. **TypeHandlerRegistry** - Make thread-safe
3. **LockFreeFreeList Node.next** - Add volatile

### Phase 2: Medium Priority Fixes
4. **PageColumn publish()** - Make atomic
5. **LockFreeFreeList size** - Remove unnecessary atomic

### Phase 3: Performance Optimizations (Optional)
6. **RowIdArraySet** - Replace with ConcurrentHashMap
7. **RowIdBitSet** - Chunk-based copy-on-write
8. **Thread-local sorting buffers** - Reduce allocations

---

## Testing Strategy

### Existing Tests

```bash
# Run all concurrency tests
mvn.cmd test -Dtest=*ConcurrencyTest

# Run specific tests
mvn.cmd test -Dtest=AbstractTableTombstoneConcurrencyTest
mvn.cmd test -Dtest=AbstractTableConcurrencyTest
mvn.cmd test -Dtest=PageColumnConcurrencyTest
mvn.cmd test -Dtest=AbstractTableFreeListConcurrencyTest
```

### Verification Checklist

After each change:

- [ ] **Compile**: Run `mvn clean compile` - verify compilation succeeds
- [ ] **Unit tests**: Run affected concurrency tests
- [ ] **Integration tests**: Run full test suite
- [ ] **Manual review**: Check for volatile/Atomic* usage

### Stress Test (Optional)

Create `ConcurrentUpdateStressTest.java`:
```java
@Test
void shouldHandleConcurrentTombstoneAndSave() {
    // 10 writers: concurrent save() with overlapping IDs
    // 10 readers: concurrent findBy* queries
    // 10 deleters: concurrent delete()
    // Verify no index corruption or lost updates
}
```

---

## Risk Assessment

| Issue | Risk Level | Mitigation |
|-------|------------|------------|
| RepositoryRuntime ID counter | LOW | Simple change to instance field |
| TypeHandlerRegistry | MEDIUM | HashMap to ConcurrentHashMap is safe |
| LockFreeFreeList Node.next | LOW | Adding volatile is always safe |
| PageColumn publish() | MEDIUM | Atomic maintains monotonic semantics |
| LockFreeFreeList size | LOW | Performance-only, documented as approximate |
| RowIdArraySet optimization | MEDIUM | New implementation, thorough testing required |
| RowIdBitSet optimization | MEDIUM | Complex implementation, thorough testing required |

---

## Performance Comparison (Expected)

| Optimization | Before | After | Improvement |
|--------------|--------|-------|-------------|
| RowIdArraySet add | O(n) | O(1) | 10-100x |
| RowIdBitSet add | O(m) | O(1) per chunk | 64x less GC |
| LockFreeFreeList size | Atomic ops | Regular ops | ~5ns per op |
| PageColumn publish | Non-atomic | CAS-based | Correctness + minor perf |
| ID allocation | Global counter | Per-table | No contention |

---

## Notes

- All critical fixes maintain API compatibility
- No reflection introduced into hot paths
- Follows existing lock-free design patterns
- Thread safety guarantees are preserved or improved
