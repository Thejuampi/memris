# Documentation Update Plan - Memris

## Executive Summary

**Key Context:**
- **FFM (Foreign Function Memory)** is a **FUTURE ROADMAP ITEM** for off-heap storage replacement
- **Current architecture**: 100% heap-based (int[], long[], String[])
- **Concurrency goal**: Improve concurrent entity storage for repository use case

**Critical Issues to Address:**
1. FFM documentation - should document as FUTURE roadmap (not remove references)
2. Concurrency model - needs detailed documentation of current thread-safety
3. Concurrency improvements - identify well-known algorithms for repository use case
4. Performance characteristics - document current bottlenecks and improvement opportunities

## Files to Update

| File | Priority | Changes Required |
|------|----------|------------------|
| `docs/ARCHITECTURE.md` | High | FFM as future roadmap, concurrency model, RangeIndex, SIMD status |
| `docs/SPRING_DATA.md` | High | Relationships accurate, package structure, concurrency notes |
| `docs/examples/ecommerce-domain.md` | High | Remove non-existent features, update PlantUML |
| `docs/QUERY.md` | High | Package references, operator status verification |
| `CLAUDE.md` | High | FFM roadmap, concurrency model, package structure |
| `docs/CONCURRENCY.md` | High | **CREATE NEW** - comprehensive concurrency documentation |
| `docs/ROADMAP.md` | High | **CREATE NEW** - future features including FFM |
| `README.md` | Medium | FFM as roadmap item, remove SIMD references |
| `docs/DEVELOPMENT.md` | Medium | Remove SIMD references, add concurrency guidelines |
| `tmp/test-that-need-attention.md` | Low | Archive FFM migration doc as historical |

## Detailed Changes

### 1. docs/ARCHITECTURE.md

**Update Package Structure:**
- Line 66: `io.memris.spring.plan` â†’ `io.memris.query`
- Line 67: `io.memris.spring.runtime` â†’ `io.memris.runtime`
- Line 68: `io.memris.spring.scaffold` â†’ `io.memris.repository`
- Add row for `io.memris.core` (custom annotations & types)
- Lines 84, 98, 121: Update package references

**Add FFM Roadmap Section:**
Add after line 18 (before "Key Design Decisions"):
```markdown
## Future Roadmap: FFM-Based Storage

**Planned Feature**: Off-heap storage using Java Foreign Function & Memory (FFM) API to replace current heap-based storage.

**Benefits:**
- Reduced GC pressure for large datasets
- Direct memory control for predictable latency
- Potential for SIMD vectorization via Vector API
- Memory-mapped file persistence

**Current Design**: Heap-based storage with primitive arrays is sufficient for most use cases and provides:
- Simpler deployment (no `--enable-native-access` required)
- Better Java integration and debugging
- JIT-optimized primitive arrays
- Zero configuration overhead

**Implementation Complexity**: HIGH
- Requires Arena lifecycle management
- String pooling for off-heap storage
- Coordination across threads for Arena access
- Module system integration
```

**Update Notes Section:**
Replace line 317:
```markdown
## Notes

- **Current Storage**: 100% heap-based using primitive arrays (int[], long[], String[])
- **Future Roadmap**: FFM off-heap storage planned for large dataset scenarios
- **SIMD Not Implemented**: Plain loops used; JIT may auto-vectorize but no explicit Vector API
- **Custom Annotations**: Uses `@Entity`, `@Index`, etc. (not Jakarta/JPA)
- **No Repository Generation**: Generates tables, caller implements repository pattern
- **Relationship Support**: @OneToOne and @ManyToOne fully implemented; @OneToMany and @ManyToMany not implemented
- **RangeIndex Exists**: O(log n) operations via ConcurrentSkipListMap
- **Concurrency Model**: Multi-reader, single-writer (external sync required for concurrent writes)
```

**Add Important Files Reference:**
Replace lines 296-311 with comprehensive table including concurrency files.

---

### 2. docs/SPRING_DATA.md

**Update Package Structure:**
- Line 50: `io.memris.spring.Entity` â†’ `io.memris.core.Entity`
- Lines 54, 59, 68, 72, 75: Update all package references
- Lines 84-87: Update import statements
- Lines 192, 199, 205, 210: Update architecture section

**Update @OneToOne Description:**
Replace line 64:
```markdown
**@OneToOne** (`io.memris.core.OneToOne`)
- Marks a one-to-one relationship
- Cascade operations NOT implemented
```

**Add Concurrency Notes:**
Add after line 266:
```markdown
### Concurrency Model

**Current Implementation:**
- Multi-reader: Thread-safe concurrent queries (via HashIndex, RangeIndex)
- Single-writer: Assumes single-threaded saves (external synchronization required)
- Read-write coordination: No coordination between reads and writes
- Isolation level: Best-effort (no MVCC or transactions)

**Thread-Safe Operations:**
- ID generation: `AtomicLong` per entity class (lock-free)
- ID indexes: `ConcurrentHashMap` for lock-free lookups
- Query execution: Thread-safe reads on published data
- Index updates: `ConcurrentHashMap.compute()` / `ConcurrentSkipListMap.compute()`

**NOT Thread-Safe (External Sync Required):**
- Entity saves: Multiple concurrent saves can corrupt column state
- Entity deletes: Tombstone BitSet operations not synchronized
- Row allocation: Free-list operations not synchronized

**See Also:** [CONCURRENCY.md](CONCURRENCY.md) for detailed concurrency model and improvement roadmap.
```

---

### 3. docs/examples/ecommerce-domain.md

**Update Overview:**
Replace line 5:
```markdown
This document describes real-world e-commerce domain model implemented in `ECommerceRealWorldTest.java`. It demonstrates Memris's support for @ManyToOne and @OneToOne relationships with manual foreign key fields.
```

**Update PlantUML Relationships:**
Replace lines 130-143:
```plantuml
' Relationships
Account "1" --> "1" Customer : One-to-One
Customer "1" --> "*" Order : NOT IMPLEMENTED
Customer "1" --> "1" Address : Many-to-One (billing)
Customer "1" --> "1" Address : Many-to-One (shipping)
Category "1" --> "0..1" Category : self (parent)
Category "*" --> "1" Category : children
Product "*" --> "1" Supplier : Many-to-One
Product "*" --> "*" Category : NOT IMPLEMENTED
Supplier "1" --> "1" Address : Many-to-One
Order "*" --> "1" Customer : Many-to-One
Order "*" --> "*" Coupon : NOT IMPLEMENTED
Order "1" --> "*" OrderItem : NOT IMPLEMENTED
OrderItem "*" --> "1" Product : Many-to-One
OrderItem "*" --> "1" Order : Many-to-One
```

**Remove Non-Existent Features:**
- Delete lines 52-53: `<<EMBEDDABLE>>` and `<<TRANSIENT>>` from Product
- Delete lines 81-82: `<<ENUM(STRING)>>` and `<<ENUM(ORDINAL)>>` from Order
- Delete line 33: `<<TRANSIENT>>` from Customer
- Delete entire "Lifecycle Callbacks" section (lines 275-295)

**Update Test Coverage:**
Replace lines 255-273:
```markdown
## Test Coverage

The `ECommerceRealWorldTest` includes 12 comprehensive query tests:

1. âœ… Find by indexed SKU
2. âœ… Price range query
3. âœ… Low stock detection
4. âœ… Order status filtering
5. âœ… Amount-based filtering
6. âœ… Name pattern matching
7. âœ… Slug-based lookup
8. âœ… Active coupon retrieval
9. âœ… Self-referential hierarchy
10. âœ… Combined status + amount query
11. âœ… Name contains + price constraint
12. âœ… Related entity field queries

**Note:** @Embeddable, @Enumerated, and lifecycle callbacks (@PrePersist, @PostLoad) are NOT implemented. Entities use manual foreign key fields (long) for relationships.
```

---

### 4. docs/QUERY.md

**Update Package References:**
- Line 273: `io.memris.spring.plan.QueryMethodLexer` â†’ `io.memris.query.QueryMethodLexer`
- Line 279: `io.memris.spring.plan.QueryPlanner` â†’ `io.memris.query.QueryPlanner`
- Line 284: `io.memris.spring.plan.BuiltInResolver` â†’ `io.memris.query.BuiltInResolver`

---

### 5. CLAUDE.md

**Update Package Structure:**
- Line 127: `io.memris.spring.plan` â†’ `io.memris.query`
- Line 128: `io.memris.spring.runtime` â†’ `io.memris.runtime`
- Line 129: `io.memris.spring.scaffold` â†’ `io.memris.repository`
- Lines 158-161: Update annotation package references

**Add FFM Roadmap Note:**
Add after line 17 (before "Package Structure"):
```markdown
- **FFM Off-Heap Storage**: Planned for future (see docs/ROADMAP.md)
- **Bytecode Implementation**: Default table generation strategy with ~1ns overhead
- **MethodHandle Implementation**: Fallback strategy with ~5ns overhead
```

**Add Concurrency Model Note:**
Add after line 176 (before "Join Table Implementation"):
```markdown
**Concurrency Model**: Multi-reader, single-writer (see docs/CONCURRENCY.md)
- Thread-safe: Queries, ID lookups, index reads
- External sync required: Concurrent saves, concurrent deletes
```

---

### 6. docs/CONCURRENCY.md (CREATE NEW)

```markdown
# Concurrency Model

## Current Implementation

### Concurrency Characteristics

**Thread-Safe Operations:**

| Operation | Thread-Safety | Mechanism | Location |
|-----------|--------------|------------|----------|
| ID generation | âœ… Lock-free | `AtomicLong.getAndIncrement()` | `MemrisRepositoryFactory:287` |
| ID index lookups | âœ… Lock-free | `ConcurrentHashMap.get()` | `LongIdIndex.java:38`, `StringIdIndex.java:38` |
| HashIndex lookups | âœ… Lock-free | `ConcurrentHashMap.get()` | `HashIndex.java:67` |
| RangeIndex lookups | âœ… Lock-free | `ConcurrentSkipListMap.get()` | `RangeIndex.java:51` |
| Query scans | âœ… Safe reads | `volatile published` watermark | `PageColumn*.java:20` |
| Index add/remove | âœ… Thread-safe | `compute()` / `computeIfAbsent()` | `HashIndex.java:31`, `RangeIndex.java:34` |

**NOT Thread-Safe (External Synchronization Required):**

| Operation | Issue | Impact | Location |
|-----------|--------|---------|----------|
| Entity saves | Free-list race condition | Data corruption | `AbstractTable.java:114-136` |
| Row allocation | Unsynchronized free-list | Duplicate row IDs | `AbstractTable.java:36-37` |
| Column writes | No atomicity between writes | Torn reads | `PageColumn*.java:79-84` |
| Entity deletes | Unsynchronized tombstones | Double decrement | `AbstractTable.java:175-186` |
| Index updates | Race with column writes | Inconsistent state | `RepositoryRuntime.java:203-220` |

### Concurrency Model Summary

**Current Design:**
- **Reads**: Thread-safe, lock-free for most operations
- **Writes**: Single-threaded (assumes external coordination)
- **Read-Write**: No coordination, potential inconsistency
- **Isolation**: Best-effort (no MVCC, no transactions)

### Critical Issues

**1. Free-List Race Condition** (`AbstractTable.java:116-117`)
Multiple threads can pop the same row ID from free-list:
```java
// PROBLEM: Two threads can get same index
if (freeListSize > 0) {
    int reusedRowId = freeList[--freeListSize];  // Race condition!
    // Both threads write to same offset
}
```

**Impact**: Data corruption when concurrent saves reuse deleted rows.

**2. Tombstone BitSet Not Thread-Safe** (`AbstractTable.java:175-186`)
Multiple threads can decrement `liveRowCount` for same row:
```java
// PROBLEM: Check-then-act without synchronization
if (!tombstones.get(index)) {
    tombstones.set(index);
    liveRowCount.decrementAndGet();  // Race condition!
}
```

**Impact**: Incorrect row count with concurrent deletes.

**3. Column Writes Not Atomic** (`PageColumn*.java:79-84`)
No atomicity between `data[]` and `present[]` writes:
```java
// PROBLEM: Two-step write without coordination
data[offset] = value;
present[offset] = 1;  // Reader sees null or value + present=false
```

**Impact**: Readers can see torn or partially-written state.

**4. SeqLock Not Actually Implemented** (`GeneratedTable.java:51-53`)
Interface promises seqlock but no version field exists.

**Impact**: Design gap, documented but not implemented.

### Current Concurrency Workarounds

For applications requiring concurrent saves/deletes:

```java
// Option 1: Synchronize on repository
synchronized (repository) {
    repository.save(entity);
}

// Option 2: Use single writer thread
ExecutorService singleWriter = Executors.newSingleThreadExecutor();
singleWriter.submit(() -> repository.save(entity));

// Option 3: Partition repositories by entity type
Map<Class<?>, Repository<?>> repositories = new ConcurrentHashMap<>();
repositories.computeIfAbsent(entity.getClass(), k -> new Repository<T>());
```

---

## Concurrency Improvement Roadmap

### Priority 1: Fix Critical Issues (Correctness)

**1.1 Fix Free-List Race Condition**
**Algorithm**: Lock-free stack or striped locking
**Complexity**: HIGH (lock-free) or MEDIUM (striped)
**Expected Improvement**: Eliminates data corruption
**Implementation**: Replace `int[] freeList` with `ConcurrentLinkedQueue` or striped locks

**1.2 Fix Tombstone BitSet Concurrency**
**Algorithm**: Striped locking or AtomicLongArray
**Complexity**: LOW
**Expected Improvement**: Correct concurrent deletes
**Implementation**: Replace `BitSet tombstones` with striped `AtomicBooleanArray`

**1.3 Fix Column Write Atomicity**
**Algorithm**: SeqLock (Sequence Lock) per row
**Complexity**: MEDIUM
**Expected Improvement**: 2-3x read throughput under concurrent updates
**Implementation**: Add `AtomicLong[] rowSeqLocks` and follow seqlock protocol

### Priority 2: Performance Improvements

**2.1 Stripe-Based Index Updates**
**Algorithm**: Partition `MutableRowIdSet` by hash stripes
**Complexity**: LOW
**Expected Improvement**: 4-8x index update throughput
**Implementation**: Add striped locking to `MutableRowIdSet` implementations

**2.2 Optimistic Locking for Updates**
**Algorithm**: CAS-based versioning with retry loops
**Complexity**: LOW
**Expected Improvement**: 2x throughput for low-contention updates
**Implementation**: Add version CAS to update operations

**2.3 Lock-Free Free-List**
**Algorithm**: CAS-based lock-free stack
**Complexity**: VERY HIGH
**Expected Improvement**: 5-10x row allocation throughput
**Implementation**: Replace with `AtomicReferenceArray` or Michael-Scott queue

### Priority 3: Advanced Features

**3.1 MVCC for Snapshot Isolation**
**Algorithm**: Per-row version chains with timestamp-based snapshots
**Complexity**: HIGH
**Expected Improvement**: 3-5x read throughput, snapshot consistency
**Implementation**: Extend row storage with version tracking and GC

**3.2 Pessimistic Locking API**
**Algorithm**: Striped ReadWriteLock with timeout
**Complexity**: MEDIUM
**Expected Improvement**: Predictable high-contention behavior
**Implementation**: Add `@Lock` annotation support and lock manager

**3.3 Concurrent Hash Join**
**Algorithm**: Radix-partitioned parallel join
**Complexity**: VERY HIGH
**Expected Improvement**: Near-linear scaling with CPU cores
**Implementation**: New join executor for @OneToMany/@ManyToMany support

---

## Well-Known Concurrency Algorithms

### SeqLock (Sequence Lock)

**Description**: Version-based read optimization where readers check version before/after reads and retry if changed.

**How It Works:**
- Writer: Increment version (odd), write, increment version (even)
- Reader: Read version, read data, read version again
- If versions differ or version is odd, retry

**Best Use Case**: Read-mostly workloads with infrequent writes.

**Pros**: Wait-free reads, simple to implement.
**Cons**: Writer can starve readers, read amplification.

**Expected Improvement**: 2-3x read throughput under concurrent single-row updates.

### Optimistic Locking

**Description**: Writers assume no conflicts, detect via CAS, retry on failure.

**How It Works:**
- Each row has a version number
- Read: Capture current version
- Write: CAS version with value increment
- If CAS fails, retry entire operation

**Best Use Case**: Low-contention workloads where conflicts are rare.

**Pros**: No locking overhead in happy path, no deadlocks.
**Cons**: Retry storms at high contention, not suitable for write-heavy workloads.

**Expected Improvement**: 2x throughput for low-contention updates.

### Striped Locking

**Description**: Partition data into independent stripes, each with its own lock.

**How It Works:**
- Hash key to determine stripe
- Each stripe has independent lock
- Operations only lock relevant stripe

**Best Use Case**: Hash-based structures with high-frequency operations.

**Pros**: Reduces contention by factor of stripes, simple to understand.
**Cons**: Can have hot stripes, not suitable for range queries.

**Expected Improvement**: 4-8x throughput for concurrent index updates.

### MVCC (Multi-Version Concurrency Control)

**Description**: Maintain multiple versions of each row for snapshot isolation.

**How It Works:**
- Each write creates new row version with timestamp
- Readers track their snapshot timestamp
- Old versions garbage-collected after readers complete

**Best Use Case**: Read-heavy workloads requiring snapshot isolation.

**Pros**: Readers never block, snapshot isolation, no deadlocks.
**Cons**: Memory overhead for old versions, complex garbage collection.

**Expected Improvement**: 3-5x read throughput, snapshot consistency.

### Lock-Free Data Structures

**Description**: Use atomic operations (CAS) for lock-free concurrent access.

**How It Works:**
- Use `AtomicReference`, `AtomicInteger`, `AtomicLong`
- CAS loops for updates
- Wait-free reads or lock-free updates

**Best Use Case**: Hot-path operations, high-frequency updates.

**Pros**: No lock overhead, high throughput, no deadlocks.
**Cons**: Very complex to implement correctly, ABA problem, memory reclamation issues.

**Expected Improvement**: 5-10x throughput for hot-path operations.

---

## Implementation Examples

### Example 1: Striped Locking for Free-List

```java
class StripedFreeList {
    private final ReadWriteLock[] locks;
    private final int[] freeList;
    private final AtomicInteger freeListTop = new AtomicInteger(-1);
    private final int stripes;

    public StripedFreeList(int capacity, int stripes) {
        this.stripes = stripes;
        this.locks = new ReadWriteLock[stripes];
        this.freeList = new int[capacity];
        for (int i = 0; i < stripes; i++) {
            locks[i] = new ReentrantReadWriteLock();
        }
    }

    private int stripeFor(int rowIndex) {
        return rowIndex % stripes;
    }

    public void push(int rowId) {
        int stripe = stripeFor(rowId);
        locks[stripe].writeLock().lock();
        try {
            int top = freeListTop.getAndIncrement();
            freeList[top + 1] = rowId;
        } finally {
            locks[stripe].writeLock().unlock();
        }
    }

    public int pop() {
        int stripe = stripeFor(freeListTop.get());
        locks[stripe].writeLock().lock();
        try {
            int top = freeListTop.get();
            if (top < 0) return -1;
            freeListTop.decrementAndGet();
            return freeList[top + 1];
        } finally {
            locks[stripe].writeLock().unlock();
        }
    }
}
```

### Example 2: SeqLock for Row Updates

```java
class SeqLockRow {
    private final AtomicLong version = new AtomicLong(0);
    private final Object[] columns;

    public void write(Object[] newValues) {
        version.getAndIncrement();  // Make odd
        try {
            // Write all columns
            System.arraycopy(newValues, 0, columns, 0, columns.length);
        } finally {
            version.incrementAndGet();  // Make even
        }
    }

    public Object[] read() {
        long v1 = version.get();
        if ((v1 & 1) == 1) return read();  // Writing, retry

        Object[] copy = new Object[columns.length];
        System.arraycopy(columns, 0, copy, 0, columns.length);

        long v2 = version.get();
        if (v1 != v2) return read();  // Changed, retry
        return copy;
    }
}
```

### Example 3: Optimistic Update

```java
class OptimisticRow {
    private final AtomicLong version = new AtomicLong(0);
    private final Object[] columns;

    public boolean update(int columnIndex, Object newValue, long expectedVersion) {
        long oldVersion = version.get();
        if (oldVersion != expectedVersion) return false;

        columns[columnIndex] = newValue;
        return version.compareAndSet(oldVersion, oldVersion + 1);
    }

    public long readVersion() {
        return version.get();
    }
}
```

---

## Performance Impact

| Improvement | Complexity | Expected Throughput Gain | Priority |
|-------------|-----------|-------------------------|----------|
| **Fix free-list race** | HIGH | Correctness only | **CRITICAL** |
| **Striped tombstones** | LOW | Correctness only | **CRITICAL** |
| **SeqLock rows** | MEDIUM | 2-3x | **HIGH** |
| **Striped indexes** | LOW | 4-8x | **HIGH** |
| **Optimistic locking** | LOW | 2x | **MEDIUM** |
| **Pessimistic API** | MEDIUM | Predictable | **MEDIUM** |
| **MVCC** | HIGH | 3-5x | **LOW** |
| **Lock-free free-list** | VERY HIGH | 5-10x | **LOW** |
| **Concurrent join** | VERY HIGH | Near-linear scaling | **LOW** |

---

## See Also

- [ROADMAP.md](ROADMAP.md) - Future feature roadmap including FFM
- [ARCHITECTURE.md](ARCHITECTURE.md) - Overall architecture
- [SPRING_DATA.md](SPRING_DATA.md) - Spring Data integration
```

---

### 7. docs/ROADMAP.md (CREATE NEW)

```markdown
# Roadmap

## Future Features

### Phase 1: Concurrency Improvements (Short-Term)

**1.1 Fix Critical Concurrency Issues** [Priority: CRITICAL]
- Fix free-list race condition (data corruption)
- Fix tombstone BitSet concurrency
- Implement seqlock for row updates
- Expected: Correct concurrent operations

**1.2 Performance Optimizations** [Priority: HIGH]
- Stripe-based index updates (4-8x throughput)
- Optimistic locking for updates (2x throughput)
- Lock-free data structures (5-10x throughput)
- Expected: Significantly improved concurrent access

### Phase 2: Advanced Concurrency (Medium-Term)

**2.1 Snapshot Isolation** [Priority: MEDIUM]
- MVCC implementation for snapshot queries
- Per-row version chains
- Background version garbage collection
- Expected: 3-5x read throughput, snapshot consistency

**2.2 Transaction Support** [Priority: MEDIUM]
- ACID transaction primitives
- Begin/commit/rollback API
- Optimistic concurrency control
- Expected: Data consistency guarantees

### Phase 3: Relationship Features (Medium-Term)

**3.1 @OneToMany Support** [Priority: HIGH]
- Bidirectional relationships
- Collection field mapping
- Cascade operations
- Expected: Full relationship support

**3.2 @ManyToMany Support** [Priority: MEDIUM]
- Join table generation
- Many-to-many relationship mapping
- Optimized join execution
- Expected: Many-to-many queries

### Phase 4: Storage Evolution (Long-Term)

**4.1 FFM Off-Heap Storage** [Priority: LOW]
- Off-heap storage using Java Foreign Function & Memory API
- Reduced GC pressure for large datasets
- Direct memory control
- Memory-mapped file persistence
- Expected: Better performance for large datasets

**4.2 SIMD Vectorization** [Priority: LOW]
- Java Vector API integration
- Parallel scan operations
- SIMD-optimized comparisons
- Expected: 2-4x scan throughput

### Phase 5: Enterprise Features (Long-Term)

**5.1 Schema Evolution** [Priority: LOW]
- Online schema changes
- Migration support
- Backward compatibility
- Expected: Zero-downtime schema updates

**5.2 Distributed Storage** [Priority: LOW]
- Partitioned tables
- Distributed queries
- Replication
- Expected: Horizontal scalability

---

## Status Legend

| Status | Meaning |
|---------|----------|
| âœ… Implemented | Feature is complete and tested |
| ðŸš§ In Progress | Feature is currently being developed |
| â³ Planned | Feature is planned but not started |
| ðŸ“‹ Proposed | Feature is proposed for consideration |
| âŒ Blocked | Feature has known blockers |

---

## See Also

- [CONCURRENCY.md](CONCURRENCY.md) - Current concurrency model and improvements
- [ARCHITECTURE.md](ARCHITECTURE.md) - Current architecture
- [SPRING_DATA.md](SPRING_DATA.md) - Spring Data integration
```

---

### 8. README.md

**Add FFM as Roadmap Item:**
Add after line 17 (in "Quick Start" section):
```markdown
**Storage**: 100% heap-based using primitive arrays (int[], long[], String[])
**Future**: FFM off-heap storage planned for large datasets (see [docs/ROADMAP.md](docs/ROADMAP.md))
```

**Remove SIMD References:**
Line 77:
```markdown
- **PageColumnInt**: int[] with direct array scans
```

---

### 9. docs/DEVELOPMENT.md

**Remove SIMD Reference:**
Line 45:
```markdown
- SIMD not implemented; plain loops used (JIT may auto-vectorize)
```

**Add Concurrency Guidelines:**
Add after line 100:
```markdown
## Concurrency Guidelines

### Current Concurrency Model

- **Multi-reader**: Thread-safe concurrent queries
- **Single-writer**: External synchronization required for concurrent saves
- **Read-write**: No coordination, potential inconsistency

### When to Use External Synchronization

Use external synchronization (synchronized, locks) when:
1. Multiple threads save entities concurrently
2. Multiple threads delete entities concurrently
3. Read-write coordination is required

### Best Practices

1. Prefer query-only workloads (thread-safe)
2. Use single-writer thread pattern for writes
3. Partition repositories by entity type for isolation
4. Avoid concurrent saves to same table

See [CONCURRENCY.md](CONCURRENCY.md) for detailed concurrency model and improvement roadmap.
```

---

### 10. docs/IMPLEMENTATION.md (CREATE NEW)

```markdown
# Implementation Status

## Implemented Features

### Core Storage
- âœ… 100% heap-based storage (int[], long[], String[])
- âœ… ByteBuddy table generation (DEFAULT, ~1ns overhead)
- âœ… MethodHandle fallback (~5ns overhead)
- âœ… HashIndex (O(1)) lookups
- âœ… RangeIndex (O(log n)) range queries via ConcurrentSkipListMap
- âœ… LongIdIndex and StringIdIndex

### Query Support
- âœ… All comparison operators (EQ, NE, GT, GTE, LT, LTE, BETWEEN)
- âœ… String operators (LIKE, NOT_LIKE, STARTING_WITH, ENDING_WITH, CONTAINING)
- âœ… Boolean operators (IS_TRUE, IS_FALSE)
- âœ… Null operators (IS_NULL, IS_NOT_NULL)
- âœ… Collection operators (IN, NOT_IN)
- âœ… Logical operators (AND, OR)
- âœ… OrderBy sorting
- âœ… Top/First limiting
- âœ… @Query with JPQL-like syntax (limited)

### Relationships
- âœ… @OneToOne (FULLY IMPLEMENTED)
- âœ… @ManyToOne (FULLY IMPLEMENTED)
- âŒ @OneToMany (NOT IMPLEMENTED)
- âŒ @ManyToMany (NOT IMPLEMENTED)

### Annotations
- âœ… @Entity
- âœ… @Index (HASH type)
- âœ… @GeneratedValue (AUTO, IDENTITY, UUID, CUSTOM)
- âœ… @OneToOne
- âœ… @ManyToOne
- âœ… @JoinColumn
- âœ… @Query
- âœ… @Param

## Not Implemented

### Relationships
- @OneToMany and @ManyToMany relationships
- Cascade delete / orphan removal
- Cascade operations on @OneToOne relationships

### Query Features
- DISTINCT query modifier (tokenized, execution incomplete)

### Enterprise Features
- @Embeddable components
- @Enumerated types
- Lifecycle callbacks (@PrePersist, @PostLoad, @PreUpdate, @PostUpdate)
- Inheritance hierarchies
- Composite keys
- Transaction support
- Schema evolution

### Performance Optimizations
- SIMD/Vector API (plain loops used)
- MVCC for snapshot isolation
- Optimistic concurrency control

## Future Roadmap

See [ROADMAP.md](ROADMAP.md) for detailed roadmap including:
- Concurrency improvements
- FFM off-heap storage
- Advanced relationship support
- Enterprise features

## Performance Characteristics

| Operation | Complexity | Implementation |
|-----------|------------|----------------|
| HashIndex lookup | O(1) | ConcurrentHashMap |
| RangeIndex lookup | O(log n) | ConcurrentSkipListMap |
| Table scan | O(n) | Direct array iteration |
| Bytecode field access | ~1ns | Direct bytecode generation |
| MethodHandle field access | ~5ns | Pre-compiled MethodHandle |
| TypeCode dispatch | O(1) | tableswitch bytecode |

## Concurrency Characteristics

| Operation | Thread-Safety | Mechanism |
|-----------|--------------|------------|
| ID generation | âœ… | AtomicLong |
| Query reads | âœ… | Volatile published |
| Index lookups | âœ… | ConcurrentHashMap / ConcurrentSkipListMap |
| Entity saves | âŒ | External sync required |
| Entity deletes | âŒ | External sync required |

See [CONCURRENCY.md](CONCURRENCY.md) for detailed concurrency analysis and improvement opportunities.
```

---

### 11. Archive tmp/test-that-need-attention.md

Create `docs/archive/ffm-migration-audit.md`:
```markdown
# Archive: FFM Storage Test Audit (Historical)

**Status**: ARCHIVED - FFM was removed in commit 04df166 (Jan 28, 2026)

This document cataloged FFM-dependent tests that needed migration to heap storage.

## Migration Summary

- âœ… All FFM code removed (14,248 deletions)
- âœ… Heap-based storage implemented (3,886 insertions)
- âœ… 100% heap storage (int[], long[], String[])

## Current Implementation

- âœ… 100% heap-based storage
- âœ… RangeIndex implemented (ConcurrentSkipListMap)
- âœ… Bytecode implementation default
- âœ… @OneToOne and @ManyToOne relationships

## Future Roadmap

FFM off-heap storage is planned for future large dataset scenarios. See [ROADMAP.md](../../ROADMAP.md).

**Note**: This document is kept for historical reference only.
```

---

## Implementation Order

### Phase 1: Critical Documentation (Priority 1)
1. Update `docs/ARCHITECTURE.md` - FFM roadmap, concurrency model, RangeIndex
2. Create `docs/CONCURRENCY.md` - comprehensive concurrency documentation
3. Create `docs/ROADMAP.md` - future feature roadmap
4. Update `docs/SPRING_DATA.md` - concurrency notes, package structure
5. Update `CLAUDE.md` - FFM roadmap, concurrency model

### Phase 2: Accuracy Fixes (Priority 2)
6. Update `docs/examples/ecommerce-domain.md` - remove non-existent features
7. Update `docs/QUERY.md` - package references
8. Update `README.md` - FFM as roadmap item
9. Update `docs/DEVELOPMENT.md` - remove SIMD, add concurrency guidelines
10. Create `docs/IMPLEMENTATION.md` - implementation status

### Phase 3: Archive (Priority 3)
11. Archive `tmp/test-that-need-attention.md` to `docs/archive/`

---

## Verification Strategy

After completing all updates:

1. **Verify FFM documented as roadmap:**
   ```bash
   rg -i "FFM|Foreign Function|MemorySegment" docs/ --md
   # Should find references only in ROADMAP.md or as future plans
   ```

2. **Verify concurrency documented:**
   ```bash
   rg "concurrency|thread-safe|concurrent" docs/ --md
   # Should find comprehensive coverage in CONCURRENCY.md
   ```

3. **Verify package structure:**
   ```bash
   rg "io\.memris\.spring\." docs/ --md
   # Should only find in archived docs
   ```

4. **Verify relationship accuracy:**
   ```bash
   rg "@OneToMany|@ManyToMany" docs/ --md
   # Should only mention they're NOT implemented
   ```

5. **Run all tests:**
   ```bash
   mvn.cmd -q -e -pl memris-core test
   ```

6. **Verify code examples:**
   - All code blocks in docs should be valid
   - Import statements should match actual package structure
   - Concurrency examples should be accurate

---

## Summary

- **10 files to update**
- **3 new files to create** (CONCURRENCY.md, ROADMAP.md, IMPLEMENTATION.md)
- **1 file to archive**
- **~120 specific text replacements/additions**
- **Comprehensive concurrency documentation** with well-known algorithms
- **FFM documented as future roadmap** (not removed)
- **Clear statement of what IS vs IS NOT implemented**
- **Concurrency improvement roadmap** with priorities and expected gains
