# Plan: Restructure Packages - Remove Misleading "spring" Name

## Problem
The `io.memris.spring` package name is misleading because:
- Memris core has **zero dependencies** on Spring Framework
- The code implements a Spring Data-like *pattern*, but is not tied to Spring
- Suggests tight coupling that doesn't exist
- Should be loosely coupled, framework-agnostic core

## Goal
Restructure packages to reflect actual architecture:
- `io.memris.core` - Core engine (annotations, metadata, config, types)
- `io.memris.runtime` - Query execution engine  
- `io.memris.query` - Query planning and parsing
- `io.memris.repository` - Repository pattern (Spring Data-like interface)
- `io.memris.storage` - Already correct (storage layer)

## New Package Structure

### Phase 1: Core Package (was io.memris.spring)

**New Package:** `io.memris.core`

**Files to move:**
- `TypeCodes.java` - Core type constants
- `EntityMetadata.java` - Entity metadata (framework-agnostic)
- `MetadataExtractor.java` - Metadata extraction
- `MemrisConfiguration.java` - Engine configuration
- `MemrisArena.java` - Memory management
- `MemrisException.java` - Base exception
- All annotations: `Entity.java`, `Index.java`, `GeneratedValue.java`, `OneToOne.java`, etc.

**Files to keep in `io.memris.data` (repository pattern):**
- `MemrisRepository.java` - Repository marker interface
- `MemrisRepositoryFactory.java` - Repository factory

### Phase 2: Runtime Package (was io.memris.spring.runtime)

**New Package:** `io.memris.runtime`

**Files to move:**
- `HeapRuntimeKernel.java` - Core query execution
- `RepositoryRuntime.java` → `QueryRuntime.java` (rename)
- `RepositoryPlan.java` → `QueryPlan.java` (rename)
- `EntityMaterializer.java` + `EntityMaterializerImpl.java`
- `EntityMaterializerGenerator.java`
- `EntitySaver.java`
- `JoinExecutor.java` + `JoinExecutorImpl.java`
- `JoinMaterializer.java` + `JoinMaterializerImpl.java`
- `TypeHandler.java`, `TypeHandlerRegistry.java`, `AbstractTypeHandler.java`
- All handlers in `runtime/handlers/` → `runtime/handler/`

### Phase 3: Query Package (was io.memris.spring.plan)

**New Package:** `io.memris.query`

**Files to move:**
- `QueryPlanner.java`
- `QueryCompiler.java`
- `CompiledQuery.java`
- `LogicalQuery.java`
- `QueryMethodLexer.java`
- `BuiltInResolver.java`
- `OpCode.java`
- Subpackages:
  - `plan/jpql/` → `query/jpql/`

### Phase 4: Repository Package (was io.memris.spring.scaffold)

**New Package:** `io.memris.repository`

**Files to move:**
- `RepositoryEmitter.java` → `RepositoryFactory.java` (rename)
- `RepositoryMethodIntrospector.java`
- `EntitySaverGenerator.java` → move to `io.memris.core.codegen`?

### Phase 5: Converter and Util

**New Packages:**
- `io.memris.core.converter` (was spring.converter)
- `io.memris.util` (was spring.util)

## Implementation Steps

### Step 1: Create New Packages and Move Files

For each file:
1. Create new file in correct package
2. Update package declaration
3. Update all imports
4. Update references in other files
5. Delete old file

### Step 2: Update Imports in All Files

Files that import from `io.memris.spring.*` need updating:
- All test files
- All main source files with imports
- Update CLAUDE.md if it references specific packages

### Step 3: Rename Classes

- `RepositoryRuntime` → `QueryRuntime`
- `RepositoryPlan` → `QueryPlan`
- `RepositoryEmitter` → `RepositoryFactory` (but might conflict with existing)

Actually, keep names but change packages:
- `io.memris.runtime.RepositoryRuntime` (clear it's runtime)
- `io.memris.query.QueryPlanner` (clear it's query planning)

### Step 4: Update Tests

All test files need package updates:
- Update package declarations
- Update imports
- Ensure tests still run

## File Mapping

| Current | New |
|---------|-----|
| `io.memris.spring.TypeCodes` | `io.memris.core.TypeCodes` |
| `io.memris.spring.EntityMetadata` | `io.memris.core.EntityMetadata` |
| `io.memris.spring.MemrisConfiguration` | `io.memris.core.MemrisConfiguration` |
| `io.memris.spring.MemrisRepository` | `io.memris.data.MemrisRepository` |
| `io.memris.spring.MemrisRepositoryFactory` | `io.memris.data.MemrisRepositoryFactory` |
| `io.memris.spring.runtime.*` | `io.memris.runtime.*` |
| `io.memris.spring.plan.*` | `io.memris.query.*` |
| `io.memris.spring.scaffold.*` | `io.memris.repository.*` |
| `io.memris.spring.converter.*` | `io.memris.core.converter.*` |
| `io.memris.spring.util.*` | `io.memris.util.*` |

## Benefits

1. **Honest naming** - No false Spring association
2. **Clear architecture** - Core vs Repository pattern separation
3. **Framework agnostic** - Core can be used without repository pattern
4. **Better organization** - Runtime, query, storage layers clearly separated

## Verification

```bash
# Verify no files in old packages
find memris-core/src/main/java/io/memris/spring -type f
# Should return nothing after migration

# Run all tests
mvn.cmd -q -e -pl memris-core test

# Verify compilation
mvn.cmd -q -e compile
```

## Commits

1. `refactor: move core classes from spring to core package`
2. `refactor: move runtime classes from spring.runtime to runtime package`
3. `refactor: move query classes from spring.plan to query package`
4. `refactor: move repository classes from spring.scaffold to repository package`
5. `refactor: move converter and util to appropriate packages`
6. `refactor: update all imports and references`

## Note on Compatibility

This is a **breaking change** for any external code using Memris. But since this is an in-memory library likely used internally, the benefits outweigh the costs.

Alternative: Keep old packages as deprecated aliases for one release:
```java
// In old location, just re-export
package io.memris.spring;
@Deprecated
public class TypeCodes extends io.memris.core.TypeCodes {}
```

But this adds maintenance burden. Better to do clean rename now while user base is small.
