# RowIdSet Full-Performance Rollout Plan

## Goal
- Implement the full performance design now:
  - `RowIdArraySet` -> `StampedLock` with optimistic reads and in-place writes.
  - `RowIdBitSet` -> chunked CAS design to remove full-array clone hot spots.
- Preserve correctness under concurrent index reads/writes (`HashIndex`, `StringPrefixIndex`).
- Keep hot paths primitive-only and core framework-agnostic.

## Fixed Semantic Decisions (for implementation + tests)
- `MutableRowIdSet` is a **set** (no duplicates): `add` is idempotent.
- `remove` is idempotent (no-op when value absent).
- `size()` is unique-cardinality.
- `enumerator()` is snapshot-at-creation and never fails due to concurrent mutation.
- Iteration order is unspecified API-wise.

## Files to Modify

### Kernel
- `memris-core/src/main/java/io/memris/kernel/RowIdArraySet.java`
- `memris-core/src/main/java/io/memris/kernel/RowIdBitSet.java`
- `memris-core/src/main/java/io/memris/kernel/RowIdSetFactory.java`
- `memris-core/src/main/java/io/memris/kernel/RowIdSet.java` (contract docs)
- `memris-core/src/main/java/io/memris/kernel/MutableRowIdSet.java` (contract docs)

### Index touchpoints (only if required by semantic shifts)
- `memris-core/src/main/java/io/memris/index/HashIndex.java`
- `memris-core/src/main/java/io/memris/index/StringPrefixIndex.java`

### Tests
- `memris-core/src/test/java/io/memris/kernel/RowIdSetFactoryTest.java` (expand)
- `memris-core/src/test/java/io/memris/kernel/RowIdArraySetTest.java` (new)
- `memris-core/src/test/java/io/memris/kernel/RowIdBitSetTest.java` (new)
- `memris-core/src/test/java/io/memris/index/HashIndexTest.java` (extend)
- `memris-core/src/test/java/io/memris/index/StringPatternIndexTest.java` (extend where relevant)

## Implementation Steps

1) **Lock in contracts first**
- Update `RowIdSet`/`MutableRowIdSet` docs so behavior is explicit and testable.

2) **Refactor `RowIdArraySet` to optimistic-read design**
- Replace `synchronized` methods with `StampedLock`.
- Writes (`add/remove`) mutate in place under write lock.
- Reads (`size/contains/toLongArray`) use optimistic read + fallback read lock.
- Keep enumerator snapshot semantics by iterating a snapshot array.
- Enforce set semantics (dedupe in `add`).

3) **Implement chunked CAS `RowIdBitSet`**
- Replace single-state full-clone CAS with chunked storage and per-chunk CAS updates.
- Ensure chunk growth/initialization is CAS-safe.
- Keep `contains/size/enumerator/toLongArray` lock-free or read-optimized.
- Preserve `Integer.MAX_VALUE` rowId bound (aligned with existing runtime int casts).

4) **Update factory upgrade path**
- Keep threshold policy.
- Ensure `maybeUpgrade` works with new set semantics and does not depend on brittle assumptions.
- Confirm no regression in one-way array->bitset upgrade behavior.

5) **Index integration validation**
- Verify `HashIndex` and `StringPrefixIndex` logic remains correct with dedupe semantics:
  - empty-set cleanup,
  - filter paths,
  - no stale entries after remove.

6) **Add/extend tests for correctness + concurrency**
- Add focused kernel tests for:
  - idempotent `add/remove`,
  - cardinality invariants,
  - snapshot enumerator behavior during concurrent writes,
  - boundary row ids (`63/64/65`, high row ids).
- Extend index tests for same-key churn and upgrade scenarios.
- Keep test style constraints (single AssertJ assertion per test).

7) **Benchmark and baseline comparison (reduced, memory-safe)**
- Run a reduced JMH suite with constrained heap to avoid page-file crashes.
- Save JSON for current branch and baseline commit, then compare percent deltas.

## Verification

### Correctness
- `mvn.cmd -q -e -pl memris-core test -Dtest=RowIdArraySetTest,RowIdBitSetTest,RowIdSetFactoryTest`
- `mvn.cmd -q -e -pl memris-core test -Dtest=HashIndexTest,StringPatternIndexTest`
- `mvn.cmd -q -e -pl memris-core test`
- `mvn.cmd -q -e test`

### JMH (current + baseline)
- Current commit (reduced suite, memory-capped):
  - `mvn.cmd -pl memris-core -DskipTests jmh:benchmark -Djmh.benchmarks=io.memris.benchmarks.PatternMatchingBenchmark -Djmh.p.rowCount=10000,50000 -Djmh.p.useIndex=true,false -Djmh.wi=1 -Djmh.i=3 -Djmh.r=1s -Djmh.rf=json -Djmh.rff=target/jmh-current.json -Djmh.jvmArgs=-Xms256m -Djmh.jvmArgsAppend=-Xmx512m`
- Baseline commit (same exact command, output `target/jmh-baseline.json`).
- Compare JSON means for matching benchmark+params and report percent deltas.

## Risks and Mitigations
- **Semantic shift risk (duplicates removed):** lock behavior with explicit tests before/with refactor.
- **Chunked complexity risk:** keep implementation bounded to existing interfaces; avoid unrelated refactors.
- **Benchmark environment fragility (Windows page file):** reduced benchmark set + capped heap + JSON outputs.
- **Regression blast radius:** validate kernel tests first, then index tests, then full reactor.
