# Concurrency Audit Plan

## Goal
Audit the current concurrency model end-to-end, reconcile docs vs. code guarantees, and identify any correctness gaps before proposing targeted fixes or tests.

## Plan
1) Align the documented contract with the code reality
   - Compare `docs/CONCURRENCY.md`, `README.md`, `docs/DEVELOPMENT.md`, and `docs/design/storage.md` for consistency (multi-writer vs single-writer, publish protocol, eventual index consistency).
   - Produce a short contract summary listing: safe operations, caveats, and required external synchronization.

2) Trace row lifecycle and publish protocol
   - Follow `allocateRowId` -> `insertFrom` -> `publish` -> `tombstone` -> free-list reuse.
   - Validate seqlock usage and ordering in `AbstractTable` and `MethodHandleImplementation` (write under seqlock, publish after write, read retries on version change).
   - Check row generation updates for visibility and stale reference rejection.

3) Validate read paths and scan paths
   - Confirm `readWithSeqLock` is used for typed reads and presence checks (GeneratedTable read/Present interceptors).
   - Confirm scans only consider published rows and are filtered for tombstones.
   - Flag any read path that can observe unpublished or partially written data.

4) Audit index correctness under concurrency
   - Review `HashIndex` and `RangeIndex` map operations and thread safety of `MutableRowIdSet` implementations.
   - Verify query-time validation in `RepositoryRuntime` (`selectionFromRows` + `isLive`) correctly filters stale index entries.
   - Confirm delete/update ordering doesn't create false positives or lost entries.

5) Inspect allocation/reuse safety
   - Validate `LockFreeFreeList` behavior and interaction with tombstones + generations.
   - Check for any row reuse race with concurrent reads, especially around generation changes.

6) Consolidate findings into an audit report
   - List proven-safe paths, potential hazards, and any doc/code mismatches.
   - If issues are found, propose minimal fixes and targeted tests (no speculative refactors).

## Critical Files (audit scope)
- `docs/CONCURRENCY.md`
- `README.md`
- `docs/DEVELOPMENT.md`
- `docs/design/storage.md`
- `memris-core/src/main/java/io/memris/storage/heap/AbstractTable.java`
- `memris-core/src/main/java/io/memris/storage/heap/MethodHandleImplementation.java`
- `memris-core/src/main/java/io/memris/storage/GeneratedTable.java`
- `memris-core/src/main/java/io/memris/storage/heap/LockFreeFreeList.java`
- `memris-core/src/main/java/io/memris/storage/heap/PageColumnInt.java`
- `memris-core/src/main/java/io/memris/storage/heap/PageColumnLong.java`
- `memris-core/src/main/java/io/memris/storage/heap/PageColumnString.java`
- `memris-core/src/main/java/io/memris/index/HashIndex.java`
- `memris-core/src/main/java/io/memris/index/RangeIndex.java`
- `memris-core/src/main/java/io/memris/runtime/RepositoryRuntime.java`
- `memris-core/src/main/java/io/memris/kernel/MutableRowIdSet.java`
- `memris-core/src/main/java/io/memris/kernel/RowIdSetFactory.java`
- `memris-core/src/main/java/io/memris/kernel/RowIdSets.java`

## Verification
- Run existing concurrency tests:
  - `mvn.cmd -q -e -pl memris-core test`
- If gaps are found, add focused concurrency tests in `memris-core/src/test/java/io/memris/storage/heap/` and `memris-core/src/test/java/io/memris/runtime/` to validate the corrected behavior.
