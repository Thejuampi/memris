# Plan: JMH Baseline for Save/Update/Delete (Single + Multi-Thread)

## Scope
- Add a JMH benchmark in `memris-core/src/jmh/java` using `TestEntityRepository`.
- Measure mixed save/update/delete throughput at scale (millions of ops).
- Provide single-thread and multi-thread variants with thread-safe ID partitioning.
- Run baseline with 1/2/4/8 threads and record results in `docs/DEVELOPMENT.md`.

## Design Overview
- Use JMH `@State(Scope.Benchmark)` for shared Memris arena/repository.
- Use `@State(Scope.Thread)` for thread-local ID pools to avoid contention and align with concurrency guidance.
- Implement a mixed workload loop per invocation with configurable percentages.
- Parameterize dataset size and ops-per-invocation; rely on JMH `-t` for thread counts (1/2/4/8).

## Implementation Steps
1. **Benchmark class**
   - Add `memris-core/src/jmh/java/io/memris/benchmarks/TestEntityRepositoryBenchmark.java`.
   - Annotate with `@BenchmarkMode(Mode.Throughput)`, `@OutputTimeUnit(TimeUnit.SECONDS)`, reasonable `@Warmup`/`@Measurement`.

2. **Benchmark state setup**
   - `BenchmarkState` (Scope.Benchmark):
     - Fields: `MemrisRepositoryFactory`, `MemrisArena`, `TestEntityRepository`, `@Param` for `initialRows`, `opsPerInvocation`, `savePct`, `updatePct`, `deletePct`.
     - `@Setup(Level.Trial)`: create factory/arena/repo, prefill `initialRows` entities.
     - `@TearDown(Level.Trial)`: close factory.
   - `ThreadState` (Scope.Thread):
     - Thread-local id array/ring buffer and index.
     - `@Setup(Level.Iteration)`: seed per-thread ID pool from prefilled rows using thread index ranges.

3. **Workload logic**
   - Mixed loop: for `opsPerInvocation` iterations, choose action based on percentages.
   - Save: create new `TestEntity` with `id = null`, save, store returned id into thread-local pool.
   - Update: pick id from pool, save entity with same id + updated fields.
   - Delete: pick id from pool, `deleteById`, mark slot empty (skip updates on empty slots).
   - Keep distribution deterministic via thread-local RNG with fixed seed + thread index.
   - Use `@OperationsPerInvocation(opsPerInvocation)` to normalize throughput.

4. **Single vs multi-thread**
    - Provide one benchmark method; use JMH CLI `-t 1,2,4,8` for thread counts.
    - Document example commands (single-thread and multi-thread).

5. **Fix JMH plugin/deps**
    - Add `jmh.plugin.version=0.2.2` in parent `pom.xml` properties.
    - Use `pw.krejci:jmh-maven-plugin` with `${jmh.plugin.version}` in parent pluginManagement.
    - Ensure `jmh-core` stays as test-scope dependency in `memris-core`.

6. **Capture baseline results**
    - Run the benchmark with default params at `-t 1,2,4,8`.
    - Record ops/sec and environment details in `docs/DEVELOPMENT.md` under Performance Validation.

## Files to Modify / Add
- `memris-core/src/jmh/java/io/memris/benchmarks/TestEntityRepositoryBenchmark.java`
- `docs/DEVELOPMENT.md` (add baseline results table + run instructions)
- `pom.xml` and/or `memris-core/pom.xml` (JMH plugin coordinates)

## Verification
- Build JMH: `mvn.cmd -pl memris-core -DskipTests pw.krejci:jmh-maven-plugin:${jmh.plugin.version}:benchmark -Dbenchmark=TestEntityRepositoryBenchmark`
- Example runs:
  - Single thread: `... -Dthreads=1` or `-t 1`
  - Multi-thread: `... -Dthreads=8` or `-t 8`
- Ensure benchmark completes and reports ops/sec for the mixed workload.

## Notes
- Thread-local ID pools avoid cross-thread contention while still stressing multi-writer paths on the same table.
- Mixed workload is configurable to represent “millions saved/updated/deleted”.
