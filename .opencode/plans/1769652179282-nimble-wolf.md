# Implementation Plan: ECommerceRealWorldTest Implementation

## Current Status

### Completed ✅
- **ArenaFeatureTest**: 6/6 tests passing (ID generation bug fixed)
- **QueryCompiler**: Property path to column index resolution working
- **EntityMaterializerImpl**: Complete entity materialization from table rows
- **RepositoryRuntime.executeMethod()**: Full OpCode dispatch with SAVE_ONE, FIND_BY_ID, etc.
- **MemrisArena**: Repository lookup by entity class fixed
- **RepositoryEmitter**: Query compilation integrated

### Test Results
```
ArenaFeatureTest: 6/6 PASSING ✅
- shouldCreateArenaWithUniqueId
- shouldCreateRepositoryInArena
- shouldIsolateDataBetweenArenas
- shouldFindRepositoryByEntityClassInArena
- shouldDefaultToSharedArena
- shouldSupportCloseArena
```

## Goal

Create a working ECommerceRealWorldTest that demonstrates the Memris repository infrastructure with a realistic e-commerce domain model. The test should showcase:
- Entity relationships (simplified, without full join support)
- CRUD operations
- Query methods with various operators
- Index usage for performance

## What's Missing for Full E-Commerce

From `docs/examples/ecommerce-domain.md`, the following are **NOT YET IMPLEMENTED**:

| Feature | Status | Impact | Workaround |
|---------|--------|--------|------------|
| @ManyToOne relationships | ❌ | Cannot navigate Order->Customer | Store IDs as Long fields |
| @OneToMany relationships | ❌ | Cannot fetch Customer->Orders | Use separate queries |
| @ManyToMany relationships | ❌ | Cannot do Product<->Category many-to-many | Use join table entity |
| BigDecimal type | ❌ | Cannot store prices as BigDecimal | Use long (cents) |
| LocalDateTime type | ❌ | Cannot store timestamps | Use long (epoch millis) |
| Enum types | ❌ | Cannot use OrderStatus enum | Use String |
| @PrePersist callbacks | ❌ | Cannot auto-generate order numbers | Generate manually |
| Sorting (OrderBy) | ⚠️ | Parsed but not executed | Sort in memory after query |
| Pagination | ❌ | No Page<T> support | Use List with limits |

## Implementation Plan

### Phase 1: Create ECommerceRealWorldTest (P0)

**File:** `memris-core/src/test/java/io/memris/spring/ECommerceRealWorldTest.java`

**Entities to Create:**

1. **Customer** (simple entity)
```java
@Entity
public class Customer {
    @Id @GeneratedValue
    private Long id;
    
    @Index(type = Index.Type.HASH)
    private String email;
    
    private String firstName;
    private String lastName;
    private String phone;
    private long createdAt; // epoch millis instead of LocalDateTime
}
```

2. **Product** (simple entity)
```java
@Entity
public class Product {
    @Id @GeneratedValue
    private Long id;
    
    @Index(type = Index.Type.HASH)
    private String sku;
    
    private String name;
    private String description;
    private long priceCents; // BigDecimal workaround
    private int stockQuantity;
    private long categoryId; // Foreign key instead of @ManyToOne
}
```

3. **Order** (with foreign keys)
```java
@Entity
public class Order {
    @Id @GeneratedValue
    private Long id;
    
    private long customerId; // Foreign key
    private long orderDate; // epoch millis
    private String status; // String instead of enum
    private long totalCents;
}
```

4. **OrderItem** (join entity)
```java
@Entity
public class OrderItem {
    @Id @GeneratedValue
    private Long id;
    
    private long orderId; // Foreign key
    private long productId; // Foreign key
    private int quantity;
    private long unitPriceCents;
}
```

**Repository Interfaces:**

```java
public interface CustomerRepository extends MemrisRepository<Customer> {
    Optional<Customer> findByEmail(String email);
    List<Customer> findByFirstNameContainingIgnoreCase(String name);
    List<Customer> findByCreatedAtGreaterThan(long date);
    boolean existsByEmail(String email);
}

public interface ProductRepository extends MemrisRepository<Product> {
    Optional<Product> findBySku(String sku);
    List<Product> findByNameContaining(String keyword);
    List<Product> findByPriceCentsBetween(long min, long max);
    List<Product> findByStockQuantityGreaterThan(int quantity);
}

public interface OrderRepository extends MemrisRepository<Order> {
    List<Order> findByCustomerId(Long customerId);
    List<Order> findByCustomerIdAndStatus(Long customerId, String status);
    List<Order> findByOrderDateBetween(long start, long end);
    long countByStatus(String status);
}

public interface OrderItemRepository extends MemrisRepository<OrderItem> {
    List<OrderItem> findByOrderId(Long orderId);
    List<OrderItem> findByProductId(Long productId);
}
```

**Test Scenarios:**
1. Create customers and verify findByEmail
2. Create products and verify findBySku, findByPriceBetween
3. Create an order with items
4. Query orders by customer
5. Query order items by order
6. Verify data isolation between arenas

**Dependencies:** 
- All infrastructure already implemented and working

**Estimated Time:** 2-3 hours

---

### Phase 2: Add Missing Type Support (P1 - Future Enhancement)

**File:** `memris-core/src/main/java/io/memris/spring/TypeCodes.java`

Add support for:
```java
public static final byte TYPE_BIG_DECIMAL = 9;
public static final byte TYPE_LOCAL_DATE_TIME = 10;
public static final byte TYPE_ENUM = 11;
```

**File:** `memris-core/src/main/java/io/memris/spring/converter/TypeConverterRegistry.java`

Register converters for new types.

**File:** `memris-core/src/main/java/io/memris/spring/runtime/HeapRuntimeKernel.java`

Add scan methods for BigDecimal and Date types.

**Dependencies:** TypeConverter infrastructure
**Estimated Time:** 4-6 hours (for all three types)

---

### Phase 3: Implement Sorting (P1 - Future Enhancement)

**File:** `memris-core/src/main/java/io/memris/spring/runtime/RepositoryRuntime.java`

Add sorting support to find operations:
```java
private List<T> executeFind(CompiledQuery query, Object[] args) {
    Selection selection = executeConditions(query, args);
    
    // Get sort orders from query
    List<SortOrder> sortOrders = query.sortOrders();
    
    if (!sortOrders.isEmpty()) {
        // Materialize all entities
        List<T> results = materializeSelection(selection);
        
        // Sort in memory
        results.sort((a, b) -> {
            for (SortOrder order : sortOrders) {
                int comparison = compareEntities(a, b, order);
                if (comparison != 0) {
                    return order.isAscending() ? comparison : -comparison;
                }
            }
            return 0;
        });
        
        return results;
    }
    
    // No sorting needed
    return materializeSelection(selection);
}
```

**Dependencies:** None
**Estimated Time:** 2-3 hours

---

## Verification Strategy

### Test Commands

```bash
# Run ECommerceRealWorldTest
mvn.cmd -q -e -pl memris-core test -Dtest=ECommerceRealWorldTest

# Run all tests to ensure no regressions
mvn.cmd -q -e -pl memris-core test
```

### Expected Results

**ECommerceRealWorldTest:**
- ✅ shouldCreateCustomerWithEmail
- ✅ shouldFindCustomerByEmail
- ✅ shouldCreateProductWithSku
- ✅ shouldFindProductsByPriceRange
- ✅ shouldCreateOrderWithItems
- ✅ shouldFindOrdersByCustomer
- ✅ shouldFindOrderItemsByOrder
- ✅ shouldIsolateECommerceDataBetweenArenas

---

## Implementation Order

1. **Phase 1** - Create ECommerceRealWorldTest with simplified entities (no relationships)
2. **Phase 2** - Add BigDecimal/Date/Enum type support (optional)
3. **Phase 3** - Implement sorting (optional)

**Minimum Viable:** Phase 1 only (2-3 hours)
**Full Featured:** All phases (8-12 hours)

---

## Files to Create/Modify

| Phase | File | Type | Purpose |
|-------|------|------|---------|
| 1 | ECommerceRealWorldTest.java | Create | Integration test |
| 1 | Customer.java | Create | Test entity |
| 1 | Product.java | Create | Test entity |
| 1 | Order.java | Create | Test entity |
| 1 | OrderItem.java | Create | Test entity |
| 2 | TypeCodes.java | Modify | Add type codes |
| 2 | TypeConverterRegistry.java | Modify | Add converters |
| 3 | RepositoryRuntime.java | Modify | Add sorting |

---

## Risk Mitigation

**Risk 1: Test takes too long to write**
- Mitigation: Use simplified domain model without relationships
- Start with just Customer and Product entities

**Risk 2: Query methods don't work as expected**
- Mitigation: Test each query method individually before writing full test
- Use existing ArenaFeatureTest patterns

**Risk 3: Type conversions fail**
- Mitigation: Stick to supported types (Long, String, int, long)
- Don't use BigDecimal, LocalDateTime, or enums in Phase 1
