# Plan: Refactor ScanInterceptor to Direct Method Binding

## Problem
Current `ScanInterceptor` uses:
1. `Thread.currentThread().getStackTrace()[2].getMethodName()` - expensive stack trace capture
2. String switch statement - adds O(log n) overhead for hash/compare
3. Runtime type code checking - branch misprediction risk

All scan methods (scanEqualsLong, scanEqualsInt, etc.) delegate to a single interceptor instance that uses introspection to determine which operation to perform.

## Solution
Create **separate specialized interceptor classes** for each scan method type:
- `ScanEqualsLongInterceptor`
- `ScanEqualsIntInterceptor`  
- `ScanEqualsStringInterceptor`
- `ScanEqualsStringIgnoreCaseInterceptor`
- `ScanBetweenLongInterceptor`
- `ScanBetweenIntInterceptor`
- `ScanInLongInterceptor`
- `ScanInIntInterceptor`
- `ScanInStringInterceptor`

Each interceptor:
- Binds directly to its specific scan method via ByteBuddy
- Knows its type code at construction time (no runtime check)
- Calls column scan method directly (no switch/if)
- Filters tombstoned rows inline (no separate method call)

## Performance Impact
- Before: Stack trace + string hash + switch + type check = ~50-100ns overhead
- After: Direct method call + inline tombstone filter = ~5-10ns overhead
- 5-10x speedup on scan operations

## Implementation

### Phase 1: Create Specialized Interceptor Classes

**File**: `MethodHandleImplementation.java`

Create a base `AbstractScanInterceptor` with common logic:
- Column field access via MethodHandle
- Allocated count retrieval
- Tombstone filtering (inline for performance)

Create specialized interceptors extending base:
- Each hardcodes its type code
- Each hardcodes its scan method call
- No runtime dispatch

### Phase 2: Update addScanMethods

Instead of:
```java
ScanInterceptor interceptor = new ScanInterceptor(columnFields);
builder.method(named("scanEqualsLong")).intercept(MethodDelegation.to(interceptor));
```

Use:
```java
builder.method(named("scanEqualsLong"))
    .intercept(MethodDelegation.to(new ScanEqualsLongInterceptor(columnFields)));
```

### Phase 3: Remove Monolithic ScanInterceptor

Delete the old `ScanInterceptor` class and its `filterTombstonedRows` method.

## Files to Modify

1. `memris-core/src/main/java/io/memris/storage/heap/MethodHandleImplementation.java`
   - Add specialized interceptor classes
   - Update `addScanMethods` to use separate instances
   - Remove monolithic `ScanInterceptor`

## Verification

1. Compile: `mvn.cmd -q -e clean compile`
2. Run ECommerceRealWorldTest: `mvn.cmd -q -e -pl memris-core test -Dtest=ECommerceRealWorldTest`
3. Run all tests: `mvn.cmd -q -e -pl memris-core test`
4. Performance: Scan operations should be visibly faster in benchmarks

## Example Code Structure

```java
// Base class with common field access
public abstract static class AbstractScanInterceptor {
    protected final List<ColumnFieldInfo> columnFields;
    protected final MethodHandles.Lookup lookup = MethodHandles.lookup();
    
    protected Object getColumn(Object obj, int columnIndex) throws Throwable {
        ColumnFieldInfo fieldInfo = columnFields.get(columnIndex);
        Field field = obj.getClass().getDeclaredField(fieldInfo.fieldName());
        MethodHandle getter = lookup.unreflectGetter(field);
        return getter.invoke(obj);
    }
}

// Specialized: scanEqualsLong
public static class ScanEqualsLongInterceptor extends AbstractScanInterceptor {
    public ScanEqualsLongInterceptor(List<ColumnFieldInfo> columnFields) {
        this.columnFields = columnFields;
    }
    
    @RuntimeType
    public int[] intercept(@Argument(0) int columnIndex, 
                          @Argument(1) Long value, 
                          @This Object obj) throws Throwable {
        // Direct column access - no type check needed
        PageColumnLong column = (PageColumnLong) getColumn(obj, columnIndex);
        int limit = (int) getAllocatedCount(obj);
        int[] results = column.scanEquals(value, limit);
        return filterTombstoned(rows, obj);  // Inline
    }
}
```

## Key Benefits

1. **Zero runtime dispatch**: Each interceptor is specialized at creation
2. **No string operations**: No stack traces, no hash codes, no comparisons  
3. **Type safety**: Type casts at construction, not runtime
4. **Branch prediction**: Single path through code, CPU can optimize
5. **Maintainability**: Each scan type is isolated and testable
