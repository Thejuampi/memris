# Implementation Plan: Full Join Support Between Arena Tables

## Background

The Memris storage engine has infrastructure for joins that is not yet integrated:
- `JoinCondition` - Structure for join conditions ✅
- `HashJoin` - Hash join algorithm implementation ✅
- `PlanNode.Join` - Join plan node with INNER/LEFT/RIGHT/FULL support ✅

However, cross-table queries are currently impossible because:
- Each `RepositoryRuntime` is bound to a single table
- No relationship annotations (@ManyToOne, @JoinColumn) in custom annotations
- Query planner only handles single-table queries
- No mechanism to access multiple tables during query execution

## Goal

Implement full join support that allows querying across tables in the same arena, enabling:
```java
// Find orders by customer email (join Order -> Customer)
List<Order> findByCustomerEmail(String email);

// Find order items with product details (join OrderItem -> Product)
List<OrderItem> findByProductSku(String sku);

// Complex multi-table joins
List<Order> findByCustomerNameContainingAndTotalGreaterThan(String name, long minTotal);
```

## Architecture Overview

### Join Types Supported
- **INNER JOIN**: Only matching rows from both tables
- **LEFT JOIN**: All rows from left table, matching from right
- **RIGHT JOIN**: Matching from left, all from right table  
- **FULL JOIN**: All rows from both tables

### Join Resolution Strategy
1. **Parse**: Detect dot notation in query method (e.g., `findByCustomerEmail`)
2. **Plan**: Identify join path (Order.customer -> Customer.id, then filter Customer.email)
3. **Execute**: Use HashJoin to combine selections from both tables
4. **Materialize**: Fetch complete entities from both tables

## Implementation Plan

### Phase 1: Relationship Annotations (P0)

#### 1.1 Create @ManyToOne Annotation
**File:** `memris-core/src/main/java/io/memris/spring/ManyToOne.java`

```java
@Target(ElementType.FIELD)
@Retention(RetentionPolicy.RUNTIME)
public @interface ManyToOne {
    /** 
     * The entity class this field references.
     * If not specified, inferred from field type.
     */
    Class<?> targetEntity() default void.class;
    
    /**
     * Fetch type - LAZY or EAGER.
     * Currently only EAGER is supported.
     */
    FetchType fetch() default FetchType.EAGER;
}

enum FetchType {
    LAZY, EAGER
}
```

**Estimated Time:** 15 minutes

#### 1.2 Create @JoinColumn Annotation
**File:** `memris-core/src/main/java/io/memris/spring/JoinColumn.java`

```java
@Target(ElementType.FIELD)
@Retention(RetentionPolicy.RUNTIME)
public @interface JoinColumn {
    /**
     * Name of the foreign key column.
     * If not specified, defaults to {fieldName}_{referencedColumnName}
     */
    String name() default "";
    
    /**
     * Name of the column in the referenced table.
     * Defaults to "id".
     */
    String referencedColumnName() default "id";
    
    /**
     * Whether the relationship is optional (can be null).
     */
    boolean nullable() default true;
}
```

**Estimated Time:** 15 minutes

#### 1.3 Update EntityMetadata to Support Relationships
**File:** `memris-core/src/main/java/io/memris/spring/EntityMetadata.java`

Enhance `FieldMapping` to include:
- `relationshipType` enum (MANY_TO_ONE, ONE_TO_MANY, etc.)
- `targetEntity` Class<?>
- `joinColumnName` String
- `referencedColumnName` String
- `isRelationship` boolean

**Estimated Time:** 1 hour

#### 1.4 Update MetadataExtractor to Parse Relationship Annotations
**File:** `memris-core/src/main/java/io/memris/spring/MetadataExtractor.java`

Parse @ManyToOne and @JoinColumn annotations to populate relationship metadata.

**Estimated Time:** 1 hour

**Phase 1 Total:** 2.5 hours

---

### Phase 2: Join Query Planning (P1)

#### 2.1 Update LogicalQuery to Support Joins
**File:** `memris-core/src/main/java/io/memris/spring/plan/LogicalQuery.java`

Add join support:
```java
public record LogicalQuery(
    OpCode opCode,
    ReturnKind returnKind,
    Condition[] conditions,
    Join[] joins,  // NEW: Array of joins
    int arity
) {
    public record Join(
        String propertyPath,      // e.g., "customer"
        String targetEntity,      // e.g., "Customer"
        String joinColumn,        // e.g., "customer_id"
        String referencedColumn,  // e.g., "id"
        JoinType joinType         // INNER, LEFT, RIGHT, FULL
    ) {}
    
    public enum JoinType {
        INNER, LEFT, RIGHT, FULL
    }
}
```

**Estimated Time:** 30 minutes

#### 2.2 Enhance QueryMethodLexer to Parse Dot Notation
**File:** `memris-core/src/main/java/io/memris/spring/plan/QueryMethodLexer.java`

Update to recognize relationship paths:
- `findByCustomerEmail` → join on customer, filter by email
- `findByCustomerAddressCity` → nested join
- Tokenize dot-separated property paths

**Estimated Time:** 2 hours

#### 2.3 Update QueryPlanner to Generate Join Plans
**File:** `memris-core/src/main/java/io/memris/spring/plan/QueryPlanner.java`

When parsing `findByCustomerEmail`:
1. Identify "customer" is a relationship field
2. Identify "email" is a field in Customer entity
3. Create Join: Order.customer → Customer.id
4. Create Condition: Customer.email = ?

**Estimated Time:** 3 hours

**Phase 2 Total:** 5.5 hours

---

### Phase 3: Compiled Join Support (P1)

#### 3.1 Add CompiledJoin to CompiledQuery
**File:** `memris-core/src/main/java/io/memris/spring/plan/CompiledQuery.java`

```java
public record CompiledQuery(
    OpCode opCode,
    ReturnKind returnKind,
    CompiledCondition[] conditions,
    CompiledJoin[] joins,  // NEW: Compiled join information
    int parameterCount
) {
    public record CompiledJoin(
        int targetTableIndex,      // Index in array of tables
        int sourceColumnIndex,     // Foreign key column in source table
        int targetColumnIndex,     // Primary key column in target table
        JoinType joinType,
        String targetEntityClass   // For materialization
    ) {}
}
```

**Estimated Time:** 30 minutes

#### 3.2 Update QueryCompiler to Compile Joins
**File:** `memris-core/src/main/java/io/memris/spring/plan/QueryCompiler.java`

Resolve join metadata:
- Map entity class names to table indices
- Resolve column indices for join columns
- Create CompiledJoin array

**Estimated Time:** 1.5 hours

**Phase 3 Total:** 2 hours

---

### Phase 4: Arena-Aware Repository Runtime (P2)

#### 4.1 Modify RepositoryPlan for Multi-Table Support
**File:** `memris-core/src/main/java/io/memris/spring/runtime/RepositoryPlan.java`

Support multiple tables:
```java
public class RepositoryPlan<T> {
    private final Class<T> entityClass;
    private final GeneratedTable primaryTable;  // Renamed from 'table'
    private final GeneratedTable[] joinedTables; // NEW: Array of joined tables
    private final HeapRuntimeKernel[] kernels;   // NEW: Kernel per table
    private final CompiledQuery[] queries;
    // ... rest of fields
}
```

**Estimated Time:** 1 hour

#### 4.2 Update RepositoryRuntime to Handle Joins
**File:** `memris-core/src/main/java/io/memris/spring/runtime/RepositoryRuntime.java`

Key changes:
```java
public final class RepositoryRuntime<T> {
    private final RepositoryPlan<T> plan;
    private final MemrisArena arena;  // NEW: Access to arena for multi-table queries
    private final Map<Class<?>, EntityMaterializer<?>> materializers; // NEW: Per-entity materializers
    
    private Selection executeJoins(CompiledQuery query, Object[] args) {
        // For each CompiledJoin:
        // 1. Get target table from arena
        // 2. Execute conditions on target table
        // 3. Use HashJoin to combine with source table selection
        // 4. Return combined selection
    }
}
```

**Estimated Time:** 4 hours

#### 4.3 Integrate HashJoin into Execution
**File:** `memris-core/src/main/java/io/memris/spring/runtime/JoinExecutor.java` (NEW)

Create a dedicated join executor:
```java
public class JoinExecutor {
    public Selection executeJoin(
        GeneratedTable sourceTable,
        Selection sourceSelection,
        GeneratedTable targetTable,
        CompiledQuery.CompiledJoin joinSpec
    ) {
        // Use HashJoin to combine selections
        // Build hash table from target table's join column
        // Probe with source table's join column
    }
}
```

**Estimated Time:** 3 hours

**Phase 4 Total:** 8 hours

---

### Phase 5: RepositoryEmitter Updates (P2)

#### 5.1 Update RepositoryEmitter for Multi-Table Plans
**File:** `memris-core/src/main/java/io/memris/spring/scaffold/RepositoryEmitter.java`

When creating a repository:
1. Analyze query methods for joins
2. Identify all tables needed (primary + joined)
3. Get/create all tables from arena
4. Build multi-table RepositoryPlan

**Estimated Time:** 3 hours

**Phase 5 Total:** 3 hours

---

### Phase 6: Materialization with Joins (P2)

#### 6.1 Update EntityMaterializer for Relationship Hydration
**File:** `memris-core/src/main/java/io/memris/spring/runtime/EntityMaterializerImpl.java`

When materializing an entity with joins:
```java
public T materialize(HeapRuntimeKernel kernel, int rowIndex) {
    // Materialize primary entity
    T entity = materializeEntity(kernel, rowIndex);
    
    // For each relationship field:
    // 1. Get foreign key value
    // 2. Query target table using arena
    // 3. Materialize related entity
    // 4. Set relationship field
}
```

**Estimated Time:** 3 hours

**Phase 6 Total:** 3 hours

---

## Summary

| Phase | Component | Est. Time | Priority |
|-------|-----------|-----------|----------|
| 1 | Relationship Annotations | 2.5h | P0 |
| 2 | Join Query Planning | 5.5h | P1 |
| 3 | Compiled Join Support | 2h | P1 |
| 4 | Arena-Aware Runtime | 8h | P2 |
| 5 | RepositoryEmitter Updates | 3h | P2 |
| 6 | Join Materialization | 3h | P2 |
| **Total** | | **24 hours** | |

## Files to Create/Modify

### New Files:
```
io/memris/spring/
  - ManyToOne.java
  - JoinColumn.java
  - FetchType.java
  
io/memris/spring/plan/
  - JoinType.java
  
io/memris/spring/runtime/
  - JoinExecutor.java
```

### Modified Files:
```
io/memris/spring/
  - EntityMetadata.java (add relationship fields)
  
io/memris/spring/plan/
  - LogicalQuery.java (add Join record)
  - CompiledQuery.java (add CompiledJoin record)
  - QueryMethodLexer.java (parse dot notation)
  - QueryPlanner.java (generate join plans)
  - QueryCompiler.java (compile joins)
  
io/memris/spring/runtime/
  - RepositoryPlan.java (multi-table support)
  - RepositoryRuntime.java (join execution)
  - EntityMaterializerImpl.java (relationship hydration)
  
io/memris/spring/scaffold/
  - RepositoryEmitter.java (multi-table plans)
  
io/memris/spring/
  - MetadataExtractor.java (parse annotations)
```

## Testing Strategy

### Unit Tests:
```java
@Test
void shouldJoinOrderWithCustomer() {
    // Given
    Customer customer = new Customer("john@example.com", "John Doe");
    customerRepo.save(customer);
    
    Order order = new Order();
    order.customer = customer.id;  // Foreign key
    order.total = 10000;
    orderRepo.save(order);
    
    // When - Query with implicit join
    List<Order> orders = orderRepo.findByCustomerEmail("john@example.com");
    
    // Then
    assertThat(orders).hasSize(1);
    assertThat(orders.get(0).customer).isEqualTo(customer.id);
}
```

### Integration Tests:
- Cross-table queries with multiple joins
- Left joins with nullable relationships
- Nested property paths (e.g., order.customer.address.city)
- Performance tests with large datasets

## Usage Examples After Implementation

```java
// Simple join
public interface OrderRepository extends MemrisRepository<Order> {
    // Implicit join: Order.customer -> Customer.email
    List<Order> findByCustomerEmail(String email);
    
    // Join with condition
    List<Order> findByCustomerNameContainingAndTotalGreaterThan(String name, long minTotal);
    
    // Nested join: OrderItem -> Product -> Category
    List<OrderItem> findByProductCategoryName(String categoryName);
}

// Entity with relationship
public class Order {
    public Long id;
    
    @ManyToOne
    @JoinColumn(name = "customer_id")
    public Customer customer;  // Can store actual reference, not just ID
    
    public long total;
    public String status;
}
```

## Next Steps

1. **Start with Phase 1** - Create annotations (2.5 hours)
2. **Phase 2** - Query parsing for joins (5.5 hours)
3. **Phase 3** - Compile joins (2 hours)
4. **Phase 4** - Multi-table runtime (8 hours) - Most complex
5. **Phase 5 & 6** - Repository and materialization (6 hours)

**Recommended Approach:** 
- Implement Phases 1-3 first for basic join support
- Then Phase 4 for execution
- Finally Phases 5-6 for complete integration

This will enable powerful cross-table queries while maintaining the arena-scoped isolation model.

## Standard Extensions Plan

### Phase 1: Complete Missing Primitive Handlers (P0)

These types have type codes but no handlers. They use existing column storage (PageColumnInt/Long).

#### 1.1 ByteTypeHandler
**File:** `memris-core/src/main/java/io/memris/spring/runtime/handlers/ByteTypeHandler.java`

```java
public class ByteTypeHandler extends AbstractTypeHandler<Byte> {
    @Override
    public byte getTypeCode() { return TypeCodes.TYPE_BYTE; }
    
    @Override
    public Byte convertValue(Object value) {
        if (value instanceof Byte) return (Byte) value;
        if (value instanceof Number) return ((Number) value).byteValue();
        throw new IllegalArgumentException("Cannot convert " + value.getClass() + " to Byte");
    }
    // Store as int, use PageColumnInt scan methods
}
```

**Storage:** PageColumnInt (byte stored as int)
**Complexity:** Low - reuse IntTypeHandler pattern
**Estimated Time:** 30 minutes

#### 1.2 ShortTypeHandler
**File:** `memris-core/src/main/java/io/memris/spring/runtime/handlers/ShortTypeHandler.java`

Similar to ByteTypeHandler but for short values.
**Storage:** PageColumnInt
**Complexity:** Low
**Estimated Time:** 30 minutes

#### 1.3 CharTypeHandler  
**File:** `memris-core/src/main/java/io/memris/spring/runtime/handlers/CharTypeHandler.java`

```java
public class CharTypeHandler extends AbstractTypeHandler<Character> {
    // Store char as int (char code)
    @Override
    protected Selection executeEquals(...) {
        int intValue = (int) value.charValue();
        return createSelection(table, table.scanEqualsInt(columnIndex, intValue));
    }
}
```

**Storage:** PageColumnInt (char code)
**Complexity:** Low
**Estimated Time:** 30 minutes

#### 1.4 FloatTypeHandler
**File:** `memris-core/src/main/java/io/memris/spring/runtime/handlers/FloatTypeHandler.java`

```java
public class FloatTypeHandler extends AbstractTypeHandler<Float> {
    // Store float bits as int
    private int floatToIntBits(float value) {
        return Float.floatToIntBits(value);
    }
    
    @Override
    protected Selection executeEquals(...) {
        int bits = floatToIntBits(value);
        return createSelection(table, table.scanEqualsInt(columnIndex, bits));
    }
}
```

**Storage:** PageColumnInt (Float.floatToIntBits)
**Complexity:** Low
**Estimated Time:** 30 minutes

**Phase 1 Total:** 4 handlers × 30 min = 2 hours

---

### Phase 2: Date/Time Types (P1)

Java 8 java.time types are essential for business applications.

#### 2.1 Add Type Codes
**File:** `memris-core/src/main/java/io/memris/spring/TypeCodes.java`

```java
// After TYPE_STRING (8)
public static final byte TYPE_LOCAL_DATE = 9;      // epochDay as long
public static final byte TYPE_LOCAL_DATE_TIME = 10; // epochMillis as long  
public static final byte TYPE_INSTANT = 11;        // epochMillis as long
public static final byte TYPE_UUID = 12;           // two longs (msb, lsb)
public static final byte TYPE_BIG_DECIMAL = 13;    // unscaled + scale
public static final byte TYPE_ENUM = 14;           // String (name) or int (ordinal)

public static final int TYPE_COUNT = 15;
```

#### 2.2 LocalDateTypeHandler
**File:** `memris-core/src/main/java/io/memris/spring/runtime/handlers/LocalDateTypeHandler.java`

```java
public class LocalDateTypeHandler extends AbstractTypeHandler<LocalDate> {
    @Override
    public byte getTypeCode() { return TypeCodes.TYPE_LOCAL_DATE; }
    
    @Override
    public LocalDate convertValue(Object value) {
        if (value instanceof LocalDate) return (LocalDate) value;
        if (value instanceof Number) return LocalDate.ofEpochDay(((Number) value).longValue());
        if (value instanceof String) return LocalDate.parse((String) value);
        throw new IllegalArgumentException("Cannot convert " + value.getClass() + " to LocalDate");
    }
    
    // Store as epochDay (long), use PageColumnLong
    @Override
    protected Selection executeEquals(GeneratedTable table, int columnIndex, LocalDate value, boolean ignoreCase) {
        long epochDay = value.toEpochDay();
        return createSelection(table, table.scanEqualsLong(columnIndex, epochDay));
    }
    
    @Override
    protected Selection executeGreaterThan(...) {
        long epochDay = value.toEpochDay();
        return createSelection(table, table.scanBetweenLong(columnIndex, epochDay + 1, Long.MAX_VALUE));
    }
    // ... other comparison methods using epochDay
}
```

**Storage:** PageColumnLong (LocalDate.toEpochDay())
**Operations:** All comparisons (dates are ordered)
**Complexity:** Low-Medium
**Estimated Time:** 1 hour

#### 2.3 LocalDateTimeTypeHandler
**File:** `memris-core/src/main/java/io/memris/spring/runtime/handlers/LocalDateTimeTypeHandler.java`

```java
public class LocalDateTimeTypeHandler extends AbstractTypeHandler<LocalDateTime> {
    // Store as epoch milliseconds
    private long toEpochMillis(LocalDateTime value) {
        return value.toInstant(ZoneOffset.UTC).toEpochMilli();
    }
    
    @Override
    protected Selection executeEquals(...) {
        long millis = toEpochMillis(value);
        return createSelection(table, table.scanEqualsLong(columnIndex, millis));
    }
    // ... similar to LocalDate but with millisecond precision
}
```

**Storage:** PageColumnLong (epoch milliseconds)
**Note:** Loses nanosecond precision (millis only). For full precision, would need two columns.
**Complexity:** Medium
**Estimated Time:** 1 hour

#### 2.4 InstantTypeHandler
**File:** `memris-core/src/main/java/io/memris/spring/runtime/handlers/InstantTypeHandler.java`

Similar to LocalDateTime but stores Instant.toEpochMilli().
**Storage:** PageColumnLong (epoch milliseconds)
**Complexity:** Low
**Estimated Time:** 45 minutes

**Phase 2 Total:** ~3 hours

---

### Phase 3: Complex Types (P2)

#### 3.1 UUIDTypeHandler
**File:** `memris-core/src/main/java/io/memris/spring/runtime/handlers/UuidTypeHandler.java`

```java
public class UuidTypeHandler extends AbstractTypeHandler<UUID> {
    @Override
    public byte getTypeCode() { return TypeCodes.TYPE_UUID; }
    
    @Override
    public UUID convertValue(Object value) {
        if (value instanceof UUID) return (UUID) value;
        if (value instanceof String) return UUID.fromString((String) value);
        throw new IllegalArgumentException("Cannot convert " + value.getClass() + " to UUID");
    }
    
    @Override
    protected Selection executeEquals(GeneratedTable table, int columnIndex, UUID value, boolean ignoreCase) {
        // UUID stored as two longs in consecutive columns
        long msb = value.getMostSignificantBits();
        long lsb = value.getLeastSignificantBits();
        
        // Scan both columns - rows must match both
        int[] msbMatches = table.scanEqualsLong(columnIndex, msb);
        int[] lsbMatches = table.scanEqualsLong(columnIndex + 1, lsb);
        
        // Intersection
        return intersection(createSelection(table, msbMatches), 
                           createSelection(table, lsbMatches));
    }
    // Range comparisons not supported for UUID
}
```

**Storage:** Two consecutive PageColumnLong columns (msb, lsb)
**Challenge:** Requires special handling in table metadata - UUID fields occupy 2 columns
**Complexity:** Medium-High
**Estimated Time:** 2-3 hours

**Alternative Simpler Approach:**
Store UUID as String (UUID.toString()). Simpler but less efficient for lookups.

#### 3.2 EnumTypeHandler
**File:** `memris-core/src/main/java/io/memris/spring/runtime/handlers/EnumTypeHandler.java`

```java
public class EnumTypeHandler<T extends Enum<T>> extends AbstractTypeHandler<T> {
    private final Class<T> enumClass;
    
    public EnumTypeHandler(Class<T> enumClass) {
        this.enumClass = enumClass;
    }
    
    @Override
    public byte getTypeCode() { return TypeCodes.TYPE_ENUM; }
    
    @Override
    public T convertValue(Object value) {
        if (enumClass.isInstance(value)) return enumClass.cast(value);
        if (value instanceof String) return Enum.valueOf(enumClass, (String) value);
        throw new IllegalArgumentException("Cannot convert " + value.getClass() + " to " + enumClass.getSimpleName());
    }
    
    @Override
    protected Selection executeEquals(GeneratedTable table, int columnIndex, T value, boolean ignoreCase) {
        // Store enum as String (name)
        String name = value.name();
        return createSelection(table, table.scanEqualsString(columnIndex, name));
    }
}
```

**Storage:** PageColumnString (enum.name())
**Pros:** Readable in storage, survives enum reordering
**Cons:** Slower than ordinal, takes more space
**Alternative:** Store as int ordinal (faster, fragile)
**Complexity:** Medium
**Estimated Time:** 1.5 hours

#### 3.3 BigDecimalTypeHandler (Simplified)
**File:** `memris-core/src/main/java/io/memris/spring/runtime/handlers/BigDecimalTypeHandler.java`

```java
public class BigDecimalTypeHandler extends AbstractTypeHandler<BigDecimal> {
    // Simplified: Store as unscaled long with fixed scale
    // Limitation: Max precision 18 digits (Long.MAX_VALUE)
    
    private static final int DEFAULT_SCALE = 4; // 4 decimal places
    
    @Override
    public byte getTypeCode() { return TypeCodes.TYPE_BIG_DECIMAL; }
    
    @Override
    public BigDecimal convertValue(Object value) {
        if (value instanceof BigDecimal) return (BigDecimal) value;
        if (value instanceof Number) return BigDecimal.valueOf(((Number) value).doubleValue());
        throw new IllegalArgumentException("Cannot convert " + value.getClass() + " to BigDecimal");
    }
    
    @Override
    protected Selection executeEquals(GeneratedTable table, int columnIndex, BigDecimal value, boolean ignoreCase) {
        // Convert to long with scale
        long unscaled = value.movePointRight(DEFAULT_SCALE).longValueExact();
        return createSelection(table, table.scanEqualsLong(columnIndex, unscaled));
    }
    
    @Override
    protected Selection executeGreaterThan(...) {
        long unscaled = value.movePointRight(DEFAULT_SCALE).longValueExact();
        return createSelection(table, table.scanBetweenLong(columnIndex, unscaled + 1, Long.MAX_VALUE));
    }
    // ... other comparisons
}
```

**Storage:** PageColumnLong (unscaled value with fixed scale)
**Limitations:** 
- Max 18 significant digits
- Fixed scale (e.g., 4 decimal places)
- No arbitrary precision
**Full Solution:** Would require storing scale + unscaled value, or using String storage
**Complexity:** Medium
**Estimated Time:** 2 hours

**Phase 3 Total:** ~6 hours

---

## Implementation Summary

| Phase | Types | Files | Est. Time | Priority |
|-------|-------|-------|-----------|----------|
| 1 | Byte, Short, Char, Float | 4 handlers | 2 hours | P0 |
| 2 | LocalDate, LocalDateTime, Instant | 3 handlers + TypeCodes | 3 hours | P1 |
| 3 | UUID, Enum, BigDecimal | 3 handlers | 6 hours | P2 |
| **Total** | **10 types** | **10 handlers** | **11 hours** | |

## Files to Modify/Create

### New Files:
```
io/memris/spring/runtime/handlers/
  - ByteTypeHandler.java
  - ShortTypeHandler.java
  - CharTypeHandler.java
  - FloatTypeHandler.java
  - LocalDateTypeHandler.java
  - LocalDateTimeTypeHandler.java
  - InstantTypeHandler.java
  - UuidTypeHandler.java
  - EnumTypeHandler.java
  - BigDecimalTypeHandler.java
```

### Modified Files:
```
io/memris/spring/
  - TypeCodes.java (add new type codes 9-14)
  
io/memris/spring/runtime/
  - TypeHandlerRegistry.java (register new handlers)
```

## Verification Strategy

### Test for Each Handler:
```java
@Test
void shouldSupportLocalDate() {
    // Given
    TestEntity entity = new TestEntity();
    entity.date = LocalDate.of(2024, 1, 15);
    
    // When
    TestEntity saved = repository.save(entity);
    Optional<TestEntity> found = repository.findByDate(LocalDate.of(2024, 1, 15));
    
    // Then
    assertThat(found).isPresent();
    assertThat(found.get().date).isEqualTo(LocalDate.of(2024, 1, 15));
}
```

### Run All Tests:
```bash
mvn.cmd -q -e -pl memris-core test
```

## Usage After Implementation

```java
@Entity
public class Product {
    @Id
    private Long id;
    
    private String name;
    private BigDecimal price;        // Now supported!
    private LocalDateTime createdAt; // Now supported!
    private UUID sku;                // Now supported!
    private Status status;           // Enum - now supported!
}

public enum Status {
    ACTIVE, INACTIVE, DISCONTINUED
}
```

## Next Steps

1. **Start with Phase 1** (2 hours) - Complete primitive types
2. **Phase 2** (3 hours) - Date/time types for e-commerce
3. **Phase 3** (6 hours) - Complex types when needed

**Recommended:** Implement Phase 1 + Phase 2 (5 hours total) for a complete basic type system suitable for 90% of applications.

## Goal

Create a working ECommerceRealWorldTest that demonstrates the Memris repository infrastructure with a realistic e-commerce domain model. The test should showcase:
- Entity relationships (simplified, without full join support)
- CRUD operations
- Query methods with various operators
- Index usage for performance

## What's Missing for Full E-Commerce

From `docs/examples/ecommerce-domain.md`, the following are **NOT YET IMPLEMENTED**:

| Feature | Status | Impact | Workaround |
|---------|--------|--------|------------|
| @ManyToOne relationships | ❌ | Cannot navigate Order->Customer | Store IDs as Long fields |
| @OneToMany relationships | ❌ | Cannot fetch Customer->Orders | Use separate queries |
| @ManyToMany relationships | ❌ | Cannot do Product<->Category many-to-many | Use join table entity |
| BigDecimal type | ❌ | Cannot store prices as BigDecimal | Use long (cents) |
| LocalDateTime type | ❌ | Cannot store timestamps | Use long (epoch millis) |
| Enum types | ❌ | Cannot use OrderStatus enum | Use String |
| @PrePersist callbacks | ❌ | Cannot auto-generate order numbers | Generate manually |
| Sorting (OrderBy) | ⚠️ | Parsed but not executed | Sort in memory after query |
| Pagination | ❌ | No Page<T> support | Use List with limits |

## Implementation Plan

### Phase 1: Create ECommerceRealWorldTest (P0)

**File:** `memris-core/src/test/java/io/memris/spring/ECommerceRealWorldTest.java`

**Entities to Create:**

1. **Customer** (simple entity)
```java
@Entity
public class Customer {
    @Id @GeneratedValue
    private Long id;
    
    @Index(type = Index.Type.HASH)
    private String email;
    
    private String firstName;
    private String lastName;
    private String phone;
    private long createdAt; // epoch millis instead of LocalDateTime
}
```

2. **Product** (simple entity)
```java
@Entity
public class Product {
    @Id @GeneratedValue
    private Long id;
    
    @Index(type = Index.Type.HASH)
    private String sku;
    
    private String name;
    private String description;
    private long priceCents; // BigDecimal workaround
    private int stockQuantity;
    private long categoryId; // Foreign key instead of @ManyToOne
}
```

3. **Order** (with foreign keys)
```java
@Entity
public class Order {
    @Id @GeneratedValue
    private Long id;
    
    private long customerId; // Foreign key
    private long orderDate; // epoch millis
    private String status; // String instead of enum
    private long totalCents;
}
```

4. **OrderItem** (join entity)
```java
@Entity
public class OrderItem {
    @Id @GeneratedValue
    private Long id;
    
    private long orderId; // Foreign key
    private long productId; // Foreign key
    private int quantity;
    private long unitPriceCents;
}
```

**Repository Interfaces:**

```java
public interface CustomerRepository extends MemrisRepository<Customer> {
    Optional<Customer> findByEmail(String email);
    List<Customer> findByFirstNameContainingIgnoreCase(String name);
    List<Customer> findByCreatedAtGreaterThan(long date);
    boolean existsByEmail(String email);
}

public interface ProductRepository extends MemrisRepository<Product> {
    Optional<Product> findBySku(String sku);
    List<Product> findByNameContaining(String keyword);
    List<Product> findByPriceCentsBetween(long min, long max);
    List<Product> findByStockQuantityGreaterThan(int quantity);
}

public interface OrderRepository extends MemrisRepository<Order> {
    List<Order> findByCustomerId(Long customerId);
    List<Order> findByCustomerIdAndStatus(Long customerId, String status);
    List<Order> findByOrderDateBetween(long start, long end);
    long countByStatus(String status);
}

public interface OrderItemRepository extends MemrisRepository<OrderItem> {
    List<OrderItem> findByOrderId(Long orderId);
    List<OrderItem> findByProductId(Long productId);
}
```

**Test Scenarios:**
1. Create customers and verify findByEmail
2. Create products and verify findBySku, findByPriceBetween
3. Create an order with items
4. Query orders by customer
5. Query order items by order
6. Verify data isolation between arenas

**Dependencies:** 
- All infrastructure already implemented and working

**Estimated Time:** 2-3 hours

---

### Phase 2: Add Missing Type Support (P1 - Future Enhancement)

**File:** `memris-core/src/main/java/io/memris/spring/TypeCodes.java`

Add support for:
```java
public static final byte TYPE_BIG_DECIMAL = 9;
public static final byte TYPE_LOCAL_DATE_TIME = 10;
public static final byte TYPE_ENUM = 11;
```

**File:** `memris-core/src/main/java/io/memris/spring/converter/TypeConverterRegistry.java`

Register converters for new types.

**File:** `memris-core/src/main/java/io/memris/spring/runtime/HeapRuntimeKernel.java`

Add scan methods for BigDecimal and Date types.

**Dependencies:** TypeConverter infrastructure
**Estimated Time:** 4-6 hours (for all three types)

---

### Phase 3: Implement Sorting (P1 - Future Enhancement)

**File:** `memris-core/src/main/java/io/memris/spring/runtime/RepositoryRuntime.java`

Add sorting support to find operations:
```java
private List<T> executeFind(CompiledQuery query, Object[] args) {
    Selection selection = executeConditions(query, args);
    
    // Get sort orders from query
    List<SortOrder> sortOrders = query.sortOrders();
    
    if (!sortOrders.isEmpty()) {
        // Materialize all entities
        List<T> results = materializeSelection(selection);
        
        // Sort in memory
        results.sort((a, b) -> {
            for (SortOrder order : sortOrders) {
                int comparison = compareEntities(a, b, order);
                if (comparison != 0) {
                    return order.isAscending() ? comparison : -comparison;
                }
            }
            return 0;
        });
        
        return results;
    }
    
    // No sorting needed
    return materializeSelection(selection);
}
```

**Dependencies:** None
**Estimated Time:** 2-3 hours

---

## Verification Strategy

### Test Commands

```bash
# Run ECommerceRealWorldTest
mvn.cmd -q -e -pl memris-core test -Dtest=ECommerceRealWorldTest

# Run all tests to ensure no regressions
mvn.cmd -q -e -pl memris-core test
```

### Expected Results

**ECommerceRealWorldTest:**
- ✅ shouldCreateCustomerWithEmail
- ✅ shouldFindCustomerByEmail
- ✅ shouldCreateProductWithSku
- ✅ shouldFindProductsByPriceRange
- ✅ shouldCreateOrderWithItems
- ✅ shouldFindOrdersByCustomer
- ✅ shouldFindOrderItemsByOrder
- ✅ shouldIsolateECommerceDataBetweenArenas

---

## Implementation Order

1. **Phase 1** - Create ECommerceRealWorldTest with simplified entities (no relationships)
2. **Phase 2** - Add BigDecimal/Date/Enum type support (optional)
3. **Phase 3** - Implement sorting (optional)

**Minimum Viable:** Phase 1 only (2-3 hours)
**Full Featured:** All phases (8-12 hours)

---

## Files to Create/Modify

| Phase | File | Type | Purpose |
|-------|------|------|---------|
| 1 | ECommerceRealWorldTest.java | Create | Integration test |
| 1 | Customer.java | Create | Test entity |
| 1 | Product.java | Create | Test entity |
| 1 | Order.java | Create | Test entity |
| 1 | OrderItem.java | Create | Test entity |
| 2 | TypeCodes.java | Modify | Add type codes |
| 2 | TypeConverterRegistry.java | Modify | Add converters |
| 3 | RepositoryRuntime.java | Modify | Add sorting |

---

## Risk Mitigation

**Risk 1: Test takes too long to write**
- Mitigation: Use simplified domain model without relationships
- Start with just Customer and Product entities

**Risk 2: Query methods don't work as expected**
- Mitigation: Test each query method individually before writing full test
- Use existing ArenaFeatureTest patterns

**Risk 3: Type conversions fail**
- Mitigation: Stick to supported types (Long, String, int, long)
- Don't use BigDecimal, LocalDateTime, or enums in Phase 1
