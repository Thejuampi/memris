# Implementation Plan: Standard Type Extensions

## Background

The Memris storage engine now has an extensible type system using the TypeHandler pattern. The current implementation supports:
- Long (64-bit integers) ✅
- Int (32-bit integers) ✅  
- String ✅
- Boolean ✅
- Double (partial - equality only) ⚠️

Type codes are defined for additional types but handlers are missing:
- Byte, Short, Char, Float (type codes exist, no handlers)
- LocalDate, LocalDateTime, Instant (not defined)
- UUID, BigDecimal, Enum (not defined)

## Goal

Implement a complete set of standard type handlers for common Java types, following the TypeHandler pattern already established. This will make Memris usable for typical enterprise applications without workarounds.

## Standard Extensions Plan

### Phase 1: Complete Missing Primitive Handlers (P0)

These types have type codes but no handlers. They use existing column storage (PageColumnInt/Long).

#### 1.1 ByteTypeHandler
**File:** `memris-core/src/main/java/io/memris/spring/runtime/handlers/ByteTypeHandler.java`

```java
public class ByteTypeHandler extends AbstractTypeHandler<Byte> {
    @Override
    public byte getTypeCode() { return TypeCodes.TYPE_BYTE; }
    
    @Override
    public Byte convertValue(Object value) {
        if (value instanceof Byte) return (Byte) value;
        if (value instanceof Number) return ((Number) value).byteValue();
        throw new IllegalArgumentException("Cannot convert " + value.getClass() + " to Byte");
    }
    // Store as int, use PageColumnInt scan methods
}
```

**Storage:** PageColumnInt (byte stored as int)
**Complexity:** Low - reuse IntTypeHandler pattern
**Estimated Time:** 30 minutes

#### 1.2 ShortTypeHandler
**File:** `memris-core/src/main/java/io/memris/spring/runtime/handlers/ShortTypeHandler.java`

Similar to ByteTypeHandler but for short values.
**Storage:** PageColumnInt
**Complexity:** Low
**Estimated Time:** 30 minutes

#### 1.3 CharTypeHandler  
**File:** `memris-core/src/main/java/io/memris/spring/runtime/handlers/CharTypeHandler.java`

```java
public class CharTypeHandler extends AbstractTypeHandler<Character> {
    // Store char as int (char code)
    @Override
    protected Selection executeEquals(...) {
        int intValue = (int) value.charValue();
        return createSelection(table, table.scanEqualsInt(columnIndex, intValue));
    }
}
```

**Storage:** PageColumnInt (char code)
**Complexity:** Low
**Estimated Time:** 30 minutes

#### 1.4 FloatTypeHandler
**File:** `memris-core/src/main/java/io/memris/spring/runtime/handlers/FloatTypeHandler.java`

```java
public class FloatTypeHandler extends AbstractTypeHandler<Float> {
    // Store float bits as int
    private int floatToIntBits(float value) {
        return Float.floatToIntBits(value);
    }
    
    @Override
    protected Selection executeEquals(...) {
        int bits = floatToIntBits(value);
        return createSelection(table, table.scanEqualsInt(columnIndex, bits));
    }
}
```

**Storage:** PageColumnInt (Float.floatToIntBits)
**Complexity:** Low
**Estimated Time:** 30 minutes

**Phase 1 Total:** 4 handlers × 30 min = 2 hours

---

### Phase 2: Date/Time Types (P1)

Java 8 java.time types are essential for business applications.

#### 2.1 Add Type Codes
**File:** `memris-core/src/main/java/io/memris/spring/TypeCodes.java`

```java
// After TYPE_STRING (8)
public static final byte TYPE_LOCAL_DATE = 9;      // epochDay as long
public static final byte TYPE_LOCAL_DATE_TIME = 10; // epochMillis as long  
public static final byte TYPE_INSTANT = 11;        // epochMillis as long
public static final byte TYPE_UUID = 12;           // two longs (msb, lsb)
public static final byte TYPE_BIG_DECIMAL = 13;    // unscaled + scale
public static final byte TYPE_ENUM = 14;           // String (name) or int (ordinal)

public static final int TYPE_COUNT = 15;
```

#### 2.2 LocalDateTypeHandler
**File:** `memris-core/src/main/java/io/memris/spring/runtime/handlers/LocalDateTypeHandler.java`

```java
public class LocalDateTypeHandler extends AbstractTypeHandler<LocalDate> {
    @Override
    public byte getTypeCode() { return TypeCodes.TYPE_LOCAL_DATE; }
    
    @Override
    public LocalDate convertValue(Object value) {
        if (value instanceof LocalDate) return (LocalDate) value;
        if (value instanceof Number) return LocalDate.ofEpochDay(((Number) value).longValue());
        if (value instanceof String) return LocalDate.parse((String) value);
        throw new IllegalArgumentException("Cannot convert " + value.getClass() + " to LocalDate");
    }
    
    // Store as epochDay (long), use PageColumnLong
    @Override
    protected Selection executeEquals(GeneratedTable table, int columnIndex, LocalDate value, boolean ignoreCase) {
        long epochDay = value.toEpochDay();
        return createSelection(table, table.scanEqualsLong(columnIndex, epochDay));
    }
    
    @Override
    protected Selection executeGreaterThan(...) {
        long epochDay = value.toEpochDay();
        return createSelection(table, table.scanBetweenLong(columnIndex, epochDay + 1, Long.MAX_VALUE));
    }
    // ... other comparison methods using epochDay
}
```

**Storage:** PageColumnLong (LocalDate.toEpochDay())
**Operations:** All comparisons (dates are ordered)
**Complexity:** Low-Medium
**Estimated Time:** 1 hour

#### 2.3 LocalDateTimeTypeHandler
**File:** `memris-core/src/main/java/io/memris/spring/runtime/handlers/LocalDateTimeTypeHandler.java`

```java
public class LocalDateTimeTypeHandler extends AbstractTypeHandler<LocalDateTime> {
    // Store as epoch milliseconds
    private long toEpochMillis(LocalDateTime value) {
        return value.toInstant(ZoneOffset.UTC).toEpochMilli();
    }
    
    @Override
    protected Selection executeEquals(...) {
        long millis = toEpochMillis(value);
        return createSelection(table, table.scanEqualsLong(columnIndex, millis));
    }
    // ... similar to LocalDate but with millisecond precision
}
```

**Storage:** PageColumnLong (epoch milliseconds)
**Note:** Loses nanosecond precision (millis only). For full precision, would need two columns.
**Complexity:** Medium
**Estimated Time:** 1 hour

#### 2.4 InstantTypeHandler
**File:** `memris-core/src/main/java/io/memris/spring/runtime/handlers/InstantTypeHandler.java`

Similar to LocalDateTime but stores Instant.toEpochMilli().
**Storage:** PageColumnLong (epoch milliseconds)
**Complexity:** Low
**Estimated Time:** 45 minutes

**Phase 2 Total:** ~3 hours

---

### Phase 3: Complex Types (P2)

#### 3.1 UUIDTypeHandler
**File:** `memris-core/src/main/java/io/memris/spring/runtime/handlers/UuidTypeHandler.java`

```java
public class UuidTypeHandler extends AbstractTypeHandler<UUID> {
    @Override
    public byte getTypeCode() { return TypeCodes.TYPE_UUID; }
    
    @Override
    public UUID convertValue(Object value) {
        if (value instanceof UUID) return (UUID) value;
        if (value instanceof String) return UUID.fromString((String) value);
        throw new IllegalArgumentException("Cannot convert " + value.getClass() + " to UUID");
    }
    
    @Override
    protected Selection executeEquals(GeneratedTable table, int columnIndex, UUID value, boolean ignoreCase) {
        // UUID stored as two longs in consecutive columns
        long msb = value.getMostSignificantBits();
        long lsb = value.getLeastSignificantBits();
        
        // Scan both columns - rows must match both
        int[] msbMatches = table.scanEqualsLong(columnIndex, msb);
        int[] lsbMatches = table.scanEqualsLong(columnIndex + 1, lsb);
        
        // Intersection
        return intersection(createSelection(table, msbMatches), 
                           createSelection(table, lsbMatches));
    }
    // Range comparisons not supported for UUID
}
```

**Storage:** Two consecutive PageColumnLong columns (msb, lsb)
**Challenge:** Requires special handling in table metadata - UUID fields occupy 2 columns
**Complexity:** Medium-High
**Estimated Time:** 2-3 hours

**Alternative Simpler Approach:**
Store UUID as String (UUID.toString()). Simpler but less efficient for lookups.

#### 3.2 EnumTypeHandler
**File:** `memris-core/src/main/java/io/memris/spring/runtime/handlers/EnumTypeHandler.java`

```java
public class EnumTypeHandler<T extends Enum<T>> extends AbstractTypeHandler<T> {
    private final Class<T> enumClass;
    
    public EnumTypeHandler(Class<T> enumClass) {
        this.enumClass = enumClass;
    }
    
    @Override
    public byte getTypeCode() { return TypeCodes.TYPE_ENUM; }
    
    @Override
    public T convertValue(Object value) {
        if (enumClass.isInstance(value)) return enumClass.cast(value);
        if (value instanceof String) return Enum.valueOf(enumClass, (String) value);
        throw new IllegalArgumentException("Cannot convert " + value.getClass() + " to " + enumClass.getSimpleName());
    }
    
    @Override
    protected Selection executeEquals(GeneratedTable table, int columnIndex, T value, boolean ignoreCase) {
        // Store enum as String (name)
        String name = value.name();
        return createSelection(table, table.scanEqualsString(columnIndex, name));
    }
}
```

**Storage:** PageColumnString (enum.name())
**Pros:** Readable in storage, survives enum reordering
**Cons:** Slower than ordinal, takes more space
**Alternative:** Store as int ordinal (faster, fragile)
**Complexity:** Medium
**Estimated Time:** 1.5 hours

#### 3.3 BigDecimalTypeHandler (Simplified)
**File:** `memris-core/src/main/java/io/memris/spring/runtime/handlers/BigDecimalTypeHandler.java`

```java
public class BigDecimalTypeHandler extends AbstractTypeHandler<BigDecimal> {
    // Simplified: Store as unscaled long with fixed scale
    // Limitation: Max precision 18 digits (Long.MAX_VALUE)
    
    private static final int DEFAULT_SCALE = 4; // 4 decimal places
    
    @Override
    public byte getTypeCode() { return TypeCodes.TYPE_BIG_DECIMAL; }
    
    @Override
    public BigDecimal convertValue(Object value) {
        if (value instanceof BigDecimal) return (BigDecimal) value;
        if (value instanceof Number) return BigDecimal.valueOf(((Number) value).doubleValue());
        throw new IllegalArgumentException("Cannot convert " + value.getClass() + " to BigDecimal");
    }
    
    @Override
    protected Selection executeEquals(GeneratedTable table, int columnIndex, BigDecimal value, boolean ignoreCase) {
        // Convert to long with scale
        long unscaled = value.movePointRight(DEFAULT_SCALE).longValueExact();
        return createSelection(table, table.scanEqualsLong(columnIndex, unscaled));
    }
    
    @Override
    protected Selection executeGreaterThan(...) {
        long unscaled = value.movePointRight(DEFAULT_SCALE).longValueExact();
        return createSelection(table, table.scanBetweenLong(columnIndex, unscaled + 1, Long.MAX_VALUE));
    }
    // ... other comparisons
}
```

**Storage:** PageColumnLong (unscaled value with fixed scale)
**Limitations:** 
- Max 18 significant digits
- Fixed scale (e.g., 4 decimal places)
- No arbitrary precision
**Full Solution:** Would require storing scale + unscaled value, or using String storage
**Complexity:** Medium
**Estimated Time:** 2 hours

**Phase 3 Total:** ~6 hours

---

## Implementation Summary

| Phase | Types | Files | Est. Time | Priority |
|-------|-------|-------|-----------|----------|
| 1 | Byte, Short, Char, Float | 4 handlers | 2 hours | P0 |
| 2 | LocalDate, LocalDateTime, Instant | 3 handlers + TypeCodes | 3 hours | P1 |
| 3 | UUID, Enum, BigDecimal | 3 handlers | 6 hours | P2 |
| **Total** | **10 types** | **10 handlers** | **11 hours** | |

## Files to Modify/Create

### New Files:
```
io/memris/spring/runtime/handlers/
  - ByteTypeHandler.java
  - ShortTypeHandler.java
  - CharTypeHandler.java
  - FloatTypeHandler.java
  - LocalDateTypeHandler.java
  - LocalDateTimeTypeHandler.java
  - InstantTypeHandler.java
  - UuidTypeHandler.java
  - EnumTypeHandler.java
  - BigDecimalTypeHandler.java
```

### Modified Files:
```
io/memris/spring/
  - TypeCodes.java (add new type codes 9-14)
  
io/memris/spring/runtime/
  - TypeHandlerRegistry.java (register new handlers)
```

## Verification Strategy

### Test for Each Handler:
```java
@Test
void shouldSupportLocalDate() {
    // Given
    TestEntity entity = new TestEntity();
    entity.date = LocalDate.of(2024, 1, 15);
    
    // When
    TestEntity saved = repository.save(entity);
    Optional<TestEntity> found = repository.findByDate(LocalDate.of(2024, 1, 15));
    
    // Then
    assertThat(found).isPresent();
    assertThat(found.get().date).isEqualTo(LocalDate.of(2024, 1, 15));
}
```

### Run All Tests:
```bash
mvn.cmd -q -e -pl memris-core test
```

## Usage After Implementation

```java
@Entity
public class Product {
    @Id
    private Long id;
    
    private String name;
    private BigDecimal price;        // Now supported!
    private LocalDateTime createdAt; // Now supported!
    private UUID sku;                // Now supported!
    private Status status;           // Enum - now supported!
}

public enum Status {
    ACTIVE, INACTIVE, DISCONTINUED
}
```

## Next Steps

1. **Start with Phase 1** (2 hours) - Complete primitive types
2. **Phase 2** (3 hours) - Date/time types for e-commerce
3. **Phase 3** (6 hours) - Complex types when needed

**Recommended:** Implement Phase 1 + Phase 2 (5 hours total) for a complete basic type system suitable for 90% of applications.

## Goal

Create a working ECommerceRealWorldTest that demonstrates the Memris repository infrastructure with a realistic e-commerce domain model. The test should showcase:
- Entity relationships (simplified, without full join support)
- CRUD operations
- Query methods with various operators
- Index usage for performance

## What's Missing for Full E-Commerce

From `docs/examples/ecommerce-domain.md`, the following are **NOT YET IMPLEMENTED**:

| Feature | Status | Impact | Workaround |
|---------|--------|--------|------------|
| @ManyToOne relationships | ❌ | Cannot navigate Order->Customer | Store IDs as Long fields |
| @OneToMany relationships | ❌ | Cannot fetch Customer->Orders | Use separate queries |
| @ManyToMany relationships | ❌ | Cannot do Product<->Category many-to-many | Use join table entity |
| BigDecimal type | ❌ | Cannot store prices as BigDecimal | Use long (cents) |
| LocalDateTime type | ❌ | Cannot store timestamps | Use long (epoch millis) |
| Enum types | ❌ | Cannot use OrderStatus enum | Use String |
| @PrePersist callbacks | ❌ | Cannot auto-generate order numbers | Generate manually |
| Sorting (OrderBy) | ⚠️ | Parsed but not executed | Sort in memory after query |
| Pagination | ❌ | No Page<T> support | Use List with limits |

## Implementation Plan

### Phase 1: Create ECommerceRealWorldTest (P0)

**File:** `memris-core/src/test/java/io/memris/spring/ECommerceRealWorldTest.java`

**Entities to Create:**

1. **Customer** (simple entity)
```java
@Entity
public class Customer {
    @Id @GeneratedValue
    private Long id;
    
    @Index(type = Index.Type.HASH)
    private String email;
    
    private String firstName;
    private String lastName;
    private String phone;
    private long createdAt; // epoch millis instead of LocalDateTime
}
```

2. **Product** (simple entity)
```java
@Entity
public class Product {
    @Id @GeneratedValue
    private Long id;
    
    @Index(type = Index.Type.HASH)
    private String sku;
    
    private String name;
    private String description;
    private long priceCents; // BigDecimal workaround
    private int stockQuantity;
    private long categoryId; // Foreign key instead of @ManyToOne
}
```

3. **Order** (with foreign keys)
```java
@Entity
public class Order {
    @Id @GeneratedValue
    private Long id;
    
    private long customerId; // Foreign key
    private long orderDate; // epoch millis
    private String status; // String instead of enum
    private long totalCents;
}
```

4. **OrderItem** (join entity)
```java
@Entity
public class OrderItem {
    @Id @GeneratedValue
    private Long id;
    
    private long orderId; // Foreign key
    private long productId; // Foreign key
    private int quantity;
    private long unitPriceCents;
}
```

**Repository Interfaces:**

```java
public interface CustomerRepository extends MemrisRepository<Customer> {
    Optional<Customer> findByEmail(String email);
    List<Customer> findByFirstNameContainingIgnoreCase(String name);
    List<Customer> findByCreatedAtGreaterThan(long date);
    boolean existsByEmail(String email);
}

public interface ProductRepository extends MemrisRepository<Product> {
    Optional<Product> findBySku(String sku);
    List<Product> findByNameContaining(String keyword);
    List<Product> findByPriceCentsBetween(long min, long max);
    List<Product> findByStockQuantityGreaterThan(int quantity);
}

public interface OrderRepository extends MemrisRepository<Order> {
    List<Order> findByCustomerId(Long customerId);
    List<Order> findByCustomerIdAndStatus(Long customerId, String status);
    List<Order> findByOrderDateBetween(long start, long end);
    long countByStatus(String status);
}

public interface OrderItemRepository extends MemrisRepository<OrderItem> {
    List<OrderItem> findByOrderId(Long orderId);
    List<OrderItem> findByProductId(Long productId);
}
```

**Test Scenarios:**
1. Create customers and verify findByEmail
2. Create products and verify findBySku, findByPriceBetween
3. Create an order with items
4. Query orders by customer
5. Query order items by order
6. Verify data isolation between arenas

**Dependencies:** 
- All infrastructure already implemented and working

**Estimated Time:** 2-3 hours

---

### Phase 2: Add Missing Type Support (P1 - Future Enhancement)

**File:** `memris-core/src/main/java/io/memris/spring/TypeCodes.java`

Add support for:
```java
public static final byte TYPE_BIG_DECIMAL = 9;
public static final byte TYPE_LOCAL_DATE_TIME = 10;
public static final byte TYPE_ENUM = 11;
```

**File:** `memris-core/src/main/java/io/memris/spring/converter/TypeConverterRegistry.java`

Register converters for new types.

**File:** `memris-core/src/main/java/io/memris/spring/runtime/HeapRuntimeKernel.java`

Add scan methods for BigDecimal and Date types.

**Dependencies:** TypeConverter infrastructure
**Estimated Time:** 4-6 hours (for all three types)

---

### Phase 3: Implement Sorting (P1 - Future Enhancement)

**File:** `memris-core/src/main/java/io/memris/spring/runtime/RepositoryRuntime.java`

Add sorting support to find operations:
```java
private List<T> executeFind(CompiledQuery query, Object[] args) {
    Selection selection = executeConditions(query, args);
    
    // Get sort orders from query
    List<SortOrder> sortOrders = query.sortOrders();
    
    if (!sortOrders.isEmpty()) {
        // Materialize all entities
        List<T> results = materializeSelection(selection);
        
        // Sort in memory
        results.sort((a, b) -> {
            for (SortOrder order : sortOrders) {
                int comparison = compareEntities(a, b, order);
                if (comparison != 0) {
                    return order.isAscending() ? comparison : -comparison;
                }
            }
            return 0;
        });
        
        return results;
    }
    
    // No sorting needed
    return materializeSelection(selection);
}
```

**Dependencies:** None
**Estimated Time:** 2-3 hours

---

## Verification Strategy

### Test Commands

```bash
# Run ECommerceRealWorldTest
mvn.cmd -q -e -pl memris-core test -Dtest=ECommerceRealWorldTest

# Run all tests to ensure no regressions
mvn.cmd -q -e -pl memris-core test
```

### Expected Results

**ECommerceRealWorldTest:**
- ✅ shouldCreateCustomerWithEmail
- ✅ shouldFindCustomerByEmail
- ✅ shouldCreateProductWithSku
- ✅ shouldFindProductsByPriceRange
- ✅ shouldCreateOrderWithItems
- ✅ shouldFindOrdersByCustomer
- ✅ shouldFindOrderItemsByOrder
- ✅ shouldIsolateECommerceDataBetweenArenas

---

## Implementation Order

1. **Phase 1** - Create ECommerceRealWorldTest with simplified entities (no relationships)
2. **Phase 2** - Add BigDecimal/Date/Enum type support (optional)
3. **Phase 3** - Implement sorting (optional)

**Minimum Viable:** Phase 1 only (2-3 hours)
**Full Featured:** All phases (8-12 hours)

---

## Files to Create/Modify

| Phase | File | Type | Purpose |
|-------|------|------|---------|
| 1 | ECommerceRealWorldTest.java | Create | Integration test |
| 1 | Customer.java | Create | Test entity |
| 1 | Product.java | Create | Test entity |
| 1 | Order.java | Create | Test entity |
| 1 | OrderItem.java | Create | Test entity |
| 2 | TypeCodes.java | Modify | Add type codes |
| 2 | TypeConverterRegistry.java | Modify | Add converters |
| 3 | RepositoryRuntime.java | Modify | Add sorting |

---

## Risk Mitigation

**Risk 1: Test takes too long to write**
- Mitigation: Use simplified domain model without relationships
- Start with just Customer and Product entities

**Risk 2: Query methods don't work as expected**
- Mitigation: Test each query method individually before writing full test
- Use existing ArenaFeatureTest patterns

**Risk 3: Type conversions fail**
- Mitigation: Stick to supported types (Long, String, int, long)
- Don't use BigDecimal, LocalDateTime, or enums in Phase 1
