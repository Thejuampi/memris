package io.memris.spring;

import io.memris.spring.converter.TypeConverter;

import java.lang.invoke.MethodHandle;
import java.lang.reflect.Constructor;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;

/**
 * Metadata captured at repository creation time.
 * All reflection work happens once, then this metadata
 * is used by generated bytecode for zero-overhead access.
 *
 * This is a simple class - no ByteBuddy generation needed!
 * The ByteBuddy generation is for the repository implementation, not for this metadata.
 */
public class EntityMetadata<T> {
    private final Class<T> entityClass;
    private final Constructor<T> entityConstructor;
    private final String idColumnName;
    private final List<FieldMapping> fields;
    private final Set<String> foreignKeyColumns;

    // Pre-compiled TypeConverters per field
    private final Map<String, TypeConverter<?, ?>> converters;

    // Pre-compiled lifecycle callback MethodHandles
    private final MethodHandle prePersistHandle;
    private final MethodHandle postLoadHandle;
    private final MethodHandle preUpdateHandle;

    // Pre-compiled field accessor MethodHandles (NO reflection at runtime!)
    // Supports both JavaBean style (get/set) and Kotlin-style (property name) accessors
    private final Map<String, MethodHandle> fieldGetters;
    private final Map<String, MethodHandle> fieldSetters;

    // Whether this entity is a Java record (requires special handling)
    private final boolean isRecord;

    // O(1) position lookups - built at metadata creation time
    private final Map<String, Integer> propertyToColumnPosition;
    private final Map<String, Integer> columnNameToColumnPosition;

    public EntityMetadata(
        Class<T> entityClass,
        Constructor<T> entityConstructor,
        String idColumnName,
        List<FieldMapping> fields,
        Set<String> foreignKeyColumns,
        Map<String, TypeConverter<?, ?>> converters,
        MethodHandle prePersistHandle,
        MethodHandle postLoadHandle,
        MethodHandle preUpdateHandle,
        Map<String, MethodHandle> fieldGetters,
        Map<String, MethodHandle> fieldSetters,
        boolean isRecord
    ) {
        this.entityClass = entityClass;
        this.entityConstructor = entityConstructor;
        this.idColumnName = idColumnName;
        this.fields = fields;
        this.foreignKeyColumns = foreignKeyColumns;
        this.converters = converters;
        this.prePersistHandle = prePersistHandle;
        this.postLoadHandle = postLoadHandle;
        this.preUpdateHandle = preUpdateHandle;
        this.fieldGetters = fieldGetters;
        this.fieldSetters = fieldSetters;
        this.isRecord = isRecord;

        // Build O(1) lookup maps
        Map<String, Integer> propertyMap = new HashMap<>(fields.size() * 2);
        Map<String, Integer> columnMap = new HashMap<>(fields.size() * 2);
        for (int i = 0; i < fields.size(); i++) {
            FieldMapping fm = fields.get(i);
            propertyMap.put(fm.name(), fm.columnPosition());
            columnMap.put(fm.columnName(), fm.columnPosition());
        }
        this.propertyToColumnPosition = Map.copyOf(propertyMap); // Immutable copy
        this.columnNameToColumnPosition = Map.copyOf(columnMap); // Immutable copy
    }

    // Accessor methods (for record-like API)
    public Class<T> entityClass() { return entityClass; }
    public Constructor<T> entityConstructor() { return entityConstructor; }
    public String idColumnName() { return idColumnName; }
    public List<FieldMapping> fields() { return fields; }
    public Set<String> foreignKeyColumns() { return foreignKeyColumns; }
    public Map<String, TypeConverter<?, ?>> converters() { return converters; }
    public MethodHandle prePersistHandle() { return prePersistHandle; }
    public MethodHandle postLoadHandle() { return postLoadHandle; }
    public MethodHandle preUpdateHandle() { return preUpdateHandle; }
    public Map<String, MethodHandle> fieldGetters() { return fieldGetters; }
    public Map<String, MethodHandle> fieldSetters() { return fieldSetters; }
    public boolean isRecord() { return isRecord; }

    /**
     * Returns the column position for a property path.
     * O(1) lookup using pre-built map.
     * @throws IllegalArgumentException if property not found
     */
    public int resolvePropertyPosition(String propertyPath) {
        Integer pos = propertyToColumnPosition.get(propertyPath);
        if (pos == null) {
            throw new IllegalArgumentException("Property not found: " + propertyPath);
        }
        return pos;
    }

    /**
     * Returns the column position for a column name.
     * O(1) lookup using pre-built map.
     * @throws IllegalArgumentException if column not found
     */
    public int resolveColumnPosition(String columnName) {
        Integer pos = columnNameToColumnPosition.get(columnName);
        if (pos == null) {
            throw new IllegalArgumentException("Column not found: " + columnName);
        }
        return pos;
    }

    /**
     * Mapping between entity field and table column.
     * Used to generate direct field access in bytecode.
     */
    public record FieldMapping(
        String name,           // Field name (e.g., "price")
        String columnName,     // Column name (e.g., "price")
        Class<?> javaType,     // Field type (e.g., int.class)
        Class<?> storageType,  // Storage type (e.g., int.class)
        int columnPosition,    // Column index in table (for potential optimization)
        byte typeCode,         // Pre-computed type code for zero-overhead switching

        // Relationship metadata
        boolean isRelationship,   // Is this a relationship field?
        RelationshipType relationshipType, // ONE_TO_ONE, MANY_TO_ONE, etc.
        Class<?> targetEntity,    // Target entity class
        String joinTable,         // Join table name (for @ManyToMany)
        boolean isCollection,     // Is this a collection field?
        boolean isEmbedded        // Is this @Embedded?
    ) {
        public enum RelationshipType {
            ONE_TO_ONE, MANY_TO_ONE, ONE_TO_MANY, MANY_TO_MANY, NONE
        }

        // Canonical constructor with default values for new fields
        public FieldMapping {
            if (!isRelationship) {
                relationshipType = RelationshipType.NONE;
                targetEntity = null;
                joinTable = null;
                isCollection = false;
            }
        }

        // Convenience constructor for backwards compatibility (non-relationship fields)
        public FieldMapping(
            String name,
            String columnName,
            Class<?> javaType,
            Class<?> storageType,
            int columnPosition,
            byte typeCode
        ) {
            this(name, columnName, javaType, storageType, columnPosition, typeCode,
                 false, RelationshipType.NONE, null, null, false, false);
        }
    }
}
