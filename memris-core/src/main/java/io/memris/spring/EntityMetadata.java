package io.memris.spring;

import io.memris.spring.converter.TypeConverter;
import io.memris.storage.ffm.FfmTable;

import java.lang.invoke.MethodHandle;
import java.lang.reflect.Constructor;
import java.util.List;
import java.util.Map;
import java.util.Set;

/**
 * Metadata captured at repository creation time.
 * All reflection work happens once, then this metadata
 * is used by generated bytecode for zero-overhead access.
 *
 * This is a simple record - no ByteBuddy generation needed!
 * The ByteBuddy generation is for the repository implementation, not for this metadata.
 */
public record EntityMetadata<T>(
    Class<T> entityClass,
    Constructor<T> entityConstructor,
    String idColumnName,
    List<FieldMapping> fields,
    Set<String> foreignKeyColumns,

    // Pre-compiled TypeConverters per field
    Map<String, TypeConverter<?, ?>> converters,

    // Pre-compiled lifecycle callback MethodHandles
    MethodHandle prePersistHandle,
    MethodHandle postLoadHandle,
    MethodHandle preUpdateHandle,

    // Pre-compiled field accessor MethodHandles (NO reflection at runtime!)
    // Supports both JavaBean style (get/set) and Kotlin-style (property name) accessors
    Map<String, MethodHandle> fieldGetters,
    Map<String, MethodHandle> fieldSetters,

    // Whether this entity is a Java record (requires special handling)
    boolean isRecord
) {
    /**
     * Mapping between entity field and table column.
     * Used to generate direct field access in bytecode.
     */
    public record FieldMapping(
        String name,           // Field name (e.g., "price")
        String columnName,     // Column name (e.g., "price")
        Class<?> javaType,     // Field type (e.g., int.class)
        Class<?> storageType,  // Storage type (e.g., int.class)
        int columnPosition     // Column index in table (for potential optimization)
    ) {}
}
