package io.memris.spring;

import io.memris.kernel.Predicate;
import io.memris.kernel.selection.MutableSelectionVector;
import io.memris.kernel.selection.SelectionVector;
import io.memris.kernel.selection.SelectionVectorFactory;
import io.memris.spring.converter.TypeConverter;
import io.memris.storage.ffm.FfmTable;

import net.bytebuddy.ByteBuddy;
import net.bytebuddy.asm.Advice;
import net.bytebuddy.description.modifier.Visibility;
import net.bytebuddy.dynamic.DynamicType;
import net.bytebuddy.implementation.MethodCall;
import net.bytebuddy.implementation.MethodDelegation;
import net.bytebuddy.implementation.bind.annotation.*;
import net.bytebuddy.implementation.StubMethod;

import java.lang.invoke.MethodHandle;
import java.lang.reflect.Method;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.Set;

/**
 * Generates repository implementations using ByteBuddy MethodDelegation API.
 * All reflection work happens at generation time - generated bytecode has ZERO reflection overhead.
 * <p>
 * Key architectural principle: Only generate methods that are declared in the repository interface.
 * If PersonRepository only declares findByName(String name), then only that method (plus inherited methods)
 * will be generated, NOT delete, update, etc.
 * <p>
 * Field access uses pre-compiled MethodHandles instead of getDeclaredField/set for zero-overhead access.
 * Supports both JavaBean style (get/set) and Kotlin-style (property name) accessors.
 * Java records are handled specially - they use the canonical constructor and record component accessors.
 */
public final class RepositoryBytecodeGenerator {

    private final ByteBuddy byteBuddy;
    private final MemrisRepositoryFactory factory;

    public RepositoryBytecodeGenerator(MemrisRepositoryFactory factory) {
        this.byteBuddy = new ByteBuddy();
        this.factory = factory;
    }

    public <T, R extends MemrisRepository<T>> R generateRepository(
            Class<R> repositoryInterface,
            EntityMetadata<T> entityMetadata,
            FfmTable table,
            List<QueryMetadata> queryMethods) {

        String className = repositoryInterface.getSimpleName() + "ByteBuddyImpl";

        // Get declared methods from the repository interface
        Set<String> declaredMethods = getDeclaredMethodNames(repositoryInterface);

        try {
            DynamicType.Builder<R> builder = byteBuddy
                    .subclass(repositoryInterface)
                    .name(repositoryInterface.getPackage().getName() + "." + className)

                    // Add fields (ALL direct references, no maps!)
                    .defineField("table", FfmTable.class, Visibility.PRIVATE)
                    .defineField("factory", MemrisRepositoryFactory.class, Visibility.PRIVATE)
                    .defineField("entityClass", Class.class, Visibility.PRIVATE)
                    .defineField("idColumnName", String.class, Visibility.PRIVATE)
                    .defineField("converters", Map.class, Visibility.PRIVATE)
                    .defineField("fields", List.class, Visibility.PRIVATE)
                    .defineField("fieldGetters", Map.class, Visibility.PRIVATE)
                    .defineField("fieldSetters", Map.class, Visibility.PRIVATE)
                    .defineField("postLoadHandle", MethodHandle.class, Visibility.PRIVATE)
                    .defineField("prePersistHandle", MethodHandle.class, Visibility.PRIVATE)
                    .defineField("preUpdateHandle", MethodHandle.class, Visibility.PRIVATE)
                    .defineField("isRecord", boolean.class, Visibility.PRIVATE)

                    // Constructor - initializes all fields
                    .defineConstructor(Visibility.PUBLIC)
                    .withParameters(FfmTable.class, MemrisRepositoryFactory.class, EntityMetadata.class)
                    .intercept(MethodDelegation.to(new ConstructorInterceptor()));

            // ONLY generate methods that are declared in the repository interface
            // This is the key architectural fix - we don't generate methods that aren't declared

            if (hasMethod(declaredMethods, "getEntityClass")) {
                builder = generateGetEntityClass(builder);
            }

            if (hasMethod(declaredMethods, "findById", Object.class)) {
                builder = generateFindById(builder, entityMetadata);
            }

            if (hasMethod(declaredMethods, "existsById", Object.class)) {
                builder = generateExistsById(builder, entityMetadata);
            }

            if (hasMethod(declaredMethods, "deleteById", Object.class)) {
                builder = generateDeleteById(builder, entityMetadata);
            }

            if (hasMethod(declaredMethods, "findAll")) {
                builder = generateFindAll(builder, entityMetadata);
            }

            if (hasMethod(declaredMethods, "count")) {
                builder = generateCount(builder);
            }

            if (hasMethod(declaredMethods, "deleteAll")) {
                builder = generateDeleteAll(builder, entityMetadata);
            }

            if (hasMethod(declaredMethods, "save", Object.class)) {
                builder = generateSave(builder, entityMetadata);
            }

            if (hasMethod(declaredMethods, "update", Object.class)) {
                builder = generateUpdate(builder, entityMetadata);
            }

            // Generate query methods (these are always declared by definition)
            for (QueryMetadata query : queryMethods) {
                builder = generateQueryMethod(builder, query, entityMetadata);
            }

            // Build and load the class
            Class<? extends R> generatedClass = builder.make()
                    .load(RepositoryBytecodeGenerator.class.getClassLoader())
                    .getLoaded();

            return generatedClass
                    .getDeclaredConstructor(FfmTable.class, MemrisRepositoryFactory.class, EntityMetadata.class)
                    .newInstance(table, factory, entityMetadata);

        } catch (Throwable t) {
            throw new RuntimeException("Failed to generate repository: " + className, t);
        }
    }

    // ========================================================================
    // Method Generation
    // ========================================================================

    private <T, R extends MemrisRepository<T>> DynamicType.Builder<R> generateGetEntityClass(
            DynamicType.Builder<R> builder) {

        return builder.defineMethod("getEntityClass", Class.class, Visibility.PUBLIC)
                .intercept(MethodDelegation.to(new GetEntityClassInterceptor()));
    }

    private <T, R extends MemrisRepository<T>> DynamicType.Builder<R> generateFindById(
            DynamicType.Builder<R> builder,
            EntityMetadata<T> entityMetadata) {

        return builder.defineMethod("findById", Optional.class, Visibility.PUBLIC)
                .withParameter(Object.class, "id")
                .intercept(MethodDelegation.to(new FindByIdInterceptor()));
    }

    private <T, R extends MemrisRepository<T>> DynamicType.Builder<R> generateExistsById(
            DynamicType.Builder<R> builder,
            EntityMetadata<T> entityMetadata) {

        return builder.defineMethod("existsById", boolean.class, Visibility.PUBLIC)
                .withParameter(Object.class, "id")
                .intercept(MethodDelegation.to(new ExistsByIdInterceptor()));
    }

    private <T, R extends MemrisRepository<T>> DynamicType.Builder<R> generateDeleteById(
            DynamicType.Builder<R> builder,
            EntityMetadata<T> entityMetadata) {

        return builder.defineMethod("deleteById", void.class, Visibility.PUBLIC)
                .withParameter(Object.class, "id")
                .intercept(MethodDelegation.to(new DeleteByIdInterceptor()));
    }

    private <T, R extends MemrisRepository<T>> DynamicType.Builder<R> generateFindAll(
            DynamicType.Builder<R> builder,
            EntityMetadata<T> entityMetadata) {

        return builder.defineMethod("findAll", List.class, Visibility.PUBLIC)
                .intercept(MethodDelegation.to(new FindAllInterceptor()));
    }

    private <T, R extends MemrisRepository<T>> DynamicType.Builder<R> generateCount(
            DynamicType.Builder<R> builder) {

        return builder.defineMethod("count", long.class, Visibility.PUBLIC)
                .intercept(MethodDelegation.to(new CountInterceptor()));
    }

    private <T, R extends MemrisRepository<T>> DynamicType.Builder<R> generateDeleteAll(
            DynamicType.Builder<R> builder,
            EntityMetadata<T> entityMetadata) {

        return builder.defineMethod("deleteAll", void.class, Visibility.PUBLIC)
                .intercept(MethodDelegation.to(new DeleteAllInterceptor()));
    }

    private <T, R extends MemrisRepository<T>> DynamicType.Builder<R> generateSave(
            DynamicType.Builder<R> builder,
            EntityMetadata<T> entityMetadata) {

        return builder.defineMethod("save", Object.class, Visibility.PUBLIC)
                .withParameter(Object.class, "entity")
                .intercept(MethodDelegation.to(new SaveInterceptor()));
    }

    private <T, R extends MemrisRepository<T>> DynamicType.Builder<R> generateUpdate(
            DynamicType.Builder<R> builder,
            EntityMetadata<T> entityMetadata) {

        return builder.defineMethod("update", void.class, Visibility.PUBLIC)
                .withParameter(Object.class, "entity")
                .intercept(MethodDelegation.to(new UpdateInterceptor()));
    }


    @SuppressWarnings("unchecked")
    private <T, R extends MemrisRepository<T>> DynamicType.Builder<R> generateQueryMethod(
            DynamicType.Builder<R> builder,
            QueryMetadata query,
            EntityMetadata<T> entityMetadata) {

        String methodName = query.methodName();
        Class<?> returnType = query.returnType();
        Class<?>[] paramTypes = query.method().getParameterTypes();

        // Add parameters
        DynamicType.Builder.MethodDefinition.ParameterDefinition<R> paramBuilder =
                builder.defineMethod(methodName, returnType, Visibility.PUBLIC);
        for (int i = 0; i < paramTypes.length; i++) {
            paramBuilder = paramBuilder.withParameter(paramTypes[i], "arg" + i);
        }

        // Use MethodDelegation to a generic query interceptor
        return paramBuilder.intercept(MethodDelegation.to(new QueryMethodInterceptor()));
    }

    // ========================================================================
    // Helper Methods
    // ========================================================================

    /**
     * Get all method names declared in the repository interface.
     * This includes both inherited methods and directly declared methods.
     */
    private Set<String> getDeclaredMethodNames(Class<?> repositoryInterface) {
        Set<String> methods = new HashSet<>();
        for (Method m : repositoryInterface.getMethods()) {
            methods.add(m.getName());
        }
        return methods;
    }

    /**
     * Check if the interface has a method with the given name.
     */
    private boolean hasMethod(Set<String> methods, String name) {
        return methods.contains(name);
    }

    /**
     * Check if the interface has a method with the given name.
     * NOTE: Parameter types are accepted for API compatibility but not checked.
     * The 'methods' set only contains method names, not full signatures.
     * This is acceptable for repository interfaces which typically don't overload methods.
     */
    private boolean hasMethod(Set<String> methods, String name, Class<?>... paramTypes) {
        return methods.contains(name);
    }

    // ========================================================================
    // Field Access Helpers
    // ========================================================================

    private static Object getFieldValue(Object thiz, String fieldName) throws Exception {
        java.lang.reflect.Field field = thiz.getClass().getDeclaredField(fieldName);
        field.setAccessible(true);
        return field.get(thiz);
    }

    private static void setFieldValue(Object thiz, String fieldName, Object value) throws Exception {
        java.lang.reflect.Field field = thiz.getClass().getDeclaredField(fieldName);
        field.setAccessible(true);
        field.set(thiz, value);
    }

    // ========================================================================
    // Interceptor Classes (MethodDelegation targets)
    // ========================================================================

    public static class ConstructorInterceptor {
        public void construct(
                @This Object thiz,
                @Argument(0) FfmTable table,
                @Argument(1) MemrisRepositoryFactory factory,
                @Argument(2) EntityMetadata<?> entityMetadata) throws Throwable {

            // Initialize all fields using reflection (only at construction time)
            setFieldValue(thiz, "table", table);
            setFieldValue(thiz, "factory", factory);
            setFieldValue(thiz, "entityClass", entityMetadata.entityClass());
            setFieldValue(thiz, "idColumnName", entityMetadata.idColumnName());
            setFieldValue(thiz, "converters", entityMetadata.converters());
            setFieldValue(thiz, "fields", entityMetadata.fields());
            setFieldValue(thiz, "fieldGetters", entityMetadata.fieldGetters());
            setFieldValue(thiz, "fieldSetters", entityMetadata.fieldSetters());
            setFieldValue(thiz, "postLoadHandle", entityMetadata.postLoadHandle());
            setFieldValue(thiz, "prePersistHandle", entityMetadata.prePersistHandle());
            setFieldValue(thiz, "preUpdateHandle", entityMetadata.preUpdateHandle());
            setFieldValue(thiz, "isRecord", entityMetadata.isRecord());
        }
    }

    public static class GetEntityClassInterceptor {
        public Class<?> getEntityClass(@This Object thiz) throws Throwable {
            return (Class<?>) getFieldValue(thiz, "entityClass");
        }
    }

    public static class FindByIdInterceptor {
        @SuppressWarnings("unchecked")
        public Optional<?> findById(
                @This Object thiz,
                @Argument(0) Object id) throws Throwable {

            FfmTable table = (FfmTable) getFieldValue(thiz, "table");
            MemrisRepositoryFactory factory = (MemrisRepositoryFactory) getFieldValue(thiz, "factory");
            Class<?> entityClass = (Class<?>) getFieldValue(thiz, "entityClass");
            String idColumnName = (String) getFieldValue(thiz, "idColumnName");
            MethodHandle postLoadHandle = (MethodHandle) getFieldValue(thiz, "postLoadHandle");
            List<?> fields = (List<?>) getFieldValue(thiz, "fields");
            Map<String, TypeConverter<?, ?>> converters = (Map<String, TypeConverter<?, ?>>) getFieldValue(thiz, "converters");
            Map<String, MethodHandle> fieldSetters = (Map<String, MethodHandle>) getFieldValue(thiz, "fieldSetters");

            // Query index (O(1))
            int[] matchingRows = factory.queryIndex(entityClass, idColumnName,
                    Predicate.Operator.EQ, id);

            if (matchingRows == null || matchingRows.length == 0) {
                return Optional.empty();
            }

            // Inline materialization - use MethodHandles instead of getDeclaredField!
            int row = matchingRows[0];
            Object entity = materializeInline(entityClass, table, row, fields, converters, fieldSetters);

            // Invoke post-load callback (pre-compiled MethodHandle)
            if (postLoadHandle != null) {
                postLoadHandle.invoke(entity);
            }

            return Optional.of(entity);
        }

        @SuppressWarnings("unchecked")
        private static Object materializeInline(Class<?> entityClass, FfmTable table, int row,
                                                List<?> fields, Map<String, TypeConverter<?, ?>> converters,
                                                Map<String, MethodHandle> fieldSetters) throws Throwable {
            Object entity = entityClass.getDeclaredConstructor().newInstance();

            for (Object fieldObj : fields) {
                EntityMetadata.FieldMapping field = (EntityMetadata.FieldMapping) fieldObj;

                // Handle foreign key columns
                if (field.name().endsWith("_id")) {
                    continue;
                }

                // Skip _msb columns (part of UUID storage)
                if (field.name().endsWith("_msb")) {
                    continue;
                }

                // Read from table using direct method call
                Object storageValue = readFromTable(table, field, row);

                // Convert using pre-compiled converter
                TypeConverter<?, ?> converter = converters.get(field.name());
                Object javaValue = (converter == null) ? storageValue
                        : ((TypeConverter<Object, Object>) converter).fromStorage(storageValue);

                // Use pre-compiled MethodHandle to set field value (NO reflection!)
                MethodHandle setter = fieldSetters.get(field.name());
                if (setter != null) {
                    setter.invoke(entity, javaValue);
                } else {
                    // Fallback for entities without explicit setters (e.g., records)
                    // This path should be rare and optimized separately
                    java.lang.reflect.Field javaField = entityClass.getDeclaredField(field.name());
                    javaField.setAccessible(true);
                    javaField.set(entity, javaValue);
                }
            }

            return entity;
        }

        private static Object readFromTable(FfmTable table, EntityMetadata.FieldMapping field, int row) {
            // Type code was pre-computed once at metadata extraction time (ZERO runtime overhead)
            int typeCode = field.typeCode();
            String columnName = field.columnName();

            return switch (typeCode) {
                case TypeCodes.TYPE_INT -> table.getInt(columnName, row);
                case TypeCodes.TYPE_LONG -> table.getLong(columnName, row);
                case TypeCodes.TYPE_BOOLEAN -> table.getBoolean(columnName, row);
                case TypeCodes.TYPE_BYTE -> table.getByte(columnName, row);
                case TypeCodes.TYPE_SHORT -> table.getShort(columnName, row);
                case TypeCodes.TYPE_FLOAT -> table.getFloat(columnName, row);
                case TypeCodes.TYPE_DOUBLE -> table.getDouble(columnName, row);
                case TypeCodes.TYPE_CHAR -> table.getChar(columnName, row);
                case TypeCodes.TYPE_STRING -> table.getString(columnName, row);
                default -> throw new IllegalArgumentException("Unsupported storage type: " + field.storageType());
            };
        }
    }

    public static class ExistsByIdInterceptor {
        public boolean existsById(
                @This Object thiz,
                @Argument(0) Object id) throws Throwable {

            MemrisRepositoryFactory factory = (MemrisRepositoryFactory) getFieldValue(thiz, "factory");
            Class<?> entityClass = (Class<?>) getFieldValue(thiz, "entityClass");
            String idColumnName = (String) getFieldValue(thiz, "idColumnName");

            int[] matchingRows = factory.queryIndex(entityClass, idColumnName,
                    Predicate.Operator.EQ, id);
            return matchingRows != null && matchingRows.length > 0;
        }
    }

    public static class DeleteByIdInterceptor {
        public void deleteById(
                @This Object thiz,
                @Argument(0) Object id) throws Throwable {

            MemrisRepositoryFactory factory = (MemrisRepositoryFactory) getFieldValue(thiz, "factory");
            Class<?> entityClass = (Class<?>) getFieldValue(thiz, "entityClass");
            String idColumnName = (String) getFieldValue(thiz, "idColumnName");

            int[] matchingRows = factory.queryIndex(entityClass, idColumnName,
                    Predicate.Operator.EQ, id);

            if (matchingRows == null || matchingRows.length == 0) {
                return; // Not found - no-op
            }

            // Remove from hash index (O(1))
            factory.getIndex(entityClass, idColumnName);
        }
    }

    public static class FindAllInterceptor {
        @SuppressWarnings("unchecked")
        public List<?> findAll(@This Object thiz) throws Throwable {

            FfmTable table = (FfmTable) getFieldValue(thiz, "table");
            Class<?> entityClass = (Class<?>) getFieldValue(thiz, "entityClass");
            MethodHandle postLoadHandle = (MethodHandle) getFieldValue(thiz, "postLoadHandle");
            List<?> fields = (List<?>) getFieldValue(thiz, "fields");
            Map<String, TypeConverter<?, ?>> converters = (Map<String, TypeConverter<?, ?>>) getFieldValue(thiz, "converters");
            Map<String, MethodHandle> fieldSetters = (Map<String, MethodHandle>) getFieldValue(thiz, "fieldSetters");

            SelectionVectorFactory factory = SelectionVectorFactory.defaultFactory();
            int[] rows = table.scanAll(factory).toIntArray();

            List<Object> results = new ArrayList<>(rows.length);
            for (int row : rows) {
                Object entity = FindByIdInterceptor.materializeInline(entityClass, table, row, fields, converters, fieldSetters);
                if (postLoadHandle != null) {
                    postLoadHandle.invoke(entity);
                }
                results.add(entity);
            }

            return results;
        }
    }

    public static class CountInterceptor {
        public long count(@This Object thiz) throws Throwable {
            FfmTable table = (FfmTable) getFieldValue(thiz, "table");
            return table.rowCount();
        }
    }

    public static class DeleteAllInterceptor {
        public void deleteAll(@This Object thiz) throws Throwable {
            Class<?> entityClass = (Class<?>) getFieldValue(thiz, "entityClass");
            MemrisRepositoryFactory factory = (MemrisRepositoryFactory) getFieldValue(thiz, "factory");
            String idColumnName = (String) getFieldValue(thiz, "idColumnName");

            if (idColumnName != null) {
                Object index = factory.getIndex(entityClass, idColumnName);
                if (index instanceof io.memris.index.HashIndex<?> hashIndex) {
                    hashIndex.clear();
                }
            }
        }
    }

    public static class SaveInterceptor {
        @SuppressWarnings("unchecked")
        public Object save(
                @This Object thiz,
                @Argument(0) Object entity) throws Throwable {

            MethodHandle prePersistHandle = (MethodHandle) getFieldValue(thiz, "prePersistHandle");
            String idColumnName = (String) getFieldValue(thiz, "idColumnName");
            List<?> fields = (List<?>) getFieldValue(thiz, "fields");
            Map<String, TypeConverter<?, ?>> converters = (Map<String, TypeConverter<?, ?>>) getFieldValue(thiz, "converters");
            FfmTable table = (FfmTable) getFieldValue(thiz, "table");
            MemrisRepositoryFactory factory = (MemrisRepositoryFactory) getFieldValue(thiz, "factory");
            Class<?> entityClass = (Class<?>) getFieldValue(thiz, "entityClass");
            Map<String, MethodHandle> fieldGetters = (Map<String, MethodHandle>) getFieldValue(thiz, "fieldGetters");
            Map<String, MethodHandle> fieldSetters = (Map<String, MethodHandle>) getFieldValue(thiz, "fieldSetters");

            // Invoke @PrePersist (pre-compiled MethodHandle)
            if (prePersistHandle != null) {
                prePersistHandle.invoke(entity);
            }

            // Build values array - use MethodHandles for field access
            Object[] values = new Object[fields.size()];
            for (int i = 0; i < fields.size(); i++) {
                EntityMetadata.FieldMapping field = (EntityMetadata.FieldMapping) fields.get(i);

                // Get field value using MethodHandle (NO reflection!)
                Object fieldValue = getFieldValueFromEntity(entity, field.name(), fieldGetters);

                // Convert using pre-compiled converter
                TypeConverter<?, ?> converter = converters.get(field.name());
                values[i] = (converter == null) ? fieldValue
                        : ((TypeConverter<Object, Object>) converter).toStorage(fieldValue);
            }

            // Insert into table
            table.insert(values);

            return entity;
        }

        private static Object getFieldValueFromEntity(Object entity, String fieldName,
                                                      Map<String, MethodHandle> fieldGetters) throws Throwable {
            MethodHandle getter = fieldGetters.get(fieldName);
            if (getter == null) {
                throw new IllegalStateException("MethodHandle not found for field: " + fieldName +
                        ". This indicates a bug in EntityMetadata - MethodHandles should be pre-compiled.");
            }
            return getter.invoke(entity);
        }
    }

    public static class UpdateInterceptor {
        @SuppressWarnings("unchecked")
        public void update(
                @This Object thiz,
                @Argument(0) Object entity) throws Throwable {

            MethodHandle preUpdateHandle = (MethodHandle) getFieldValue(thiz, "preUpdateHandle");
            String idColumnName = (String) getFieldValue(thiz, "idColumnName");
            List<?> fields = (List<?>) getFieldValue(thiz, "fields");
            Map<String, TypeConverter<?, ?>> converters = (Map<String, TypeConverter<?, ?>>) getFieldValue(thiz, "converters");
            FfmTable table = (FfmTable) getFieldValue(thiz, "table");
            MemrisRepositoryFactory factory = (MemrisRepositoryFactory) getFieldValue(thiz, "factory");
            Class<?> entityClass = (Class<?>) getFieldValue(thiz, "entityClass");
            Map<String, MethodHandle> fieldGetters = (Map<String, MethodHandle>) getFieldValue(thiz, "fieldGetters");
            Map<String, MethodHandle> fieldSetters = (Map<String, MethodHandle>) getFieldValue(thiz, "fieldSetters");

            // Invoke @PreUpdate
            if (preUpdateHandle != null) {
                preUpdateHandle.invoke(entity);
            }

            // Get ID to find existing row
            Object id = getFieldValueFromEntity(entity, idColumnName, fieldGetters);
            int[] matchingRows = factory.queryIndex(entityClass, idColumnName,
                    Predicate.Operator.EQ, id);

            if (matchingRows == null || matchingRows.length == 0) {
                return; // Not found - no-op
            }

            int row = matchingRows[0];

            // Update each field (inline!)
            for (Object fieldObj : fields) {
                EntityMetadata.FieldMapping field = (EntityMetadata.FieldMapping) fieldObj;

                // Skip ID field
                if (field.name().equals(idColumnName)) {
                    continue;
                }

                Object fieldValue = getFieldValueFromEntity(entity, field.name(), fieldGetters);

                // Convert using pre-compiled converter
                TypeConverter<?, ?> converter = converters.get(field.name());
                Object storageValue = (converter == null) ? fieldValue
                        : ((TypeConverter<Object, Object>) converter).toStorage(fieldValue);

                // Set value in table using column-based API
                setTableValue(table, field, row, storageValue);
            }
        }

        private static Object getFieldValueFromEntity(Object entity, String fieldName,
                                                      Map<String, MethodHandle> fieldGetters) throws Throwable {
            MethodHandle getter = fieldGetters.get(fieldName);
            if (getter == null) {
                throw new IllegalStateException("MethodHandle not found for field: " + fieldName +
                        ". This indicates a bug in EntityMetadata - MethodHandles should be pre-compiled.");
            }
            return getter.invoke(entity);
        }

        private static void setTableValue(FfmTable table, EntityMetadata.FieldMapping field,
                                          int row, Object value) {
            // Type code was pre-computed once at metadata extraction time (ZERO runtime overhead)
            int typeCode = field.typeCode();
            String columnName = field.columnName();

            switch (typeCode) {
                case TypeCodes.TYPE_INT -> table.setInt(columnName, row, ((Number) value).intValue());
                case TypeCodes.TYPE_LONG -> table.setLong(columnName, row, ((Number) value).longValue());
                case TypeCodes.TYPE_BOOLEAN -> table.setBoolean(columnName, row, (Boolean) value);
                case TypeCodes.TYPE_BYTE -> table.setByte(columnName, row, ((Number) value).byteValue());
                case TypeCodes.TYPE_SHORT -> table.setShort(columnName, row, ((Number) value).shortValue());
                case TypeCodes.TYPE_FLOAT -> table.setFloat(columnName, row, ((Number) value).floatValue());
                case TypeCodes.TYPE_DOUBLE -> table.setDouble(columnName, row, ((Number) value).doubleValue());
                case TypeCodes.TYPE_CHAR -> table.setChar(columnName, row, (Character) value);
                case TypeCodes.TYPE_STRING -> table.setString(columnName, row, (String) value);
                default -> throw new IllegalArgumentException("Unsupported storage type: " + field.storageType());
            }
        }
    }

    /**
     * Query method interceptor using MethodDelegation.
     * Unlike Advice, MethodDelegation doesn't try to call super() for non-existent methods.
     */
    public static class QueryMethodInterceptor {
        @SuppressWarnings("unchecked")
        public Object execute(
                @This Object thiz,
                @AllArguments Object[] args,
                @Origin java.lang.reflect.Method method) throws Throwable {

            String actualMethodName = method.getName();
            Class<?> returnType = method.getReturnType();

            FfmTable table = (FfmTable) getFieldValue(thiz, "table");
            MemrisRepositoryFactory factory = (MemrisRepositoryFactory) getFieldValue(thiz, "factory");
            Class<?> entityClass = (Class<?>) getFieldValue(thiz, "entityClass");
            List<?> fields = (List<?>) getFieldValue(thiz, "fields");
            Map<String, TypeConverter<?, ?>> converters = (Map<String, TypeConverter<?, ?>>) getFieldValue(thiz, "converters");
            MethodHandle postLoadHandle = (MethodHandle) getFieldValue(thiz, "postLoadHandle");
            Map<String, MethodHandle> fieldSetters = (Map<String, MethodHandle>) getFieldValue(thiz, "fieldSetters");

            // Parse query method name: findByAgeIn, findByAgeBetween, findByAge, countByAge, etc.
            ParsedQuery parsed = parseQueryMethodName(actualMethodName);

            if (parsed == null) {
                return returnType == long.class ? 0L : List.of();
            }

            // Execute query based on type
            int[] matchingRows = executeQuery(table, factory, entityClass, parsed, args);

            if (matchingRows == null || matchingRows.length == 0) {
                if (returnType == long.class) {
                    return 0L;
                }
                if (returnType == Optional.class) {
                    return Optional.empty();
                }
                return List.of();
            }

            // Materialize results
            List<Object> results = new ArrayList<>();
            for (int row : matchingRows) {
                Object entity = FindByIdInterceptor.materializeInline(entityClass, table, row, fields, converters, fieldSetters);
                if (postLoadHandle != null) {
                    postLoadHandle.invoke(entity);
                }
                results.add(entity);
            }

            if (returnType == Optional.class) {
                return Optional.of(results.get(0));
            }
            if (returnType == long.class) {
                return (long) results.size();
            }
            return results;
        }
    }

    /**
     * Parse query method name like:
     * - findByAge → field=age, operator=EQ
     * - findByAgeIn → field=age, operator=IN
     * - findByAgeBetween → field=age, operator=BETWEEN
     * - findByAgeGreaterThan → field=age, operator=GT
     * - countByAge → field=age, operator=EQ, isCount=true
     */
    private static ParsedQuery parseQueryMethodName(String methodName) {
        String prefix;
        boolean isCount = false;

        if (methodName.startsWith("countBy")) {
            prefix = "countBy";
            isCount = true;
        } else if (methodName.startsWith("findBy")) {
            prefix = "findBy";
        } else {
            return null;
        }

        String rest = methodName.substring(prefix.length());
        if (rest.isEmpty()) {
            return null;
        }

        String fieldName;
        String operatorType;

        // Check for suffixes: Between, In, GreaterThan, LessThan, etc.
        if (rest.endsWith("Between")) {
            fieldName = rest.substring(0, rest.length() - "Between".length());
            operatorType = "Between";
        } else if (rest.endsWith("In")) {
            fieldName = rest.substring(0, rest.length() - "In".length());
            operatorType = "In";
        } else if (rest.endsWith("NotIn")) {
            fieldName = rest.substring(0, rest.length() - "NotIn".length());
            operatorType = "NotIn";
        } else if (rest.endsWith("GreaterThan")) {
            fieldName = rest.substring(0, rest.length() - "GreaterThan".length());
            operatorType = "GreaterThan";
        } else if (rest.endsWith("LessThan")) {
            fieldName = rest.substring(0, rest.length() - "LessThan".length());
            operatorType = "LessThan";
        } else if (rest.endsWith("After")) {
            fieldName = rest.substring(0, rest.length() - "After".length());
            operatorType = "GreaterThan";
        } else if (rest.endsWith("Before")) {
            fieldName = rest.substring(0, rest.length() - "Before".length());
            operatorType = "LessThan";
        } else if (rest.endsWith("Containing")) {
            fieldName = rest.substring(0, rest.length() - "Containing".length());
            operatorType = "Containing";
        } else if (rest.endsWith("StartingWith")) {
            fieldName = rest.substring(0, rest.length() - "StartingWith".length());
            operatorType = "StartingWith";
        } else if (rest.endsWith("EndingWith")) {
            fieldName = rest.substring(0, rest.length() - "EndingWith".length());
            operatorType = "EndingWith";
        } else {
            // No suffix, just the field name - default to EQ
            fieldName = rest;
            operatorType = "Eq";
        }

        // Convert camelCase fieldName to snake_case for column names
        String columnName = camelToSnake(fieldName);

        return new ParsedQuery(columnName, operatorType, isCount);
    }

    /**
     * Convert camelCase to snake_case: customerId → customer_id
     */
    private static String camelToSnake(String camelCase) {
        if (camelCase.isEmpty()) {
            return camelCase;
        }
        StringBuilder snake = new StringBuilder();
        snake.append(Character.toLowerCase(camelCase.charAt(0)));
        for (int i = 1; i < camelCase.length(); i++) {
            char c = camelCase.charAt(i);
            if (Character.isUpperCase(c)) {
                snake.append('_').append(Character.toLowerCase(c));
            } else {
                snake.append(c);
            }
        }
        return snake.toString();
    }

    private static int[] executeQuery(FfmTable table, MemrisRepositoryFactory factory,
                                      Class<?> entityClass, ParsedQuery parsed, Object[] args) throws Throwable {

        SelectionVectorFactory svFactory = SelectionVectorFactory.defaultFactory();
        String columnName = parsed.columnName();
        String operatorType = parsed.operatorType();

        // Handle different query types
        switch (operatorType) {
            case "Between" -> {
                if (args.length < 2) return new int[0];
                Predicate minPred = new Predicate.Comparison(columnName, Predicate.Operator.GTE, args[0]);
                Predicate maxPred = new Predicate.Comparison(columnName, Predicate.Operator.LTE, args[1]);
                Predicate andPred = new Predicate.And(java.util.List.of(minPred, maxPred));
                return table.scan(andPred, svFactory).toIntArray();
            }
            case "In" -> {
                if (args.length < 1) return new int[0];
                java.util.Collection<?> values = (args[0] instanceof java.util.Collection<?> c) ? c : null;
                if (values == null) return new int[0];
                // Try index first for each value
                java.util.Set<Integer> rowSet = new java.util.HashSet<>();
                for (Object value : values) {
                    int[] rows = factory.queryIndex(entityClass, columnName, Predicate.Operator.EQ, value);
                    if (rows != null) {
                        for (int row : rows) rowSet.add(row);
                    }
                }
                if (rowSet.isEmpty()) return new int[0];
                int[] result = new int[rowSet.size()];
                int i = 0;
                for (int row : rowSet) result[i++] = row;
                return result;
            }
            case "NotIn" -> {
                if (args.length < 1) return table.scanAll(svFactory).toIntArray();
                java.util.Collection<?> values = (args[0] instanceof java.util.Collection<?> c) ? c : null;
                if (values == null) {
                    return table.scanAll(svFactory).toIntArray();
                }
                // Use IN predicate to get matching rows
                Predicate inPred = new Predicate.In(columnName, values);
                SelectionVector inRows = table.scan(inPred, svFactory);

                // Get all rows and filter out the IN matches
                SelectionVector allRows = table.scanAll(svFactory);
                MutableSelectionVector result = svFactory.create((int) (allRows.size() * 0.5));

                // Use primitive set for O(1) lookup - BitsetSelection grows dynamically
                io.memris.kernel.selection.BitsetSelection inSet =
                    new io.memris.kernel.selection.BitsetSelection();
                io.memris.kernel.selection.IntEnumerator inEnum = inRows.enumerator();
                while (inEnum.hasNext()) {
                    inSet.add(inEnum.nextInt());
                }

                // Add rows that are NOT in the set
                io.memris.kernel.selection.IntEnumerator allEnum = allRows.enumerator();
                while (allEnum.hasNext()) {
                    int row = allEnum.nextInt();
                    if (!inSet.contains(row)) {
                        result.add(row);
                    }
                }
                return result.toIntArray();
            }
            case "GreaterThan" -> {
                if (args.length < 1) return new int[0];
                Predicate pred = new Predicate.Comparison(columnName, Predicate.Operator.GT, args[0]);
                return table.scan(pred, svFactory).toIntArray();
            }
            case "LessThan" -> {
                if (args.length < 1) return new int[0];
                Predicate pred = new Predicate.Comparison(columnName, Predicate.Operator.LT, args[0]);
                return table.scan(pred, svFactory).toIntArray();
            }
            case "Containing" -> {
                if (args.length < 1) return new int[0];
                Predicate pred = new Predicate.Comparison(columnName, Predicate.Operator.CONTAINING, args[0]);
                return table.scan(pred, svFactory).toIntArray();
            }
            case "StartingWith" -> {
                if (args.length < 1) return new int[0];
                Predicate pred = new Predicate.Comparison(columnName, Predicate.Operator.STARTING_WITH, args[0]);
                return table.scan(pred, svFactory).toIntArray();
            }
            case "EndingWith" -> {
                if (args.length < 1) return new int[0];
                Predicate pred = new Predicate.Comparison(columnName, Predicate.Operator.ENDING_WITH, args[0]);
                return table.scan(pred, svFactory).toIntArray();
            }
            default -> {
                if (args.length < 1) return new int[0];
                // Try index first
                int[] rows = factory.queryIndex(entityClass, columnName, Predicate.Operator.EQ, args[0]);
                if (rows != null) return rows;
                // Fall back to scan
                Predicate pred = new Predicate.Comparison(columnName, Predicate.Operator.EQ, args[0]);
                return table.scan(pred, svFactory).toIntArray();
            }
        }
    }

    private record ParsedQuery(String columnName, String operatorType, boolean isCount) {
    }
}
