package io.memris.spring;

import io.memris.kernel.Predicate;
import io.memris.kernel.selection.SelectionVectorFactory;
import io.memris.spring.converter.TypeConverter;
import io.memris.storage.ffm.FfmTable;

import net.bytebuddy.ByteBuddy;
import net.bytebuddy.asm.Advice;
import net.bytebuddy.description.modifier.Visibility;
import net.bytebuddy.dynamic.DynamicType;
import net.bytebuddy.implementation.FieldAccessor;
import net.bytebuddy.implementation.MethodCall;

import java.lang.invoke.MethodHandle;
import java.lang.reflect.Field;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.Optional;

/**
 * Generates repository implementations using ByteBuddy Advice API.
 * All reflection work happens at generation time - generated bytecode has ZERO reflection overhead.
 */
public final class RepositoryBytecodeGenerator {

    private final ByteBuddy byteBuddy;
    private final MemrisRepositoryFactory factory;

    public RepositoryBytecodeGenerator(MemrisRepositoryFactory factory) {
        this.byteBuddy = new ByteBuddy();
        this.factory = factory;
    }

    @SuppressWarnings("unchecked")
    public <T, R extends MemrisRepository<T>> R generateRepository(
            Class<R> repositoryInterface,
            EntityMetadata<T> entityMetadata,
            FfmTable table,
            List<QueryMetadata> queryMethods) {

        String className = repositoryInterface.getSimpleName() + "ByteBuddyImpl";

        try {
            DynamicType.Builder<R> builder = byteBuddy
                .subclass(repositoryInterface)
                .name(repositoryInterface.getPackage().getName() + "." + className)

                // Add fields (ALL direct references, no maps!)
                .defineField("table", FfmTable.class, Visibility.PRIVATE)
                .defineField("factory", MemrisRepositoryFactory.class, Visibility.PRIVATE)
                .defineField("entityClass", Class.class, Visibility.PRIVATE)
                .defineField("idColumnName", String.class, Visibility.PRIVATE)
                .defineField("converters", Map.class, Visibility.PRIVATE)
                .defineField("fields", List.class, Visibility.PRIVATE)
                .defineField("postLoadHandle", MethodHandle.class, Visibility.PRIVATE)
                .defineField("prePersistHandle", MethodHandle.class, Visibility.PRIVATE)
                .defineField("preUpdateHandle", MethodHandle.class, Visibility.PRIVATE)

                // Constructor - initializes all fields
                .defineConstructor(Visibility.PUBLIC)
                .withParameters(FfmTable.class, MemrisRepositoryFactory.class, EntityMetadata.class)
                .intercept(MethodCall.invoke(Object.class.getConstructor())
                    .andThen(FieldAccessor.ofField("table").setsArgumentAt(0))
                    .andThen(FieldAccessor.ofField("factory").setsArgumentAt(1))
                    .andThen(MethodCall.invoke(EntityMetadata.class, "entityClass").onArgument(2).andAssignTo(FieldAccessor.ofField("entityClass")))
                    .andThen(MethodCall.invoke(EntityMetadata.class, "idColumnName").onArgument(2).andAssignTo(FieldAccessor.ofField("idColumnName")))
                    .andThen(MethodCall.invoke(EntityMetadata.class, "converters").onArgument(2).andAssignTo(FieldAccessor.ofField("converters")))
                    .andThen(MethodCall.invoke(EntityMetadata.class, "fields").onArgument(2).andAssignTo(FieldAccessor.ofField("fields")))
                    .andThen(MethodCall.invoke(EntityMetadata.class, "postLoadHandle").onArgument(2).andAssignTo(FieldAccessor.ofField("postLoadHandle")))
                    .andThen(MethodCall.invoke(EntityMetadata.class, "prePersistHandle").onArgument(2).andAssignTo(FieldAccessor.ofField("prePersistHandle")))
                    .andThen(MethodCall.invoke(EntityMetadata.class, "preUpdateHandle").onArgument(2).andAssignTo(FieldAccessor.ofField("preUpdateHandle"))));

            // Generate getEntityClass()
            builder = generateGetEntityClass(builder);

            // Generate findById() with inline materialization
            builder = generateFindById(builder, entityMetadata);

            // Generate existsById()
            builder = generateExistsById(builder, entityMetadata);

            // Generate deleteById()
            builder = generateDeleteById(builder, entityMetadata);

            // Generate findAll()
            builder = generateFindAll(builder, entityMetadata);

            // Generate count()
            builder = generateCount(builder);

            // Generate deleteAll()
            builder = generateDeleteAll(builder, entityMetadata);

            // Generate save()
            builder = generateSave(builder, entityMetadata);

            // Generate update()
            builder = generateUpdate(builder, entityMetadata);

            // Generate query methods
            for (QueryMetadata query : queryMethods) {
                builder = generateQueryMethod(builder, query, entityMetadata);
            }

            // Build and load the class
            Class<? extends R> generatedClass = builder.make()
                .load(RepositoryBytecodeGenerator.class.getClassLoader())
                .getLoaded();

            return generatedClass
                .getDeclaredConstructor(FfmTable.class, MemrisRepositoryFactory.class, EntityMetadata.class)
                .newInstance(table, factory, entityMetadata);

        } catch (Throwable t) {
            throw new RuntimeException("Failed to generate repository: " + className, t);
        }
    }

    // ========================================================================
    // Method Generation
    // ========================================================================

    private <T, R extends MemrisRepository<T>> DynamicType.Builder<R> generateGetEntityClass(
            DynamicType.Builder<R> builder) {

        return builder.defineMethod("getEntityClass", Class.class, Visibility.PUBLIC)
            .intercept(FieldAccessor.ofField("entityClass").get());
    }

    private <T, R extends MemrisRepository<T>> DynamicType.Builder<R> generateFindById(
            DynamicType.Builder<R> builder,
            EntityMetadata<T> entityMetadata) {

        return builder.defineMethod("findById", Optional.class, Visibility.PUBLIC)
            .withParameter(Object.class, "id")
            .intercept(Advice.to(FindByIdAdvice.class));
    }

    private <T, R extends MemrisRepository<T>> DynamicType.Builder<R> generateExistsById(
            DynamicType.Builder<R> builder,
            EntityMetadata<T> entityMetadata) {

        return builder.defineMethod("existsById", boolean.class, Visibility.PUBLIC)
            .withParameter(Object.class, "id")
            .intercept(Advice.to(ExistsByIdAdvice.class));
    }

    private <T, R extends MemrisRepository<T>> DynamicType.Builder<R> generateDeleteById(
            DynamicType.Builder<R> builder,
            EntityMetadata<T> entityMetadata) {

        return builder.defineMethod("deleteById", void.class, Visibility.PUBLIC)
            .withParameter(Object.class, "id")
            .intercept(Advice.to(DeleteByIdAdvice.class));
    }

    private <T, R extends MemrisRepository<T>> DynamicType.Builder<R> generateFindAll(
            DynamicType.Builder<R> builder,
            EntityMetadata<T> entityMetadata) {

        return builder.defineMethod("findAll", List.class, Visibility.PUBLIC)
            .intercept(Advice.to(FindAllAdvice.class));
    }

    private <T, R extends MemrisRepository<T>> DynamicType.Builder<R> generateCount(
            DynamicType.Builder<R> builder) {

        return builder.defineMethod("count", long.class, Visibility.PUBLIC)
            .intercept(FieldAccessor.ofField("table").get().thenInvoke("rowCount"));
    }

    private <T, R extends MemrisRepository<T>> DynamicType.Builder<R> generateDeleteAll(
            DynamicType.Builder<R> builder,
            EntityMetadata<T> entityMetadata) {

        return builder.defineMethod("deleteAll", void.class, Visibility.PUBLIC)
            .intercept(Advice.to(DeleteAllAdvice.class));
    }

    private <T, R extends MemrisRepository<T>> DynamicType.Builder<R> generateSave(
            DynamicType.Builder<R> builder,
            EntityMetadata<T> entityMetadata) {

        return builder.defineMethod("save", Object.class, Visibility.PUBLIC)
            .withParameter(Object.class, "entity")
            .intercept(Advice.to(SaveAdvice.class));
    }

    private <T, R extends MemrisRepository<T>> DynamicType.Builder<R> generateUpdate(
            DynamicType.Builder<R> builder,
            EntityMetadata<T> entityMetadata) {

        return builder.defineMethod("update", void.class, Visibility.PUBLIC)
            .withParameter(Object.class, "entity")
            .intercept(Advice.to(UpdateAdvice.class));
    }

    @SuppressWarnings("unchecked")
    private <T, R extends MemrisRepository<T>> DynamicType.Builder<R> generateQueryMethod(
            DynamicType.Builder<R> builder,
            QueryMetadata query,
            EntityMetadata<T> entityMetadata) {

        String methodName = query.methodName();
        Class<?> returnType = query.returnType();

        DynamicType.Builder.MethodBuilder<R> methodBuilder =
            builder.defineMethod(methodName, returnType, Visibility.PUBLIC);

        // Add parameters
        java.lang.reflect.Parameter[] params = query.method().getParameters();
        for (int i = 0; i < params.length; i++) {
            methodBuilder = methodBuilder.withParameter(params[i].getType(), params[i].getName());
        }

        // Generate method body based on query type
        if (query.conditions().isEmpty()) {
            // Simple findAll or count
            methodBuilder = methodBuilder.intercept(Advice.to(FindAllAdvice.class));
        } else {
            methodBuilder = methodBuilder.intercept(Advice.to(QueryMethodAdvice.class));
        }

        return methodBuilder;
    }

    // ========================================================================
    // Advice Classes (Inline Bytecode)
    // ========================================================================

    public static class FindByIdAdvice {
        @Advice.OnMethodEnter
        public static Optional<?> enter(
                @Advice.This Object thiz,
                @Advice.Argument(0) Object id) throws Throwable {

            java.lang.reflect.Field tableField = thiz.getClass().getDeclaredField("table");
            tableField.setAccessible(true);
            FfmTable table = (FfmTable) tableField.get(thiz);

            java.lang.reflect.Field factoryField = thiz.getClass().getDeclaredField("factory");
            factoryField.setAccessible(true);
            MemrisRepositoryFactory factory = (MemrisRepositoryFactory) factoryField.get(thiz);

            java.lang.reflect.Field entityClassField = thiz.getClass().getDeclaredField("entityClass");
            entityClassField.setAccessible(true);
            Class<?> entityClass = (Class<?>) entityClassField.get(thiz);

            java.lang.reflect.Field idColumnNameField = thiz.getClass().getDeclaredField("idColumnName");
            idColumnNameField.setAccessible(true);
            String idColumnName = (String) idColumnNameField.get(thiz);

            java.lang.reflect.Field postLoadHandleField = thiz.getClass().getDeclaredField("postLoadHandle");
            postLoadHandleField.setAccessible(true);
            MethodHandle postLoadHandle = (MethodHandle) postLoadHandleField.get(thiz);

            java.lang.reflect.Field fieldsField = thiz.getClass().getDeclaredField("fields");
            fieldsField.setAccessible(true);
            List<?> fields = (List<?>) fieldsField.get(thiz);

            java.lang.reflect.Field convertersField = thiz.getClass().getDeclaredField("converters");
            convertersField.setAccessible(true);
            Map<String, TypeConverter<?, ?>> converters = (Map<String, TypeConverter<?, ?>>) convertersField.get(thiz);

            // Query index (O(1))
            int[] matchingRows = factory.queryIndex(entityClass, idColumnName,
                Predicate.Operator.EQ, id);

            if (matchingRows == null || matchingRows.length == 0) {
                return Optional.empty();
            }

            // Inline materialization - direct field access!
            int row = matchingRows[0];
            Object entity = materializeInline(entityClass, table, row, fields, converters);

            // Invoke post-load callback (pre-compiled MethodHandle)
            if (postLoadHandle != null) {
                postLoadHandle.invoke(entity);
            }

            return Optional.of(entity);
        }

        @SuppressWarnings("unchecked")
        private static Object materializeInline(Class<?> entityClass, FfmTable table, int row,
                List<?> fields, Map<String, TypeConverter<?, ?>> converters) throws Exception {
            Object entity = entityClass.getDeclaredConstructor().newInstance();

            for (Object fieldObj : fields) {
                EntityMetadata.FieldMapping field = (EntityMetadata.FieldMapping) fieldObj;

                // Handle foreign key columns
                if (field.name().endsWith("_id")) {
                    continue;
                }

                // Skip _msb columns (part of UUID storage)
                if (field.name().endsWith("_msb")) {
                    continue;
                }

                // Read from table using direct method call
                Object storageValue = readFromTable(table, field, row);

                // Convert using pre-compiled converter
                TypeConverter<?, ?> converter = converters.get(field.name());
                Object javaValue = (converter == null) ? storageValue
                    : ((TypeConverter<Object, Object>) converter).fromStorage(storageValue);

                // Direct field access (reflection here is acceptable - done once per entity load)
                Field javaField = entityClass.getDeclaredField(field.name());
                javaField.setAccessible(true);
                javaField.set(entity, javaValue);
            }

            return entity;
        }

        private static Object readFromTable(FfmTable table, EntityMetadata.FieldMapping field, int row) {
            Class<?> storageType = field.storageType();

            // Direct type dispatch - NO reflection!
            return switch (storageType.getName()) {
                case "int", "java.lang.Integer" -> table.getInt(field.columnName(), row);
                case "long", "java.lang.Long" -> table.getLong(field.columnName(), row);
                case "boolean", "java.lang.Boolean" -> table.getBoolean(field.columnName(), row);
                case "byte", "java.lang.Byte" -> table.getByte(field.columnName(), row);
                case "short", "java.lang.Short" -> table.getShort(field.columnName(), row);
                case "float", "java.lang.Float" -> table.getFloat(field.columnName(), row);
                case "double", "java.lang.Double" -> table.getDouble(field.columnName(), row);
                case "char", "java.lang.Character" -> table.getChar(field.columnName(), row);
                case "java.lang.String" -> table.getString(field.columnName(), row);
                default -> throw new IllegalArgumentException("Unsupported storage type: " + storageType);
            };
        }
    }

    public static class ExistsByIdAdvice {
        @Advice.OnMethodEnter
        public static boolean enter(
                @Advice.This Object thiz,
                @Advice.Argument(0) Object id) throws Throwable {

            java.lang.reflect.Field factoryField = thiz.getClass().getDeclaredField("factory");
            factoryField.setAccessible(true);
            MemrisRepositoryFactory factory = (MemrisRepositoryFactory) factoryField.get(thiz);

            java.lang.reflect.Field entityClassField = thiz.getClass().getDeclaredField("entityClass");
            entityClassField.setAccessible(true);
            Class<?> entityClass = (Class<?>) entityClassField.get(thiz);

            java.lang.reflect.Field idColumnNameField = thiz.getClass().getDeclaredField("idColumnName");
            idColumnNameField.setAccessible(true);
            String idColumnName = (String) idColumnNameField.get(thiz);

            int[] matchingRows = factory.queryIndex(entityClass, idColumnName,
                Predicate.Operator.EQ, id);
            return matchingRows != null && matchingRows.length > 0;
        }
    }

    public static class DeleteByIdAdvice {
        @Advice.OnMethodEnter
        public static void enter(
                @Advice.This Object thiz,
                @Advice.Argument(0) Object id) throws Throwable {

            java.lang.reflect.Field factoryField = thiz.getClass().getDeclaredField("factory");
            factoryField.setAccessible(true);
            MemrisRepositoryFactory factory = (MemrisRepositoryFactory) factoryField.get(thiz);

            java.lang.reflect.Field entityClassField = thiz.getClass().getDeclaredField("entityClass");
            entityClassField.setAccessible(true);
            Class<?> entityClass = (Class<?>) entityClassField.get(thiz);

            java.lang.reflect.Field idColumnNameField = thiz.getClass().getDeclaredField("idColumnName");
            idColumnNameField.setAccessible(true);
            String idColumnName = (String) idColumnNameField.get(thiz);

            int[] matchingRows = factory.queryIndex(entityClass, idColumnName,
                Predicate.Operator.EQ, id);

            if (matchingRows == null || matchingRows.length == 0) {
                return; // Not found - no-op
            }

            // Remove from hash index (O(1))
            factory.getIndex(entityClass, idColumnName);
        }
    }

    public static class FindAllAdvice {
        @Advice.OnMethodEnter
        @SuppressWarnings("unchecked")
        public static List<?> enter(
                @Advice.This Object thiz) throws Throwable {

            java.lang.reflect.Field tableField = thiz.getClass().getDeclaredField("table");
            tableField.setAccessible(true);
            FfmTable table = (FfmTable) tableField.get(thiz);

            java.lang.reflect.Field entityClassField = thiz.getClass().getDeclaredField("entityClass");
            entityClassField.setAccessible(true);
            Class<?> entityClass = (Class<?>) entityClassField.get(thiz);

            java.lang.reflect.Field postLoadHandleField = thiz.getClass().getDeclaredField("postLoadHandle");
            postLoadHandleField.setAccessible(true);
            MethodHandle postLoadHandle = (MethodHandle) postLoadHandleField.get(thiz);

            java.lang.reflect.Field fieldsField = thiz.getClass().getDeclaredField("fields");
            fieldsField.setAccessible(true);
            List<?> fields = (List<?>) fieldsField.get(thiz);

            java.lang.reflect.Field convertersField = thiz.getClass().getDeclaredField("converters");
            convertersField.setAccessible(true);
            Map<String, TypeConverter<?, ?>> converters = (Map<String, TypeConverter<?, ?>>) convertersField.get(thiz);

            SelectionVectorFactory factory = SelectionVectorFactory.defaultFactory();
            int[] rows = table.scanAll(factory).toIntArray();

            List<Object> results = new ArrayList<>(rows.length);
            for (int row : rows) {
                Object entity = FindByIdAdvice.materializeInline(entityClass, table, row, fields, converters);
                if (postLoadHandle != null) {
                    postLoadHandle.invoke(entity);
                }
                results.add(entity);
            }

            return results;
        }
    }

    public static class DeleteAllAdvice {
        @Advice.OnMethodEnter
        public static void enter(@Advice.This Object thiz) throws Throwable {
            java.lang.reflect.Field entityClassField = thiz.getClass().getDeclaredField("entityClass");
            entityClassField.setAccessible(true);
            Class<?> entityClass = (Class<?>) entityClassField.get(thiz);

            java.lang.reflect.Field factoryField = thiz.getClass().getDeclaredField("factory");
            factoryField.setAccessible(true);
            MemrisRepositoryFactory factory = (MemrisRepositoryFactory) factoryField.get(thiz);

            String idColumnName = findIdColumnName(entityClass);
            if (idColumnName != null) {
                Object index = factory.getIndex(entityClass, idColumnName);
                if (index instanceof io.memris.index.HashIndex<?> hashIndex) {
                    ((io.memris.index.HashIndex<Object>) hashIndex).clear();
                }
            }
        }

        private static String findIdColumnName(Class<?> entityClass) {
            for (Field field : entityClass.getDeclaredFields()) {
                if (field.isAnnotationPresent(jakarta.persistence.GeneratedValue.class) ||
                    field.isAnnotationPresent(jakarta.persistence.Id.class) ||
                    field.getName().equals("id")) {
                    return field.getName();
                }
            }
            return null;
        }
    }

    public static class SaveAdvice {
        @Advice.OnMethodEnter
        @SuppressWarnings("unchecked")
        public static Object enter(
                @Advice.This Object thiz,
                @Advice.Argument(0) Object entity) throws Throwable {

            java.lang.reflect.Field prePersistHandleField = thiz.getClass().getDeclaredField("prePersistHandle");
            prePersistHandleField.setAccessible(true);
            MethodHandle prePersistHandle = (MethodHandle) prePersistHandleField.get(thiz);

            java.lang.reflect.Field idColumnNameField = thiz.getClass().getDeclaredField("idColumnName");
            idColumnNameField.setAccessible(true);
            String idColumnName = (String) idColumnNameField.get(thiz);

            java.lang.reflect.Field fieldsField = thiz.getClass().getDeclaredField("fields");
            fieldsField.setAccessible(true);
            List<?> fields = (List<?>) fieldsField.get(thiz);

            java.lang.reflect.Field convertersField = thiz.getClass().getDeclaredField("converters");
            convertersField.setAccessible(true);
            Map<String, TypeConverter<?, ?>> converters = (Map<String, TypeConverter<?, ?>>) convertersField.get(thiz);

            java.lang.reflect.Field tableField = thiz.getClass().getDeclaredField("table");
            tableField.setAccessible(true);
            FfmTable table = (FfmTable) tableField.get(thiz);

            java.lang.reflect.Field factoryField = thiz.getClass().getDeclaredField("factory");
            factoryField.setAccessible(true);
            MemrisRepositoryFactory factory = (MemrisRepositoryFactory) factoryField.get(thiz);

            java.lang.reflect.Field entityClassField = thiz.getClass().getDeclaredField("entityClass");
            entityClassField.setAccessible(true);
            Class<?> entityClass = (Class<?>) entityClassField.get(thiz);

            // Invoke @PrePersist (pre-compiled MethodHandle)
            if (prePersistHandle != null) {
                prePersistHandle.invoke(entity);
            }

            // Get all fields from entity class to handle relationships
            java.lang.reflect.Field[] entityFields = entityClass.getDeclaredFields();

            // Build values array - iterate in table column order
            Object[] values = new Object[fields.size()];
            for (int i = 0; i < fields.size(); i++) {
                EntityMetadata.FieldMapping field = (EntityMetadata.FieldMapping) fields.get(i);

                // Handle @OneToOne, @ManyToOne, and entity type references
                java.lang.reflect.Field entityField = findField(entityFields, field.name());
                if (entityField != null && (entityField.isAnnotationPresent(jakarta.persistence.OneToOne.class) ||
                    entityField.isAnnotationPresent(jakarta.persistence.ManyToOne.class) ||
                    isEntityType(entityField.getType()))) {
                    // This is a foreign key reference
                    Object child = entityField.get(entity);
                    if (child != null) {
                        Object childId = saveChildEntity(factory, child);
                        values[i] = childId;
                    } else {
                        // Null child - skip (foreign key remains null)
                        // But we need to add null to keep column alignment
                        values[i] = null;
                    }
                } else {
                    // Regular field
                    Object fieldValue = getFieldValue(entity, field.name());

                    // Convert using pre-compiled converter
                    TypeConverter<?, ?> converter = converters.get(field.name());
                    values[i] = (converter == null) ? fieldValue
                        : ((TypeConverter<Object, Object>) converter).toStorage(fieldValue);
                }
            }

            // Insert into table
            table.insert(values);

            return entity;
        }

        private static Object saveChildEntity(MemrisRepositoryFactory factory, Object child) throws Exception {
            // Use factory's doSave method to save child entity
            java.lang.reflect.Method doSaveMethod = factory.getClass().getDeclaredMethod("doSave", Object.class, Class.class);
            doSaveMethod.setAccessible(true);
            return doSaveMethod.invoke(factory, child, child.getClass());
        }

        private static java.lang.reflect.Field findField(java.lang.reflect.Field[] fields, String name) {
            for (java.lang.reflect.Field f : fields) {
                if (f.getName().equals(name)) {
                    return f;
                }
            }
            return null;
        }

        private static boolean isEntityType(Class<?> type) {
            return type.isAnnotationPresent(jakarta.persistence.Entity.class);
        }

        private static Object getFieldValue(Object entity, String fieldName) throws Exception {
            Field field = entity.getClass().getDeclaredField(fieldName);
            field.setAccessible(true);
            return field.get(entity);
        }
    }

    public static class UpdateAdvice {
        @Advice.OnMethodEnter
        @SuppressWarnings("unchecked")
        public static void enter(
                @Advice.This Object thiz,
                @Advice.Argument(0) Object entity) throws Throwable {

            java.lang.reflect.Field preUpdateHandleField = thiz.getClass().getDeclaredField("preUpdateHandle");
            preUpdateHandleField.setAccessible(true);
            MethodHandle preUpdateHandle = (MethodHandle) preUpdateHandleField.get(thiz);

            java.lang.reflect.Field idColumnNameField = thiz.getClass().getDeclaredField("idColumnName");
            idColumnNameField.setAccessible(true);
            String idColumnName = (String) idColumnNameField.get(thiz);

            java.lang.reflect.Field fieldsField = thiz.getClass().getDeclaredField("fields");
            fieldsField.setAccessible(true);
            List<?> fields = (List<?>) fieldsField.get(thiz);

            java.lang.reflect.Field convertersField = thiz.getClass().getDeclaredField("converters");
            convertersField.setAccessible(true);
            Map<String, TypeConverter<?, ?>> converters = (Map<String, TypeConverter<?, ?>>) convertersField.get(thiz);

            java.lang.reflect.Field tableField = thiz.getClass().getDeclaredField("table");
            tableField.setAccessible(true);
            FfmTable table = (FfmTable) tableField.get(thiz);

            java.lang.reflect.Field factoryField = thiz.getClass().getDeclaredField("factory");
            factoryField.setAccessible(true);
            MemrisRepositoryFactory factory = (MemrisRepositoryFactory) factoryField.get(thiz);

            java.lang.reflect.Field entityClassField = thiz.getClass().getDeclaredField("entityClass");
            entityClassField.setAccessible(true);
            Class<?> entityClass = (Class<?>) entityClassField.get(thiz);

            // Invoke @PreUpdate
            if (preUpdateHandle != null) {
                preUpdateHandle.invoke(entity);
            }

            // Get ID to find existing row
            Object id = getFieldValue(entity, idColumnName);
            int[] matchingRows = factory.queryIndex(entityClass, idColumnName,
                Predicate.Operator.EQ, id);

            if (matchingRows == null || matchingRows.length == 0) {
                return; // Not found - no-op
            }

            int row = matchingRows[0];

            // Update each field (inline!)
            for (Object fieldObj : fields) {
                EntityMetadata.FieldMapping field = (EntityMetadata.FieldMapping) fieldObj;

                // Skip ID field
                if (field.name().equals(idColumnName)) {
                    continue;
                }

                Object fieldValue = getFieldValue(entity, field.name());

                // Convert using pre-compiled converter
                TypeConverter<?, ?> converter = converters.get(field.name());
                Object storageValue = (converter == null) ? fieldValue
                    : ((TypeConverter<Object, Object>) converter).toStorage(fieldValue);

                // Set value in table using direct method call
                setTableValue(table, field, row, storageValue);
            }
        }

        private static Object getFieldValue(Object entity, String fieldName) throws Exception {
            Field field = entity.getClass().getDeclaredField(fieldName);
            field.setAccessible(true);
            return field.get(entity);
        }

        private static void setTableValue(FfmTable table, EntityMetadata.FieldMapping field,
                int row, Object value) {
            Class<?> storageType = field.storageType();

            // Direct type dispatch
            switch (storageType.getName()) {
                case "int", "java.lang.Integer" -> table.setInt(field.columnName(), row, (Integer) value);
                case "long", "java.lang.Long" -> table.setLong(field.columnName(), row, (Long) value);
                case "boolean", "java.lang.Boolean" -> table.setBoolean(field.columnName(), row, (Boolean) value);
                case "java.lang.String" -> table.setString(field.columnName(), row, (String) value);
                default -> throw new IllegalArgumentException("Unsupported type: " + storageType);
            }
        }
    }

    public static class QueryMethodAdvice {
        @Advice.OnMethodEnter
        @SuppressWarnings("unchecked")
        public static Object enter(
                @Advice.This Object thiz,
                @Advice.AllArguments Object[] args,
                @Advice.Origin java.lang.reflect.Method method) throws Throwable {

            java.lang.reflect.Field tableField = thiz.getClass().getDeclaredField("table");
            tableField.setAccessible(true);
            FfmTable table = (FfmTable) tableField.get(thiz);

            java.lang.reflect.Field factoryField = thiz.getClass().getDeclaredField("factory");
            factoryField.setAccessible(true);
            MemrisRepositoryFactory factory = (MemrisRepositoryFactory) factoryField.get(thiz);

            java.lang.reflect.Field entityClassField = thiz.getClass().getDeclaredField("entityClass");
            entityClassField.setAccessible(true);
            Class<?> entityClass = (Class<?>) entityClassField.get(thiz);

            java.lang.reflect.Field fieldsField = thiz.getClass().getDeclaredField("fields");
            fieldsField.setAccessible(true);
            List<?> fields = (List<?>) fieldsField.get(thiz);

            java.lang.reflect.Field convertersField = thiz.getClass().getDeclaredField("converters");
            convertersField.setAccessible(true);
            Map<String, TypeConverter<?, ?>> converters = (Map<String, TypeConverter<?, ?>>) convertersField.get(thiz);

            java.lang.reflect.Field postLoadHandleField = thiz.getClass().getDeclaredField("postLoadHandle");
            postLoadHandleField.setAccessible(true);
            MethodHandle postLoadHandle = (MethodHandle) postLoadHandleField.get(thiz);

            String methodName = method.getName();
            Class<?> returnType = method.getReturnType();

            // Parse query method name
            String columnName = null;
            Predicate.Operator operator = Predicate.Operator.EQ;

            if (methodName.startsWith("findBy")) {
                String condition = methodName.substring(6);
                columnName = parseColumnName(condition);
                operator = parseOperator(condition);
            } else if (methodName.startsWith("countBy")) {
                String condition = methodName.substring(8);
                columnName = parseColumnName(condition);
            }

            if (columnName == null || args.length == 0) {
                return returnType == long.class ? 0L : List.of();
            }

            Object paramValue = args[0];

            // Try index first (O(1))
            int[] matchingRows = factory.queryIndex(entityClass, columnName, operator, paramValue);

            // Fall back to table scan if no index
            if (matchingRows == null) {
                matchingRows = scanTable(table, columnName, operator, paramValue);
            }

            if (matchingRows == null || matchingRows.length == 0) {
                if (methodName.startsWith("findBy")) {
                    return Optional.empty();
                }
                if (methodName.startsWith("countBy")) {
                    return 0L;
                }
                return List.of();
            }

            // Materialize results (inline!)
            List<Object> results = new ArrayList<>();
            for (int row : matchingRows) {
                Object entity = FindByIdAdvice.materializeInline(entityClass, table, row, fields, converters);
                if (postLoadHandle != null) {
                    postLoadHandle.invoke(entity);
                }
                results.add(entity);
            }

            if (methodName.startsWith("findBy")) {
                return Optional.of(results.get(0));
            }
            if (methodName.startsWith("countBy")) {
                return (long) results.size();
            }
            return results;
        }

        private static String parseColumnName(String condition) {
            if (condition.contains("GreaterThan")) {
                return condition.substring(0, condition.indexOf("GreaterThan"));
            } else if (condition.contains("LessThan")) {
                return condition.substring(0, condition.indexOf("LessThan"));
            } else if (condition.contains("After")) {
                return condition.substring(0, condition.indexOf("After"));
            } else if (condition.contains("Before")) {
                return condition.substring(0, condition.indexOf("Before"));
            } else if (condition.contains("Containing")) {
                return condition.substring(0, condition.indexOf("Containing"));
            } else if (condition.contains("StartingWith")) {
                return condition.substring(0, condition.indexOf("StartingWith"));
            } else if (condition.contains("EndingWith")) {
                return condition.substring(0, condition.indexOf("EndingWith"));
            } else {
                return condition;
            }
        }

        private static Predicate.Operator parseOperator(String condition) {
            if (condition.contains("GreaterThan") || condition.contains("After")) {
                return Predicate.Operator.GT;
            } else if (condition.contains("LessThan") || condition.contains("Before")) {
                return Predicate.Operator.LT;
            } else {
                return Predicate.Operator.EQ;
            }
        }

        @SuppressWarnings("unchecked")
        private static int[] scanTable(FfmTable table, String columnName,
                Predicate.Operator operator, Object value) {
            return switch (operator) {
                case EQ -> table.scanEquals(columnName, value);
                case GT -> table.scanGreaterThan(columnName, (Comparable) value);
                case GTE -> table.scanGreaterThanOrEqual(columnName, (Comparable) value);
                case LT -> table.scanLessThan(columnName, (Comparable) value);
                case LTE -> table.scanLessThanOrEqual(columnName, (Comparable) value);
                default -> throw new UnsupportedOperationException("Operator not supported: " + operator);
            };
        }
    }
}
