package io.memris.spring.scaffold;

import java.lang.reflect.Method;
import java.util.Optional;

import io.memris.spring.plan.CompiledQuery;
import io.memris.spring.plan.LogicalQuery.ReturnKind;
import io.memris.spring.runtime.RepositoryRuntime;

import net.bytebuddy.ByteBuddy;
import net.bytebuddy.implementation.bind.annotation.This;
import net.bytebuddy.description.modifier.FieldManifestation;
import net.bytebuddy.description.modifier.Visibility;
import net.bytebuddy.dynamic.DynamicType;
import net.bytebuddy.implementation.FieldAccessor;
import net.bytebuddy.implementation.MethodDelegation;
import net.bytebuddy.implementation.bind.annotation.AllArguments;
import net.bytebuddy.implementation.bind.annotation.RuntimeType;

/**
 * Generates repository implementation class using ByteBuddy.
 * <p>
 * The generated class:
 * - Has one field: `private final RepositoryRuntime rt;`
 * - Has one constructor: `(RepositoryRuntime rt) { this.rt = rt; }`
 * - Has query methods as thin stubs that call runtime entrypoints with constant queryId
 * <p>
 * Positional binding is used: methods from RepositoryMethodIntrospector are aligned
 * positionally with CompiledQuery[] from RepositoryRuntime.plan().queries().
 * <p>
 * Example generated code:
 * <pre>{@code
 * public class PersonRepository$MemrisImpl implements PersonRepository {
 *   private final RepositoryRuntime rt;
 *
 *   public PersonRepository$MemrisImpl(RepositoryRuntime rt) {
 *     this.rt = rt;
 *   }
 *
 *   public Optional<Person> findById(Long id) {
 *     return rt.optional1(0, id);  // queryId=0, constant (positionally bound)
 *   }
 *
 *   public List<Person> findByName(String name) {
 *     return rt.list1(1, name);  // queryId=1, constant
 *   }
 *
 *   public long countByAge(int age) {
 *     return rt.count1(2, age);  // queryId=2, constant
 *   }
 * }
 * }</pre>
 * <p>
 * <b>Key optimization:</b> queryId is a constant embedded in the generated bytecode,
 * enabling O(1) array lookup in RepositoryRuntime without any runtime parsing.
 * <p>
 * <b>Positional binding:</b> The i-th method from RepositoryMethodIntrospector
 * corresponds to the i-th CompiledQuery in the plan. This eliminates the need
 * for methodName-based lookup.
 */
public final class RepositoryEmitter {

    private final ByteBuddy byteBuddy = new ByteBuddy();

    /**
     * Emit and instantiate a repository implementation.
     * <p>
     * Uses positional binding: methods are extracted from the interface in
     * deterministic order and matched positionally with compiled queries.
     *
     * @param repositoryInterface the repository interface to implement
     * @param runtime the pre-built RepositoryRuntime (contains RepositoryPlan with queries)
     * @return an instantiated repository instance
     */
    @SuppressWarnings("unchecked")
    public <T, R> R emitAndInstantiate(
            Class<R> repositoryInterface,
            RepositoryRuntime<T> runtime) {

        String implClassName = repositoryInterface.getSimpleName() + "$MemrisImpl";

        try {
            DynamicType.Builder<?> builder = byteBuddy
                    .subclass(repositoryInterface)
                    .name(repositoryInterface.getPackage().getName() + "." + implClassName);

            // Add runtime field
            builder = builder.defineField("rt", RepositoryRuntime.class, Visibility.PRIVATE, FieldManifestation.FINAL);

            // Add constructor: calls super() then sets the field
            builder = builder.defineConstructor(Visibility.PUBLIC)
                    .withParameters(RepositoryRuntime.class)
                    .intercept(net.bytebuddy.implementation.MethodCall.invoke(Object.class.getDeclaredConstructor())
                            .andThen(FieldAccessor.ofField("rt").setsArgumentAt(0)));

            // Get methods and queries (positional binding)
            Method[] methods = RepositoryMethodIntrospector.extractQueryMethods(repositoryInterface);
            CompiledQuery[] queries = runtime.plan().queries();

            // Validate arrays match
            if (methods.length != queries.length) {
                throw new IllegalStateException(
                    "Method count mismatch: " + methods.length + " methods vs " + queries.length + " queries");
            }

            // Add query methods using positional binding
            for (int queryId = 0; queryId < methods.length; queryId++) {
                Method method = methods[queryId];
                CompiledQuery cq = queries[queryId];
                builder = defineQueryMethod(builder, method, queryId, cq.returnKind());
            }

            // Build and load using injection strategy to avoid classloader isolation
            DynamicType.Unloaded<?> unloaded = builder.make();
            Class<?> generatedClass = unloaded.load(
                    repositoryInterface.getClassLoader(),
                    net.bytebuddy.dynamic.loading.ClassLoadingStrategy.Default.INJECTION
            ).getLoaded();

            // Instantiate with runtime
            return (R) generatedClass.getDeclaredConstructor(RepositoryRuntime.class)
                    .newInstance(runtime);

        } catch (Throwable t) {
            throw new RuntimeException("Failed to generate repository: " + implClassName, t);
        }
    }

    /**
     * Define a query method as a thin stub to the runtime.
     * <p>
     * Uses MethodDelegation with a custom interceptor that uses reflection
     * to call the appropriate runtime method.
     * <p>
     * TODO: Use ReturnKind + arity + opCode to determine runtime method,
     * instead of inferring from names.
     */
    private DynamicType.Builder<?> defineQueryMethod(
            DynamicType.Builder<?> builder,
            Method method,
            int queryId,
            ReturnKind returnKind) {

        String runtimeMethod = determineRuntimeMethod(returnKind, method.getParameterCount());

        return builder.defineMethod(method.getName(), method.getReturnType(), Visibility.PUBLIC)
                .withParameters(method.getParameterTypes())
                .intercept(MethodDelegation.to(new MethodInterceptor(queryId, runtimeMethod)));
    }

    /**
     * Determine which runtime method to call based on return type and arity.
     * <p>
     * Unified entrypoints - all operations (query + CRUD) with same return type
     * use the same runtime method. ReturnKind determines the actual operation.
     * <p>
     * TODO: Use opCode + ReturnKind for dispatch instead of relying on name inference.
     */
    private String determineRuntimeMethod(ReturnKind returnKind, int arity) {
        // CRUD operations return void - use execute methods
        if (returnKind == ReturnKind.SAVE ||
            returnKind == ReturnKind.SAVE_ALL ||
            returnKind == ReturnKind.DELETE ||
            returnKind == ReturnKind.DELETE_ALL ||
            returnKind == ReturnKind.DELETE_BY_ID) {
            return "execute" + arity;
        }

        // Query operations - use typed methods
        return switch (returnKind) {
            case ONE_OPTIONAL -> "optional" + arity;
            case MANY_LIST -> "list" + arity;
            case EXISTS_BOOL -> "exists" + arity;
            case COUNT_LONG -> "count" + arity;
            default -> throw new IllegalArgumentException("Unknown return kind: " + returnKind);
        };
    }

    /**
     * Interceptor that delegates to the runtime using reflection.
     * <p>
     * Uses the stored queryId and runtimeMethodName to invoke the
     * appropriate method on RepositoryRuntime.
     * <p>
     * TODO: Generate bytecode that directly calls the appropriate runtime method
     * instead of using reflection.
     */
    public static class MethodInterceptor {
        private final int queryId;
        private final String runtimeMethodName;

        public MethodInterceptor(int queryId, String runtimeMethodName) {
            this.queryId = queryId;
            this.runtimeMethodName = runtimeMethodName;
        }

        @RuntimeType
        @SuppressWarnings("unchecked")
        public Object intercept(@This Object thiz, @AllArguments Object[] args) throws Exception {
            // Get runtime from generated field
            java.lang.reflect.Field rtField = thiz.getClass().getDeclaredField("rt");
            rtField.setAccessible(true);
            RepositoryRuntime runtime = (RepositoryRuntime) rtField.get(thiz);

            // Build argument array: queryId + method arguments
            Object[] runtimeArgs = new Object[args.length + 1];
            runtimeArgs[0] = queryId;
            System.arraycopy(args, 0, runtimeArgs, 1, args.length);

            // Find and invoke the runtime method
            for (Method m : RepositoryRuntime.class.getDeclaredMethods()) {
                if (m.getName().equals(runtimeMethodName) &&
                    m.getParameterCount() == runtimeArgs.length) {
                    m.setAccessible(true);
                    return m.invoke(runtime, runtimeArgs);
                }
            }

            throw new UnsupportedOperationException("Runtime method not found: " + runtimeMethodName);
        }
    }
}
