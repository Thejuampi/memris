package io.memris.spring.scaffold;

import java.lang.reflect.Method;
import java.util.Optional;

import io.memris.spring.plan.CompiledQuery;
import io.memris.spring.plan.LogicalQuery.ReturnKind;
import io.memris.spring.runtime.RepositoryRuntime;

import net.bytebuddy.ByteBuddy;
import net.bytebuddy.implementation.bind.annotation.This;
import net.bytebuddy.description.modifier.FieldManifestation;
import net.bytebuddy.description.modifier.Visibility;
import net.bytebuddy.dynamic.DynamicType;
import net.bytebuddy.implementation.FieldAccessor;
import net.bytebuddy.implementation.MethodDelegation;
import net.bytebuddy.implementation.bind.annotation.AllArguments;
import net.bytebuddy.implementation.bind.annotation.RuntimeType;

/**
 * Generates repository implementation class using ByteBuddy.
 * <p>
 * The generated class:
 * - Has one field: `private final RepositoryRuntime rt;`
 * - Has one constructor: `(RepositoryRuntime rt) { this.rt = rt; }`
 * - Has query methods as thin stubs that call runtime entrypoints with constant queryId
 * <p>
 * Example generated code:
 * <pre>{@code
 * public class PersonRepository$MemrisImpl implements PersonRepository {
 *   private final RepositoryRuntime rt;
 *
 *   public PersonRepository$MemrisImpl(RepositoryRuntime rt) {
 *     this.rt = rt;
 *   }
 *
 *   public Optional<Person> findById(Long id) {
 *     return rt.optional1(0, id);  // queryId=0, constant
 *   }
 *
 *   public List<Person> findByName(String name) {
 *     return rt.list1(1, name);  // queryId=1, constant
 *   }
 *
 *   public long countByAge(int age) {
 *     return rt.count1(2, age);  // queryId=2, constant
 *   }
 * }
 * }</pre>
 * <p>
 * <b>Key optimization:</b> queryId is a constant embedded in the generated bytecode,
 * enabling O(1) array lookup in RepositoryRuntime without any runtime parsing.
 */
public final class RepositoryEmitter {

    private final ByteBuddy byteBuddy = new ByteBuddy();

    /**
     * Emit and instantiate a repository implementation.
     *
     * @param repositoryInterface the repository interface to implement
     * @param entityClass the entity class
     * @param runtime the pre-built RepositoryRuntime
     * @param compiledQueries the compiled queries (indexed by queryId)
     * @return an instantiated repository instance
     */
    @SuppressWarnings("unchecked")
    public <T, R> R emitAndInstantiate(
            Class<R> repositoryInterface,
            Class<T> entityClass,
            RepositoryRuntime<T> runtime,
            CompiledQuery[] compiledQueries) {

        String implClassName = repositoryInterface.getSimpleName() + "$MemrisImpl";

        try {
            DynamicType.Builder<?> builder = byteBuddy
                    .subclass(repositoryInterface)
                    .name(repositoryInterface.getPackage().getName() + "." + implClassName);

            // Add runtime field
            builder = builder.defineField("rt", RepositoryRuntime.class, Visibility.PRIVATE, FieldManifestation.FINAL);

            // Add constructor: calls super() then sets the field
            builder = builder.defineConstructor(Visibility.PUBLIC)
                    .withParameters(RepositoryRuntime.class)
                    .intercept(net.bytebuddy.implementation.MethodCall.invoke(Object.class.getDeclaredConstructor())
                            .andThen(FieldAccessor.ofField("rt").setsArgumentAt(0)));

            // Add query methods
            for (int queryId = 0; queryId < compiledQueries.length; queryId++) {
                CompiledQuery cq = compiledQueries[queryId];
                Method method = findMethod(repositoryInterface, cq.methodName());
                if (method != null) {
                    builder = defineQueryMethod(builder, method, queryId, cq.returnKind());
                }
            }

            // Build and load using injection strategy to avoid classloader isolation
            DynamicType.Unloaded<?> unloaded = builder.make();
            Class<?> generatedClass = unloaded.load(
                    repositoryInterface.getClassLoader(),
                    net.bytebuddy.dynamic.loading.ClassLoadingStrategy.Default.INJECTION
            ).getLoaded();

            // Instantiate with runtime
            return (R) generatedClass.getDeclaredConstructor(RepositoryRuntime.class)
                    .newInstance(runtime);

        } catch (Throwable t) {
            throw new RuntimeException("Failed to generate repository: " + implClassName, t);
        }
    }

    /**
     * Define a query method as a thin stub to the runtime.
     * <p>
     * Uses MethodDelegation with a custom interceptor that uses reflection
     * to call the appropriate runtime method.
     */
    private DynamicType.Builder<?> defineQueryMethod(
            DynamicType.Builder<?> builder,
            Method method,
            int queryId,
            ReturnKind returnKind) {

        String runtimeMethod = determineRuntimeMethod(returnKind, method.getParameterCount());

        return builder.defineMethod(method.getName(), method.getReturnType(), Visibility.PUBLIC)
                .withParameters(method.getParameterTypes())
                .intercept(MethodDelegation.to(new MethodInterceptor(queryId, runtimeMethod)));
    }

    /**
     * Determine which runtime method to call based on return kind and arity.
     */
    private String determineRuntimeMethod(ReturnKind returnKind, int arity) {
        return switch (returnKind) {
            case ONE_OPTIONAL -> "optional1";
            case MANY_LIST -> "list" + arity;
            case EXISTS_BOOL -> "exists1";
            case COUNT_LONG -> "count" + arity;
        };
    }

    /**
     * Find a method in the interface by name.
     */
    private Method findMethod(Class<?> iface, String methodName) {
        for (Method method : iface.getDeclaredMethods()) {
            if (method.getName().equals(methodName)) {
                return method;
            }
        }
        return null;
    }

    /**
     * Interceptor that delegates to the runtime using reflection.
     * <p>
     * Uses the stored queryId and runtimeMethodName to invoke the
     * appropriate method on RepositoryRuntime.
     */
    public static class MethodInterceptor {
        private final int queryId;
        private final String runtimeMethodName;

        public MethodInterceptor(int queryId, String runtimeMethodName) {
            this.queryId = queryId;
            this.runtimeMethodName = runtimeMethodName;
        }

        @RuntimeType
        @SuppressWarnings("unchecked")
        public Object intercept(@This Object thiz, @AllArguments Object[] args) throws Exception {
            // Get runtime from generated field
            RepositoryRuntime runtime = (RepositoryRuntime) thiz.getClass()
                    .getDeclaredField("rt").get(thiz);

            // Build argument array: queryId + method arguments
            Object[] runtimeArgs = new Object[args.length + 1];
            runtimeArgs[0] = queryId;
            System.arraycopy(args, 0, runtimeArgs, 1, args.length);

            // Find and invoke the runtime method
            for (Method m : RepositoryRuntime.class.getDeclaredMethods()) {
                if (m.getName().equals(runtimeMethodName) &&
                    m.getParameterCount() == runtimeArgs.length) {
                    m.setAccessible(true);
                    return m.invoke(runtime, runtimeArgs);
                }
            }

            throw new UnsupportedOperationException("Runtime method not found: " + runtimeMethodName);
        }
    }
}
