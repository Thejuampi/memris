package io.memris.spring.runtime;

import io.memris.spring.plan.CompiledQuery;
import io.memris.storage.ffm.FfmTable;

/**
 * RepositoryPlan is the single compiled artifact created ONCE at repository creation time.
 * <p>
 * This class enforces the "compile once, reuse forever" principle by holding all
 * pre-compiled data needed for runtime execution. Once built, this plan is immutable
 * and used for all query executions.
 * <p>
 * <b>Build-time components:</b>
 * <ul>
 *   <li>CompiledQuery[] - All query methods compiled to index-based conditions</li>
 *   <li>EntityMaterializer - Generated bytecode for entity construction</li>
 *   <li>EntityExtractor - Generated bytecode for entity field extraction</li>
 *   <li>RuntimeKernel - Index-based column access wrapper</li>
 * </ul>
 *
 * @param <T> the entity type
 * @see RuntimeKernel
 * @see CompiledQuery
 */
public final class RepositoryPlan<T> {

    private final Class<T> entityClass;
    private final CompiledQuery[] queries;
    private final RuntimeKernel kernel;
    private final EntityMaterializer<T> materializer;
    private final EntityExtractor<T> extractor;

    private RepositoryPlan(Builder<T> builder) {
        this.entityClass = builder.entityClass;
        this.queries = builder.queries;
        this.kernel = builder.kernel;
        this.materializer = builder.materializer;
        this.extractor = builder.extractor;
    }

    /**
     * Get the entity class.
     *
     * @return entity class
     */
    public Class<T> entityClass() {
        return entityClass;
    }

    /**
     * Get compiled queries array indexed by queryId.
     *
     * @return compiled queries
     */
    public CompiledQuery[] queries() {
        return queries;
    }

    /**
     * Get runtime kernel for index-based column access.
     *
     * @return runtime kernel
     */
    public RuntimeKernel kernel() {
        return kernel;
    }

    /**
     * Get entity materializer for entity construction.
     *
     * @return entity materializer
     */
    public EntityMaterializer<T> materializer() {
        return materializer;
    }

    /**
     * Get entity extractor for field extraction.
     *
     * @return entity extractor
     */
    public EntityExtractor<T> extractor() {
        return extractor;
    }

    /**
     * Create a new builder.
     *
     * @param <T> the entity type
     * @return a new builder
     */
    public static <T> Builder<T> builder(Class<T> entityClass) {
        return new Builder<>(entityClass);
    }

    /**
     * Create a RepositoryPlan from legacy parameters.
     * <p>
     * This is a temporary bridge method for backward compatibility during migration.
     * Once scaffolder is updated to build RepositoryPlan directly, this should be removed.
     *
     * @param <T>               the entity type
     * @param table             the FfmTable
     * @param entityClass       the entity class
     * @param idColumnName      the ID column name
     * @param compiledQueries   the compiled queries
     * @param entityConstructor the entity constructor handle
     * @param columnNames       the column names array
     * @param typeCodes         the type codes array
     * @param converters        the type converters array
     * @param setters           the setter handles array
     * @return a RepositoryPlan built from legacy parameters
     */
    @SuppressWarnings({"unchecked", "JavaUtilDate"})
    public static <T> RepositoryPlan<T> fromLegacy(
            FfmTable table,
            Class<T> entityClass,
            String idColumnName,
            CompiledQuery[] compiledQueries,
            java.lang.invoke.MethodHandle entityConstructor,
            String[] columnNames,
            byte[] typeCodes,
            io.memris.spring.converter.TypeConverter<?, ?>[] converters,
            java.lang.invoke.MethodHandle[] setters) {

        // Build RuntimeKernel from legacy parameters
        RuntimeKernel runtimeKernel = RuntimeKernel.fromLegacy(table, columnNames, typeCodes);

        // TODO: Build proper EntityMaterializer from legacy parameters
        // For now, create a simple materializer that uses the legacy approach
        EntityMaterializer<T> materializer = (kernel, rowIndex) -> {
            try {
                T entity = (T) entityConstructor.invoke();
                for (int i = 0; i < columnNames.length; i++) {
                    RuntimeKernel.FfmColumnAccessor accessor = kernel.columnAt(i);
                    Object value = accessor.getValue(rowIndex);
                    if (converters[i] != null) {
                        value = ((io.memris.spring.converter.TypeConverter<Object, Object>) converters[i]).fromStorage(value);
                    }
                    if (setters[i] != null) {
                        setters[i].invoke(entity, value);
                    }
                }
                return entity;
            } catch (Throwable e) {
                throw new RuntimeException("Failed to materialize entity", e);
            }
        };

        // TODO: Build proper EntityExtractor from legacy parameters
        // For now, create a simple extractor that reads via reflection (to be replaced)
        EntityExtractor<T> extractor = entity -> {
            Object[] values = new Object[columnNames.length];
            for (int i = 0; i < columnNames.length; i++) {
                try {
                    // For now, use reflection to read field values
                    // TODO: Replace with proper pre-bound handles
                    java.lang.reflect.Field field = entityClass.getDeclaredField(columnNames[i]);
                    field.setAccessible(true);
                    Object value = field.get(entity);
                    if (converters[i] != null) {
                        value = ((io.memris.spring.converter.TypeConverter<Object, Object>) converters[i]).toStorage(value);
                    }
                    values[i] = value;
                } catch (Throwable e) {
                    throw new RuntimeException("Failed to extract field", e);
                }
            }
            return values;
        };

        return RepositoryPlan.<T>builder(entityClass)
                .queries(compiledQueries)
                .kernel(runtimeKernel)
                .materializer(materializer)
                .extractor(extractor)
                .build();
    }

    /**
     * Builder for RepositoryPlan.
     */
    public static final class Builder<T> {
        private Class<T> entityClass;
        private CompiledQuery[] queries;
        private RuntimeKernel kernel;
        private EntityMaterializer<T> materializer;
        private EntityExtractor<T> extractor;

        private Builder(Class<T> entityClass) {
            this.entityClass = entityClass;
        }

        public Builder<T> queries(CompiledQuery[] queries) {
            this.queries = queries;
            return this;
        }

        public Builder<T> kernel(RuntimeKernel kernel) {
            this.kernel = kernel;
            return this;
        }

        public Builder<T> materializer(EntityMaterializer<T> materializer) {
            this.materializer = materializer;
            return this;
        }

        public Builder<T> extractor(EntityExtractor<T> extractor) {
            this.extractor = extractor;
            return this;
        }

        /**
         * Build the immutable RepositoryPlan.
         *
         * @return the built plan
         * @throws IllegalStateException if required fields are missing
         */
        public RepositoryPlan<T> build() {
            if (entityClass == null) {
                throw new IllegalStateException("entityClass required");
            }
            if (queries == null) {
                throw new IllegalStateException("queries required");
            }
            if (kernel == null) {
                throw new IllegalStateException("kernel required");
            }
            if (materializer == null) {
                throw new IllegalStateException("materializer required");
            }
            if (extractor == null) {
                throw new IllegalStateException("extractor required");
            }
            return new RepositoryPlan<>(this);
        }
    }
}
